      SUBROUTINE F11JBF(N,A,LA,IROW,ICOL,IPIV,ISTR,CHECK,Y,X,IFAIL)
C     MARK 17 RELEASE. NAG COPYRIGHT 1995.
C
C     Purpose
C     =======
C     F11JBF solves a system of equations
C
C              Mx = y
C
C     involving the preconditioning matrix:
C
C                         T T
C              M = P L D L P
C
C     corresponding to an incomplete Cholesky decomposition of a sparse
C     symmetric matrix stored in SCS format, as generated by F11JAF.
C
C     In the above decomposition L is a lower triangular sparse matrix
C     with unit diagonals, D is a diagonal matrix and P is a permutation
C     matrix. L and D are supplied to F11JBF through the matrix
C                       -1
C              C = L + D  - I
C
C     which is a lower triangular NxN sparse matrix, stored in SCS
C     format as returned by F11JAF. The permutation matrix P is
C     returned from F11JAF via the array IPIV.
C
C     Arguments
C     =========
C
C     N      (input) INTEGER
C            On entry, the order of the matrix C.
C            N >= 1.
C
C     A      (input) DOUBLE PRECISION array, dimension (LA)
C            On entry, A must be unchanged from the value returned from
C            a previous call to F11JAF.
C
C     LA     (input) INTEGER
C            On entry, the dimension of the arrays A, IROW and ICOL
C            as declared in the (sub)program from which F11JBF is
C            called. This should be the same value as was supplied
C            in the preceeding call to F11JAF.
C
C     IROW   (input) INTEGER array, dimension (LA)
C     ICOL   (input) INTEGER array, dimension (LA)
C     IPIV   (input) INTEGER array, dimension (N)
C     ISTR   (input) INTEGER array, dimension (N+1)
C            On entry, IROW, ICOL, IPIV, ISTR must be unchanged from
C            the values returned from a previous call to F11JAF.
C
C     CHECK  (input) CHARACTER*1
C            On entry, specifies whether or not the input data should
C            be checked.
C               CHECK = 'C'  => checks are carried on the values of
C                               N, IROW, ICOL, IPIV and ISTR.
C               CHECK = 'N'  => no checks are carried out.
C            CHECK = 'C' or 'N'.
C
C     Y      (input) DOUBLE PRECISION array, dimension (N)
C            On entry, the vector y.
C
C     X      (output) DOUBLE PRECISION array, dimension (N)
C            On exit, the vector x.
C
C     IFAIL  (input/output) INTEGER
C            On entry, IFAIL must be -1, 0, or 1.
C            On exit, the following values may occur:
C               IFAIL = 0 => no error detected.
C               IFAIL = 1 => CHECK .ne. 'C' or 'N'.
C               IFAIL = 2 => N < 1.
C               IFAIL = 3 => the SCS representation of the
C                            preconditioning matrix M is invalid.
C                            Check that the call to F11JBF has been
C                            preceeded by a valid call to F11JAF, and
C                            that the arrays A, IROW, ICOL, IPIV and
C                            ISTR have not been corrupted between the
C                            two calls.
C
C     ==================================================================
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F11JBF')
C     .. Scalar Arguments ..
      INTEGER           IFAIL, LA, N
      CHARACTER         CHECK
C     .. Array Arguments ..
      DOUBLE PRECISION  A(LA), X(N), Y(N)
      INTEGER           ICOL(LA), IPIV(N), IROW(LA), ISTR(N+1)
C     .. Local Scalars ..
      INTEGER           I, IBAD, ICJ, IERR, IERROR, IPI, IRI, J, K, NNZ,
     *                  NREC
      LOGICAL           CK, IPIVOK, SYM
C     .. Local Arrays ..
      CHARACTER*80      REC(4)
C     .. External Functions ..
      INTEGER           P01ABF
      EXTERNAL          P01ABF
C     .. External Subroutines ..
      EXTERNAL          F11JAZ, M01EAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Executable Statements ..
C
      IERR = 0
      IPIVOK = .TRUE.
C
C     Check CHECK.
C
      IF (CHECK.EQ.'C' .OR. CHECK.EQ.'c') THEN
         CK = .TRUE.
      ELSE IF (CHECK.EQ.'N' .OR. CHECK.EQ.'n') THEN
         CK = .FALSE.
      ELSE
         IERR = 1
         NREC = 1
         WRITE (REC,FMT=99999) CHECK
         GO TO 200
      END IF
C
      IF (CK) THEN
C
C         Check the SCS representation of the matrix C.
C
         SYM = .TRUE.
         K = ISTR(1)
         NNZ = ISTR(N+1) - ISTR(1)
C
         CALL F11JAZ(N,NNZ,IROW(K),ICOL(K),SYM,IBAD,IERROR)
C
         IBAD = IBAD + K - 1
C
         IF (IERROR.EQ.1) THEN
            IERR = 2
            NREC = 1
            WRITE (REC,FMT=99998) N
            GO TO 200
         END IF
C
         IF (IERROR.EQ.2 .OR. IERROR.EQ.3) THEN
            IERR = 3
            NREC = 3
            WRITE (REC,FMT=99997)
            GO TO 200
         END IF
C
         IF (IERROR.EQ.4) THEN
            IERR = 3
            NREC = 4
            WRITE (REC,FMT=99996) IBAD, IROW(IBAD), N
            GO TO 200
         END IF
C
         IF (IERROR.EQ.5) THEN
            IERR = 3
            NREC = 4
            WRITE (REC,FMT=99995) IBAD, ICOL(IBAD), IROW(IBAD)
            GO TO 200
         END IF
C
         IF (IERROR.EQ.6) THEN
            IERR = 3
            NREC = 4
            WRITE (REC,FMT=99994) IBAD
            GO TO 200
         END IF
C
         IF (IERROR.EQ.7) THEN
            IERR = 3
            NREC = 4
            WRITE (REC,FMT=99993) IBAD
            GO TO 200
         END IF
C
C         Check consistency of ISTR with IROW.
C
         DO 20 I = K + 1, K + NNZ - 1
            IRI = IROW(I)
            IF (IRI.GT.IROW(I-1)) THEN
               IF (ISTR(IRI).NE.I) THEN
                  IERR = 3
                  NREC = 4
                  WRITE (REC,FMT=99992) IRI
                  GO TO 200
               END IF
            END IF
   20    CONTINUE
C
C         Check that IPIV is a valid permutation
C         of the integers in [1,N].
C
         DO 40 I = 1, N
            ISTR(I) = -ISTR(I)
   40    CONTINUE
C
         DO 60 I = 1, N
            IPI = IPIV(I)
            IF (IPI.LT.1 .OR. IPI.GT.N) THEN
               IPIVOK = .FALSE.
               IERR = 3
               NREC = 4
               WRITE (REC,FMT=99991) I, IPI, N
               GO TO 200
            END IF
            ISTR(IPI) = -ISTR(IPI)
            IF (ISTR(IPI).LT.0) THEN
               IPIVOK = .FALSE.
               IERR = 3
               NREC = 4
               WRITE (REC,FMT=99990) I
               GO TO 200
            END IF
   60    CONTINUE
C
      END IF
C
C     Solve the linear system Mx = y.
C
C          T
C     x = P y.
C
      DO 80 I = 1, N
         X(I) = Y(IPIV(I))
   80 CONTINUE
C
C          -1
C     x = L  x.
C
      DO 120 I = 2, N
         DO 100 J = ISTR(I), ISTR(I+1) - 2
            ICJ = ICOL(J)
            X(I) = X(I) - A(J)*X(ICJ)
  100    CONTINUE
  120 CONTINUE
C
C          -1
C     x = D  x.
C
      DO 140 I = 1, N
         X(I) = A(ISTR(I+1)-1)*X(I)
  140 CONTINUE
C
C          -T
C     x = L  x.
C
      DO 180 I = N, 2, -1
         DO 160 J = ISTR(I), ISTR(I+1) - 2
            ICJ = ICOL(J)
            X(ICJ) = X(ICJ) - A(J)*X(I)
  160    CONTINUE
  180 CONTINUE
C
C     x = P x.
C
      IERROR = 0
      CALL M01EAF(X,1,N,IPIV,IERROR)
C
  200 CONTINUE
C
C     Reset ISTR if necessary.
C
      IF ( .NOT. IPIVOK) THEN
         DO 220 I = 1, N
            ISTR(I) = ABS(ISTR(I))
  220    CONTINUE
      END IF
C
      IFAIL = P01ABF(IFAIL,IERR,SRNAME,NREC,REC)
      RETURN
C
99999 FORMAT (1X,'** On entry, CHECK .ne. ''C'' or ''N'': CHECK = ''',A,
     *       '''.')
99998 FORMAT (1X,'** On entry, N .lt. 1: N =',I16,'.')
99997 FORMAT (1X,'** On entry, ISTR appears to be invalid.',/4X,'Check',
     *       ' that A, IROW, ICOL, IPIV and ISTR have not been',/4X,
     *       'corrupted between calls to F11JAF and F11JBF.')
99996 FORMAT (1X,'** On entry, IROW(I) .lt. 1 or IROW(I) .gt. N:',/4X,
     *       'I = ',I16,', IROW(I) = ',I16,', N = ',I16,'.',/4X,'Check',
     *       ' that A, IROW, ICOL, IPIV and ISTR have not been',/4X,
     *       'corrupted between calls to F11JAF and F11JBF.')
99995 FORMAT (1X,'** On entry, ICOL(I) .lt. 1 or ICOL(I) .gt. IROW(I):',
     *       /4X,'I =',I16,', ICOL(I) =',I16,', IROW(I) =',I16,'.',/4X,
     *       'Check that A, IROW, ICOL, IPIV and ISTR have not been',
     *       /4X,'corrupted between calls to F11JAF and F11JBF.')
99994 FORMAT (1X,'** On entry, A(I) is out of order:',/4X,'I =',I16,'.',
     *       /4X,'Check that A, IROW, ICOL, IPIV and ISTR have not been'
     *       ,/4X,'corrupted between calls to F11JAF and F11JBF.')
99993 FORMAT (1X,'** On entry, the location (IROW(I), ICOL(I)) is a ',
     *       'duplicate:',/4X,'I =',I16,'.',/4X,'Check that A, IROW, I',
     *       'COL, IPIV and ISTR have not been',/4X,'corrupted between',
     *       ' calls to F11JAF and F11JBF.')
99992 FORMAT (1X,'** On entry, ISTR(I) is inconsistent with IROW:',/4X,
     *       'I =',I16,'.',/4X,'Check that A, IROW, ICOL, IPIV and IST',
     *       'R have not been',/4X,'corrupted between calls to F11JAF ',
     *       'and F11JBF.')
99991 FORMAT (1X,'** On entry, IPIV(I) .lt. 1 or IPIV(I) .gt. N:',/4X,
     *       'I =',I16,', IPIV(I) =',I16,', N =',I16,'.',/4X,'Check th',
     *       'at A, IROW, ICOL, IPIV and ISTR have not been',/4X,'corr',
     *       'upted between calls to F11JAF and F11JBF.')
99990 FORMAT (1X,'** On entry, IPIV(I) is a repeated value:',/4X,'I =',
     *       I16,'.',/4X,'Check that A, IROW, ICOL, IPIV and ISTR have',
     *       ' not been',/4X,'corrupted between calls to F11JAF and F1',
     *       '1JBF.')
      END
