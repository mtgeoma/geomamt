      SUBROUTINE F08PSF(JOB,COMPZ,N,ILO,IHI,H,LDH,W,Z,LDZ,WORK,LWORK,
     *                  INFO)
C     MARK 16 RELEASE. NAG COPYRIGHT 1992.
C     .. Entry Points ..
      ENTRY             ZHSEQR(JOB,COMPZ,N,ILO,IHI,H,LDH,W,Z,LDZ,WORK,
     *                  LWORK,INFO)
C
C  Purpose
C  =======
C
C  ZHSEQR computes the eigenvalues of a complex upper Hessenberg
C  matrix H, and, optionally, the matrices T and Z from the Schur
C  decomposition H = Z T Z', where T is an upper triangular matrix
C  (the Schur form), Z is the unitary matrix of Schur vectors, and Z'
C  denotes the conjugate transpose of Z.
C
C  Optionally Z may be postmultiplied into an input unitary matrix Q,
C  so that this routine can give the Schur factorization of a matrix A
C  which has been reduced to the Hessenberg form H by the unitary
C  matrix Q:  A = Q*H*Q' = (QZ)*T*(QZ)'.
C
C  Arguments
C  =========
C
C  JOB     (input) CHARACTER*1
C          = 'E': compute eigenvalues only;
C          = 'S': compute eigenvalues and the Schur form T.
C
C  COMPZ   (input) CHARACTER*1
C          = 'N': no Schur vectors are computed;
C          = 'I': Z is initialized to the unit matrix and the matrix Z
C                 of Schur vectors of H is returned;
C          = 'V': Z must contain an unitary matrix Q on entry, and
C                 the product Q*Z is returned.
C
C  N       (input) INTEGER
C          The order of the matrix H.  N >= 0.
C
C  ILO     (input) INTEGER
C  IHI     (input) INTEGER
C          It is assumed that H is already upper triangular in rows
C          and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
C          set by a previous call to ZGEBAL, and then passed to ZGEHRD
C          when the matrix output by ZGEBAL is reduced to Hessenberg
C          form. Otherwise ILO and IHI should be set to 1 and N
C          respectively.
C          1 <= ILO <= max(1,IHI); IHI <= N.
C
C  H       (input/output) COMPLEX*16 array, dimension (LDH,N)
C          On entry, the upper Hessenberg matrix H.
C          On exit, if JOB = 'S', H contains the upper triangular matrix
C          T from the Schur decomposition (the Schur form). If
C          JOB = 'E', the contents of H are unspecified on exit.
C
C  LDH     (input) INTEGER
C          The leading dimension of the array H. LDH >= max(1,N).
C
C  W       (output) COMPLEX*16 array, dimension (N)
C          The computed eigenvalues. If JOB = 'S', the eigenvalues are
C          stored in the same order as on the diagonal of the Schur form
C          returned in H, with W(i) = H(i,i).
C
C  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
C          If COMPZ = 'N': Z is not referenced.
C          If COMPZ = 'I': on entry, Z need not be set, and on exit, Z
C          contains the unitary matrix Z of the Schur vectors of H.
C          If COMPZ = 'V': on entry Z must contain an n-by-n matrix Q,
C          which is assumed to be equal to the unit matrix except for
C          the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
C          Normally Q is the unitary matrix generated by ZUNGHR after
C          the call to ZGEHRD which formed the Hessenberg matrix H.
C
C  LDZ     (input) INTEGER
C          The leading dimension of the array Z.
C          LDZ >= max(1,N) if COMPZ = 'I' or 'V'; LDZ >= 1 otherwise.
C
C  WORK    (workspace) COMPLEX*16 array, dimension (N)
C
C  LWORK   (input) INTEGER
C          This argument is now redundant.
C
C  INFO    (output) INTEGER
C          = 0: successful exit
C          < 0: if INFO = -i, the i-th argument had an illegal value
C          > 0: ZHSEQR failed to compute all the eigenvalues in a total
C               of 30*(IHI-ILO+1) iterations; if INFO = i, elements
C               1:ilo-1 and i+1:n of W contain those eigenvalues which
C               have been successfully computed.
C
C  -- LAPACK routine (adapted for NAG Library)
C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
C     Courant Institute, Argonne National Lab, and Rice University
C
C  =====================================================================
C
C     .. Parameters ..
      COMPLEX*16        ZERO, ONE
      PARAMETER         (ZERO=0.0D+0,ONE=1.0D+0)
      DOUBLE PRECISION  RZERO, RONE, CONST
      PARAMETER         (RZERO=0.0D+0,RONE=1.0D+0,CONST=1.5D+0)
      INTEGER           NSMAX, LDS
      PARAMETER         (NSMAX=15,LDS=NSMAX)
C     .. Scalar Arguments ..
      INTEGER           IHI, ILO, INFO, LDH, LDZ, LWORK, N
      CHARACTER         COMPZ, JOB
C     .. Array Arguments ..
      COMPLEX*16        H(LDH,*), W(*), WORK(*), Z(LDZ,*)
C     .. Local Scalars ..
      COMPLEX*16        CDUM, TAU, TEMP
      DOUBLE PRECISION  OVFL, RTEMP, SMLNUM, TST1, ULP, UNFL
      INTEGER           I, I1, I2, IERR, II, ITEMP, ITN, ITS, J, K, L,
     *                  MAXB, NH, NR, NS, NV
      LOGICAL           INITZ, WANTT, WANTZ
C     .. Local Arrays ..
      COMPLEX*16        S(LDS,NSMAX), V(NSMAX+1), VV(NSMAX+1)
      DOUBLE PRECISION  RWORK(1)
C     .. External Functions ..
      DOUBLE PRECISION  F06BNF, F06UMF, X02AJF, X02AMF
      INTEGER           IZAMAX, X02BHF
      EXTERNAL          F06BNF, F06UMF, X02AJF, X02AMF, IZAMAX, X02BHF
C     .. External Subroutines ..
      EXTERNAL          F06AAZ, F06TFF, F06THF, F07ZAZ, F08ASV, F08PSW,
     *                  F08PSZ, ZCOPY, ZDSCAL, ZGEMV, ZSCAL
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, DBLE, DCONJG, DIMAG, MAX, MIN
C     .. Statement Functions ..
      DOUBLE PRECISION  CABS1
C     .. Statement Function definitions ..
      CABS1(CDUM) = ABS(DBLE(CDUM)) + ABS(DIMAG(CDUM))
C     .. Executable Statements ..
C
C     Decode and test the input parameters
C
      WANTT = (JOB.EQ.'S' .OR. JOB.EQ.'s')
      INITZ = (COMPZ.EQ.'I' .OR. COMPZ.EQ.'i')
      WANTZ = INITZ .OR. (COMPZ.EQ.'V' .OR. COMPZ.EQ.'v')
C
      INFO = 0
      IF ( .NOT. (JOB.EQ.'E' .OR. JOB.EQ.'e') .AND. .NOT. WANTT) THEN
         INFO = -1
      ELSE IF ( .NOT. (COMPZ.EQ.'N' .OR. COMPZ.EQ.'n')
     *         .AND. .NOT. WANTZ) THEN
         INFO = -2
      ELSE IF (N.LT.0) THEN
         INFO = -3
      ELSE IF (ILO.LT.1 .OR. ILO.GT.MAX(1,N)) THEN
         INFO = -4
      ELSE IF (IHI.LT.MIN(ILO,N) .OR. IHI.GT.N) THEN
         INFO = -5
      ELSE IF (LDH.LT.MAX(1,N)) THEN
         INFO = -7
      ELSE IF (LDZ.LT.1 .OR. WANTZ .AND. LDZ.LT.MAX(1,N)) THEN
         INFO = -10
      END IF
      IF (INFO.NE.0) THEN
         CALL F06AAZ('F08PSF/ZHSEQR',-INFO)
         RETURN
      END IF
C
C     Initialize Z, if necessary
C
      IF (INITZ) CALL F06THF('General',N,N,ZERO,ONE,Z,LDZ)
C
C     Store the eigenvalues isolated by ZGEBAL.
C
      DO 20 I = 1, ILO - 1
         W(I) = H(I,I)
   20 CONTINUE
      DO 40 I = IHI + 1, N
         W(I) = H(I,I)
   40 CONTINUE
C
C     Quick return if possible.
C
      IF (N.EQ.0) RETURN
      IF (ILO.EQ.IHI) THEN
         W(ILO) = H(ILO,ILO)
         RETURN
      END IF
C
C     Set rows and columns ILO to IHI to zero below the first
C     subdiagonal.
C
      DO 80 J = ILO, IHI - 2
         DO 60 I = J + 2, N
            H(I,J) = ZERO
   60    CONTINUE
   80 CONTINUE
      NH = IHI - ILO + 1
C
C     I1 and I2 are the indices of the first row and last column of H
C     to which transformations must be applied. If eigenvalues only are
C     being computed, I1 and I2 are re-set inside the main loop.
C
      IF (WANTT) THEN
         I1 = 1
         I2 = N
      ELSE
         I1 = ILO
         I2 = IHI
      END IF
C
C     Ensure that the subdiagonal elements are real.
C
      DO 100 I = ILO + 1, IHI
         TEMP = H(I,I-1)
         IF (DIMAG(TEMP).NE.RZERO) THEN
            RTEMP = F06BNF(DBLE(TEMP),DIMAG(TEMP))
            H(I,I-1) = RTEMP
            TEMP = TEMP/RTEMP
            IF (I2.GT.I) CALL ZSCAL(I2-I,DCONJG(TEMP),H(I,I+1),LDH)
            CALL ZSCAL(I-I1,TEMP,H(I1,I),1)
            IF (I.LT.IHI) H(I+1,I) = TEMP*H(I+1,I)
            IF (WANTZ) CALL ZSCAL(NH,TEMP,Z(ILO,I),1)
         END IF
  100 CONTINUE
C
C     Determine the order of the multi-shift QR algorithm to be used.
C
      CALL F07ZAZ(4,'F08PSF',NS,0)
      CALL F07ZAZ(8,'F08PSF',MAXB,0)
      IF (NS.LE.1 .OR. NS.GT.NH .OR. MAXB.GE.NH) THEN
C
C        Use the standard double-shift algorithm
C
         CALL F08PSZ(WANTT,WANTZ,N,ILO,IHI,H,LDH,W,ILO,IHI,Z,LDZ,INFO)
         GO TO 360
      END IF
      MAXB = MAX(2,MAXB)
      NS = MIN(NS,MAXB,NSMAX)
C
C     Now 1 < NS <= MAXB < NH.
C
C     Set machine-dependent constants for the stopping criterion.
C     If norm(H) <= sqrt(OVFL), overflow should not occur.
C
      UNFL = X02AMF()
      OVFL = RONE/UNFL
      ULP = X02AJF()*X02BHF()
      SMLNUM = UNFL*(NH/ULP)
C
C     ITN is the total number of multiple-shift QR iterations allowed.
C
      ITN = 30*NH
C
C     The main loop begins here. I is the loop index and decreases from
C     IHI to ILO in steps of at most MAXB. Each iteration of the loop
C     works with the active submatrix in rows and columns L to I.
C     Eigenvalues I+1 to IHI have already converged. Either L = ILO, or
C     H(L,L-1) is negligible so that the matrix splits.
C
      I = IHI
  120 CONTINUE
      IF (I.LT.ILO) GO TO 360
C
C     Perform multiple-shift QR iterations on rows and columns ILO to I
C     until a submatrix of order at most MAXB splits off at the bottom
C     because a subdiagonal element has become negligible.
C
      L = ILO
      DO 320 ITS = 0, ITN
C
C        Look for a single small subdiagonal element.
C
         DO 140 K = I, L + 1, -1
            TST1 = CABS1(H(K-1,K-1)) + CABS1(H(K,K))
            IF (TST1.EQ.RZERO) TST1 = F06UMF('1',I-L+1,H(L,L),LDH,RWORK)
            IF (ABS(DBLE(H(K,K-1))).LE.MAX(ULP*TST1,SMLNUM)) GO TO 160
  140    CONTINUE
  160    CONTINUE
         L = K
         IF (L.GT.ILO) THEN
C
C           H(L,L-1) is negligible.
C
            H(L,L-1) = ZERO
         END IF
C
C        Exit from loop if a submatrix of order <= MAXB has split off.
C
         IF (L.GE.I-MAXB+1) GO TO 340
C
C        Now the active submatrix is in rows and columns L to I. If
C        eigenvalues only are being computed, only the active submatrix
C        need be transformed.
C
         IF ( .NOT. WANTT) THEN
            I1 = L
            I2 = I
         END IF
C
         IF (ITS.EQ.20 .OR. ITS.EQ.30) THEN
C
C           Exceptional shifts.
C
            DO 180 II = I - NS + 1, I
               W(II) = CONST*(ABS(DBLE(H(II,II-1)))+ABS(DBLE(H(II,II))))
  180       CONTINUE
         ELSE
C
C           Use eigenvalues of trailing submatrix of order NS as shifts.
C
            CALL F06TFF('General',NS,NS,H(I-NS+1,I-NS+1),LDH,S,LDS)
            CALL F08PSZ(.FALSE.,.FALSE.,NS,1,NS,S,LDS,W(I-NS+1),1,NS,Z,
     *                  LDZ,IERR)
            IF (IERR.GT.0) THEN
C
C              If F08PSZ failed to compute all NS eigenvalues, use the
C              unconverged diagonal elements as the remaining shifts.
C
               DO 200 II = 1, IERR
                  W(I-NS+II) = S(II,II)
  200          CONTINUE
            END IF
         END IF
C
C        Form the first column of (G-w(1)) (G-w(2)) . . . (G-w(ns))
C        where G is the Hessenberg submatrix H(L:I,L:I) and w is
C        the vector of shifts (stored in W). The result is
C        stored in the local array V.
C
         V(1) = ONE
         DO 220 II = 2, NS + 1
            V(II) = ZERO
  220    CONTINUE
         NV = 1
         DO 260 J = I - NS + 1, I
            CALL ZCOPY(NV+1,V,1,VV,1)
            CALL ZGEMV('No transpose',NV+1,NV,ONE,H(L,L),LDH,VV,1,-W(J),
     *                 V,1)
            NV = NV + 1
C
C           Scale V(1:NV) so that max(abs(V(i))) = 1. If V is zero,
C           reset it to the unit vector.
C
            ITEMP = IZAMAX(NV,V,1)
            RTEMP = CABS1(V(ITEMP))
            IF (RTEMP.EQ.RZERO) THEN
               V(1) = ONE
               DO 240 II = 2, NV
                  V(II) = ZERO
  240          CONTINUE
            ELSE
               RTEMP = MAX(RTEMP,SMLNUM)
               CALL ZDSCAL(NV,RONE/RTEMP,V,1)
            END IF
  260    CONTINUE
C
C        Multiple-shift QR step
C
         DO 300 K = L, I - 1
C
C           The first iteration of this loop determines a reflection G
C           from the vector V and applies it from left and right to H,
C           thus creating a nonzero bulge below the subdiagonal.
C
C           Each subsequent iteration determines a reflection G to
C           restore the Hessenberg form in the (K-1)th column, and thus
C           chases the bulge one step toward the bottom of the active
C           submatrix. NR is the order of G.
C
            NR = MIN(NS+1,I-K+1)
            IF (K.GT.L) CALL ZCOPY(NR,H(K,K-1),1,V,1)
            CALL F08ASV(NR,V(1),V(2),1,TAU)
            IF (K.GT.L) THEN
               H(K,K-1) = V(1)
               DO 280 II = K + 1, I
                  H(II,K-1) = ZERO
  280          CONTINUE
            END IF
            V(1) = ONE
C
C           Apply G' from the left to transform the rows of the matrix
C           in columns K to I2.
C
            CALL F08PSW('Left',NR,I2-K+1,V,DCONJG(TAU),H(K,K),LDH,WORK)
C
C           Apply G from the right to transform the columns of the
C           matrix in rows I1 to min(K+NR,I).
C
            CALL F08PSW('Right',MIN(K+NR,I)-I1+1,NR,V,TAU,H(I1,K),LDH,
     *                  WORK)
C
            IF (WANTZ) THEN
C
C              Accumulate transformations in the matrix Z
C
               CALL F08PSW('Right',NH,NR,V,TAU,Z(ILO,K),LDZ,WORK)
            END IF
  300    CONTINUE
C
C        Ensure that H(I,I-1) is real.
C
         TEMP = H(I,I-1)
         IF (DIMAG(TEMP).NE.RZERO) THEN
            RTEMP = F06BNF(DBLE(TEMP),DIMAG(TEMP))
            H(I,I-1) = RTEMP
            TEMP = TEMP/RTEMP
            IF (I2.GT.I) CALL ZSCAL(I2-I,DCONJG(TEMP),H(I,I+1),LDH)
            CALL ZSCAL(I-I1,TEMP,H(I1,I),1)
            IF (WANTZ) THEN
               CALL ZSCAL(NH,TEMP,Z(ILO,I),1)
            END IF
         END IF
C
  320 CONTINUE
C
C     Failure to converge in remaining number of iterations
C
      INFO = I
      RETURN
C
  340 CONTINUE
C
C     A submatrix of order <= MAXB in rows and columns L to I has split
C     off. Use the double-shift QR algorithm to handle it.
C
      CALL F08PSZ(WANTT,WANTZ,N,L,I,H,LDH,W,ILO,IHI,Z,LDZ,INFO)
      IF (INFO.GT.0) RETURN
C
C     Decrement number of remaining iterations, and return to start of
C     the main loop with a new value of I.
C
      ITN = ITN - ITS
      I = L - 1
      GO TO 120
C
  360 CONTINUE
      IF (WANTZ) THEN
C
C        Normalize Schur vectors so that element of largest absolute
C        value is real and positive.
C
         DO 400 J = 1, N
            DO 380 I = 1, N
               WORK(I) = ABS(Z(I,J))
  380       CONTINUE
            II = IZAMAX(N,WORK,1)
            TEMP = Z(II,J)/DBLE(WORK(II))
            CALL ZSCAL(N,DCONJG(TEMP),Z(1,J),1)
            Z(II,J) = WORK(II)
            CALL ZSCAL(J-1,DCONJG(TEMP),H(1,J),1)
            IF (J.LT.N) CALL ZSCAL(N-J,TEMP,H(J,J+1),LDH)
  400    CONTINUE
      END IF
      RETURN
C
C     End of F08PSF (ZHSEQR)
C
      END
