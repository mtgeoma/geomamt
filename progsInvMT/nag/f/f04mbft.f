      SUBROUTINE F04MBF(N,B,X,APROD,MSOLVE,PRECON,SHIFT,RTOL,ITNLIM,
     *                  MSGLVL,ITN,ANORM,ACOND,RNORM,XNORM,WORK,RWORK,
     *                  LRWORK,IWORK,LIWORK,INFORM,IFAIL)
C     MARK 11 RELEASE. NAG COPYRIGHT 1983.
C     MARK 11B REVISED. IER-459 (SEP 1984).
C     MARK 11D REVISED. IER-472 (NOV 1985).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 13A REVISED. IER-622 (APR 1988).
C
C     DESCRIPTION
C     -----------
C
C     F04MBF  IS DESIGNED TO SOLVE THE SYSTEM OF LINEAR EQUATIONS
C
C                A*X = B
C
C     WHERE  A  IS AN  N*N  SYMMETRIC MATRIX AND  B  IS A GIVEN VECTOR.
C     THE MATRIX  A  IS NOT REQUIRED TO BE POSITIVE DEFINITE.
C     ( IF  A  IS KNOWN TO BE DEFINITE, THE METHOD OF CONJUGATE
C     GRADIENTS WILL USUALLY BE SOMEWHAT MORE EFFICIENT. )
C
C
C     THE MATRIX  A  IS INTENDED TO BE LARGE AND SPARSE.  IT IS ACCESSED
C     BY MEANS OF A SUBROUTINE CALL OF THE FORM
C
C                CALL APROD ( IFLAG, N, X, Y,
C                             RWORK, LRWORK, IWORK, LIWORK )
C
C     WHICH MUST RETURN THE PRODUCT  Y = A*X  FOR ANY GIVEN VECTOR  X.
C
C
C     MORE GENERALLY,  F04MBF  IS DESIGNED TO SOLVE THE SYSTEM
C
C                ( A - SHIFT*I )*X = B
C
C     WHERE   SHIFT  IS A SPECIFIED SCALAR VALUE.  IF  SHIFT  AND  B
C     ARE SUITABLY CHOSEN, THE COMPUTED VECTOR  X  MAY APPROXIMATE AN
C     EIGENVECTOR OF  A,  AS IN THE METHODS OF INVERSE ITERATION
C     AND/OR RAYLEIGH-QUOTIENT ITERATION.
C
C
C     AGAIN, THE MATRIX  ( A - SHIFT*I ) NEED NOT BE POSITIVE DEFINITE.
C     THE WORK PER ITERATION IS VERY SLIGHTLY LESS IF SHIFT = 0.
C
C     A FURTHER OPTION IS THAT OF PRECONDITIONING , WHICH MAY REDUCE
C     THE NUMBER OF ITERATIONS REQUIRED.  IF  M  IS A POSITIVE
C     DEFINITE MATRIX WHICH IS KNOWN TO APPROXIMATE  ( A - SHIFT*I )
C     IN SOME SENSE, AND IF SYSTEMS OF THE FORM  M*Y = X  CAN BE
C     SOLVED EFFICIENTLY, THE PARAMETERS  PRECON  AND  MSOLVE  MAY BE
C     USEFUL ( SEE BELOW ).  WHEN  PRECON = .TRUE. ,  F04MBF  WILL
C     IMPLICITLY SOLVE THE SYSTEM OF EQUATIONS
C
C        M**( -1/2 )*( A - SHIFT*I )*M**( -1/2 )*Y  =  M**( -1/2 )*B,
C
C     AND RETURN THE SOLUTION  X = M**( -1/2 )*Y.
C
C     PARAMETERS
C     ----------
C
C     N       INPUT      THE DIMENSION OF THE MATRIX  A.
C
C     B( N )  INPUT     THE RHS VECTOR  B.
C
C     X( N )  OUTPUT    RETURNS THE COMPUTED SOLUTION  X.
C
C     APROD   EXTERNAL   A SUBROUTINE DEFINING THE MATRIX  A.
C                        FOR A GIVEN VECTOR  X,  THE STATEMENT
C
C                           CALL APROD ( IFLAG, N, X, Y,
C                                        RWORK, LRWORK, IWORK, LIWORK )
C
C                        SHOULD RETURN THE PRODUCT  Y = A*X.
C                        APROD   MUST NOT ALTER THE VECTOR  X.
C
C     MSOLVE  EXTERNAL   AN OPTIONAL SUBROUTINE DEFINING A
C                        PRECONDITIONING MATRIX  M,  WHICH WILL USUALLY
C                        APPROXIMATE  ( A - SHIFT*I ) IN SOME SENSE.
C                        M  MUST BE POSITIVE DEFINITE.
C                        FOR A GIVEN VECTOR  X,  THE STATEMENT
C
C                           CALL MSOLVE( IFLAG, N, X, Y,
C                                        RWORK, LRWORK, IWORK, LIWORK )
C
C                        SHOULD SOLVE THE LINEAR SYSTEM  M*Y = X.
C                        MSOLVE  MUST NOT ALTER THE VECTOR  X.
C
C                        NOTE. THE PROGRAM CALLING  F04MBF  MUST
C                        DECLARE  APROD   AND  MSOLVE  TO BE EXTERNAL.
C
C     PRECON  INPUT      IF  PRECON = .TRUE. ,  PRECONDITIONING WILL
C                        BE INVOKED.  OTHERWISE, SUBROUTINE  MSOLVE
C                        WILL NOT BE REFERENCED.  IN THIS CASE THE
C                        ACTUAL PARAMETER CORRESPONDING TO  MSOLVE  MAY
C                        BE THE SAME AS THAT CORRESPONDING TO  APROD .
C
C     SHIFT   INPUT      SHOULD BE ZERO IF THE SYSTEM  A*X = B  IS TO
C                        BE SOLVED.  OTHERWISE  SHIFT  COULD BE AN
C                        APPROXIMATION TO AN EIGENVALUE OF  A,
C                        E.G. THE RAYLEIGH QUOTIENT
C                        B( T )*A*B/( B( T )*B )
C                        CORRESPONDING TO THE VECTOR  B.
C
C     RTOL    INPUT      A USER-SPECIFIED TOLERANCE.  F04MBF TERMINATES
C                        IF IT APPEARS THAT  NORM( RBAR ) IS SMALLER
C                        THAN RTOL*NORM( ABAR )*NORM( Y ),  WHERE
C                        ABAR  IS THE TRANSFORMED MATRIX OPERATOR
C
C                        ABAR = M**( -1/2 )*( A - SHIFT*I )*M**( -1/2 )
C
C                        AND  RBAR  IS THE TRANSFORMED RESIDUAL VECTOR
C
C                        RBAR = M**( -1/2 )*( B - ( A - SHIFT*I )*X )
C
C                        ( AND  M = I  IF  PRECON = .FALSE. ).
C
C     ITNLIM  INPUT      AN UPPER LIMIT ON THE NUMBER OF ITERATIONS.
C
C     MSGLVL  INPUT      DETERMINES THE LEVEL OF PRINTING.
C                        IF MSGLVL .GT. 1 THEN PROGRESS IS MONITERED
C                        BY PRINTING OUT A SUMMARY LINE PERIODICALLY.
C                        IF MSGLVL .GT. 0 THEN A SUMMARY IS PRINTED
C                        AT THE END OF THE ROUTINE.
C                        OUTPUT IS ON THE UNIT GIVEN BY X04ABF.
C
C     INFORM  OUTPUT     AN INTEGER GIVING THE REASON FOR TERMINATION...
C
C             0          B = 0,  SO THE EXACT SOLUTION IS  X = 0.
C                        NO ITERATIONS WERE PERFORMED.
C
C             1          NORM( RBAR ) APPEARS TO BE LESS THAN
C                        THE VALUE  RTOL*NORM( ABAR )*NORM( Y ).
C
C             2          NORM( RBAR ) APPEARS TO BE LESS THAN
C                        THE VALUE   EPS*NORM( ABAR )*NORM( Y ).
C                        THIS MEANS THAT THE RESIDUAL IS AS SMALL AS
C                        SEEMS REASONABLE ON THIS MACHINE.
C
C             3          NORM( ABAR )*NORM( Y ) EXCEEDS  NORM( B )/EPS,
C                        WHICH SHOULD INDICATE THAT  X  HAS ESSENTIALLY
C                        CONVERGED TO AN EIGENVECTOR OF  A
C                        CORRESPONDING TO THE EIGENVALUE  SHIFT.
C
C             4          THE ITERATION LIMIT WAS REACHED BEFORE ANY OF
C                        THE PREVIOUS CRITERIA WERE SATISFIED.
C
C             5          THE PRECONDITIONING MATRIX  M  DOES NOT APPEAR
C                        TO BE POSITIVE DEFINITE.  X  WILL NOT BE AN
C                        ACCEPTABLE SOLUTION.
C
C     ITN     OUTPUT     THE NUMBER OF ITERATIONS PERFORMED.
C
C     ANORM   OUTPUT     AN ESTIMATE OF THE NORM OF THE MATRIX OPERATOR
C                        ABAR = M**( -1/2 )*( A - SHIFT*I )*M**( -1/2 ).
C
C     ACOND   OUTPUT     AN ESTIMATE OF THE CONDITION OF  ABAR  ABOVE.
C                        THIS WILL USUALLY BE A SUBSTANTIAL
C                        UNDER-ESTIMATE OF THE TRUE CONDITION.
C
C     RNORM   OUTPUT     THE NORM OF THE FINAL RESIDUAL VECTOR,
C                        R = B - ( A - SHIFT*I )*X.
C
C     XNORM   OUTPUT     THE NORM OF THE FINAL SOLUTION VECTOR  X.
C
C     WORK    WORKSPACE  OF LENGTH AL LEAST 5*N.
C
C     REFERENCES
C     ----------
C
C     THIS ROUTINE IS DERIVED FROM THE SUBROUTINE  SYMMLQ  DESCRIBED IN
C     THE FOLLOWING REFERENCES...
C
C         C.C. PAIGE AND M.A. SAUNDERS,  SOLUTION OF SPARSE INDEFINITE
C         SYSTEMS OF EQUATIONS AND LEAST SQUARES PROBLEMS,
C         TECHNICAL REPORT STAN-CS-73-399, COMPUTER SCIENCE DEPARTMENT,
C         STANFORD UNIVERSITY, STANFORD, CALIFORNIA, NOVEMBER 1973.
C
C         C.C. PAIGE AND M.A. SAUNDERS,  SOLUTION OF SPARSE INDEFINITE
C         SYSTEMS OF LINEAR EQUATIONS,
C         SIAM J. NUMER. ANAL. 12, 4, SEPTEMBER 1975, PP. 617-629.
C
C         J.G. LEWIS,  ALGORITHMS FOR SPARSE MATRIX EIGENVALUE PROBLEMS,
C         TECHNICAL REPORT STAN-CS-77-595, COMPUTER SCIENCE DEPARTMENT,
C         STANFORD UNIVERSITY, STANFORD, CALIFORNIA, MARCH 1977.
C
C     FURTHER COMMENTS
C     ----------------
C
C     SYMMLQ.         VERSION DATED 13 OCT 1981.  MAS.
C     F04MBF.    THIS VERSION DATED 11 OCT 1983.  S.J.HAMMARLING
C     F04MBFT.   THIS VERSION DATED  3 JAN 1984.  S.J.HAMMARLING
C                SETS W(1)BAR = V(1).
C
C     THE VECTORS Y, V, R1, R2 AND W OF SYMMLQ HAVE BEEN COMBINED INTO
C     THE ARRAY WORK IN F04MBF AS FOLLOWS.
C
C      Y( I ) = WORK( I, 1 ),  I = 1, 2, ..., N
C      V( I ) = WORK( I, 2 ),  I = 1, 2, ..., N
C     R1( I ) = WORK( I, 3 ),  I = 1, 2, ..., N
C     R2( I ) = WORK( I, 4 ),  I = 1, 2, ..., N
C      W( I ) = WORK( I, 5 ),  I = 1, 2, ..., N.
C
C     IN ALL THE EMBEDDED COMMENTS IN THE CODE TAKE M = I IF
C     PRECON = .FALSE..
C
C     SUBROUTINES AND FUNCTIONS
C
C     USER               APROD , MSOLVE
C     BLAS               AXPY  , COPY  , DOT   , NRM2
C     NAG BLAS           CNSV  , NROT  , NROTG , SCMV
C     NAG                X02ZAZ
C     FORTRAN            ABS   , AMAX1 , AMIN1 , MOD   , SQRT
C
C     APROD, MSOLVE
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='F04MBF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ACOND, ANORM, RNORM, RTOL, SHIFT, XNORM
      INTEGER           IFAIL, INFORM, ITN, ITNLIM, LIWORK, LRWORK,
     *                  MSGLVL, N
      LOGICAL           PRECON
C     .. Array Arguments ..
      DOUBLE PRECISION  B(N), RWORK(LRWORK), WORK(N,5), X(N)
      INTEGER           IWORK(LIWORK)
C     .. Subroutine Arguments ..
      EXTERNAL          APROD, MSOLVE
C     .. Arrays in Common ..
      DOUBLE PRECISION  WMACH(15)
C     .. Local Scalars ..
      DOUBLE PRECISION  ALFA, BESTNM, BETA, BETA1, CGNORM, CS, DBAR,
     *                  DELTA, DENOM, DIAG, ELQNRM, EPS, EPSA, EPSLN,
     *                  EPSR, EPSX, GAMMA, GBAR, GMAX, GMIN, GPERT,
     *                  OLDB, ONE, QRNORM, QTR, RHS1, RHS2, S, SN,
     *                  SNPROD, T, TNORM2, TWO, X1CG, X1LQ, YNORM,
     *                  YYNORM, Z, ZBAR, ZERO
      INTEGER           I, IFLAG, ITNLM, NOUT
      LOGICAL           CGPT
C     .. Local Arrays ..
      CHARACTER*1       P01REC(1)
      CHARACTER*80      REC(6)
C     .. External Functions ..
      DOUBLE PRECISION  A02ABF, DNRM2, DDOT
      INTEGER           P01ABF
      EXTERNAL          A02ABF, DNRM2, DDOT, P01ABF
C     .. External Subroutines ..
      EXTERNAL          F06FBF, F06FDF, F06FPF, F06BAF, DCOPY, DAXPY,
     *                  X02ZAZ, X04ABF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, MOD, SQRT
C     .. Common blocks ..
      COMMON            /AX02ZA/WMACH
C     .. Save statements ..
      SAVE              /AX02ZA/
C     .. Data statements ..
      DATA              ONE/1.0D+0/, QTR/0.25D+0/
      DATA              ZERO/0.0D+0/, TWO/2.00D+0/
C     .. Executable Statements ..
C
C     CHECK INPUT PARAMETERS.
C
      IF (N.GE.1 .AND. LRWORK.GE.1 .AND. LIWORK.GE.1) GO TO 20
      IFAIL = P01ABF(IFAIL,1,SRNAME,0,P01REC)
      RETURN
   20 CONTINUE
      ITNLM = ITNLIM
      IF (ITNLM.LT.1) ITNLM = N
C
C     SET MACHINE DEPENDENTS.
C
      CALL X02ZAZ
      EPS = WMACH(3)
      NOUT = WMACH(11) + QTR
C
C     PRINT HEADING.
C
      IF (MSGLVL.GT.0) THEN
         WRITE (REC,FMT=99999)
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
      END IF
      IF (MSGLVL.GT.0) THEN
         WRITE (REC,FMT=99998) N, PRECON, SHIFT, RTOL, ITNLM
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
      END IF
C
C     INITIALIZE OUTPUT PARAMETERS.
C
      INFORM = 0
      ITN = 0
      ANORM = ZERO
      ACOND = ZERO
      RNORM = ZERO
      XNORM = ZERO
      EPSR = ZERO
      EPSX = ZERO
      BESTNM = ZERO
      YNORM = ZERO
C
C     SET X(0) TO ZERO.
C
      CALL F06FBF(N,ZERO,X,1)
C
C     START THE CALCULATION OF BETA(1) AND V(1).
C
      CALL DCOPY(N,B,1,WORK(1,3),1)
C
      IFLAG = 0
      IF ( .NOT. PRECON) CALL DCOPY(N,WORK(1,3),1,WORK,1)
      IF (PRECON) CALL MSOLVE(IFLAG,N,WORK(1,3)
     *                        ,WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
      BETA1 = DDOT(N,WORK(1,3),1,WORK,1)
      IF (BETA1.LT.ZERO) GO TO 240
      IF (BETA1.EQ.ZERO) GO TO 140
      BETA1 = SQRT(BETA1)
C
      CALL F06FDF(N,ONE/BETA1,WORK,1,WORK(1,2),1)
C
C     BETA(1) AND V(1) NOW COMPUTED. SET W(1)BAR = V(1)
C
      CALL DCOPY(N,WORK(1,2),1,WORK(1,5),1)
C
C     START THE COMPUTATION OF ALPHA(1) AND V(2).
C
      CALL APROD(IFLAG,N,WORK(1,2),WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
      CALL DAXPY(N,-SHIFT,WORK(1,2),1,WORK,1)
C
      ALFA = DDOT(N,WORK(1,2),1,WORK,1)
C
      CALL DAXPY(N,-ALFA/BETA1,WORK(1,3),1,WORK,1)
C
C     ALPHA(1) AND BETA(2)*M*V(2) NOW COMPUTED. TRY TO IMPROVE THE
C     ORTHOGONALITY OF ( M**(1/2) )*V(1) AND ( M**(1/2) )*V(2).
C
C     Z = BETA(2)*( V(1)**T )*M*V(2) AND WOULD BE ZERO IN EXACT
C     ARITHMETIC.
C     S = ( V(1)**T )*V(1).
C
      Z = DDOT(N,WORK(1,2),1,WORK,1)
      S = DDOT(N,WORK(1,2),1,WORK(1,2),1)
C
      CALL DAXPY(N,-Z/S,WORK(1,2),1,WORK,1)
C
C     SAVE BETA(2)*M*V(2) IN R2.
C
      CALL DCOPY(N,WORK,1,WORK(1,4),1)
C
C     SAVE BETA(1) IN OLDB AND COMPUTE BETA(2).
C
      IF (PRECON) CALL MSOLVE(IFLAG,N,WORK(1,4)
     *                        ,WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
C
      OLDB = BETA1
      BETA = DDOT(N,WORK(1,4),1,WORK,1)
      IF (BETA.LT.ZERO) GO TO 240
      BETA = SQRT(BETA)
C
      IF (MSGLVL.GT.1) THEN
         WRITE (REC,FMT=99997) BETA1, ALFA
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
         CALL X04BAF(NOUT,REC(3))
      END IF
C
C     INITIALIZE OTHER LOCAL QUANTITIES.
C     GBAR   = GAMMA(1)BAR,  DBAR = DELTA(2)BAR,
C     RHS1   = GAMMA(1)BAR*ZETA(1)BAR. (ZETA IS AN ELEMENT OF Z.)
C     TNORM2 = NORM( T(1) )**2.
C
      GBAR = ALFA
      DBAR = BETA
      RHS1 = BETA1
      RHS2 = ZERO
      SNPROD = ONE
      TNORM2 = ALFA**2
      YYNORM = ZERO
      GMAX = ZERO
      GMIN = ONE/EPS
C
C        ***********************
C        * MAIN ITERATION LOOP *    K = 2, 3, ...
C        ***********************
C
C     +    WHILE( INFORM .EQ. 0 )LOOP
   40 IF (INFORM.NE.0) GO TO 120
      ITN = ITN + 1
C
C        COMPUTE V(K).
C
      CALL F06FDF(N,ONE/BETA,WORK,1,WORK(1,2),1)
C
C        COMPUTE ALPHA(K) AND START COMPUTATION OF V(K+1).
C
      CALL APROD(IFLAG,N,WORK(1,2),WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
      CALL DAXPY(N,-SHIFT,WORK(1,2),1,WORK,1)
      CALL DAXPY(N,-BETA/OLDB,WORK(1,3),1,WORK,1)
C
      ALFA = DDOT(N,WORK(1,2),1,WORK,1)
C
      CALL DAXPY(N,-ALFA/BETA,WORK(1,4),1,WORK,1)
C
C        SAVE BETA(K)*M*V(K) IN R1 AND BETA(K+1)*M*V(K+1) IN R2.
C
      CALL DCOPY(N,WORK(1,4),1,WORK(1,3),1)
      CALL DCOPY(N,WORK,1,WORK(1,4),1)
C
C        UPDATE TNORM2 = NORM( T(K) )**2,
C        SAVE BETA(K) IN OLDB AND COMPUTE BETA(K+1).
C
      IF (PRECON) CALL MSOLVE(IFLAG,N,WORK(1,4)
     *                        ,WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
C
      TNORM2 = TNORM2 + ALFA**2 + TWO*(BETA**2)
      OLDB = BETA
      BETA = DDOT(N,WORK(1,4),1,WORK,1)
      IF (BETA.LT.ZERO) GO TO 240
      BETA = SQRT(BETA)
C
C        COMPUTE ROTATION PARAMETERS C(K-1) AND S(K-1) FOR R(K).
C        GAMMA = GAMMA(K-1).
C
      GAMMA = GBAR
      T = OLDB
C
      CALL F06BAF(GAMMA,T,CS,SN)
C
C        COMPUTE
C            Z = ZETA(K-1),  DELTA = DELTA(K),  GBAR = GAMMA(K)BAR,
C        EPSLN = EPSLN(K+1),  DBAR = DELTA(K+1)BAR.
C
      Z = RHS1/GAMMA
      DELTA = CS*DBAR + SN*ALFA
      GBAR = SN*DBAR - CS*ALFA
      EPSLN = SN*BETA
      DBAR = -CS*BETA
C
C        ACCUMULATE THE PRODUCT OF THE SINES.
C
      SNPROD = SN*SNPROD
C
C        START THE COMPUTATION OF X(K-1). EFFICIENCY CAN BE IMPROVED
C        HERE - SEE FOR EXAMPLE THE ORIGINAL SYMMLQ.
C
C        COMPUTE
C
C        ( W(K-1)  W(K)BAR ) = ( W(K-1)BAR  V(K) )*( C(K-1)   S(K-1) ).
C                                                  ( S(K-1)  -C(K-1) )
C
      CALL F06FPF(N,WORK(1,5),1,WORK(1,2),1,CS,SN)
C
C        COMPUTE X(K-1)L = X(K-2)L + ZETA(K-1)*W(K-1).
C        AND THEN STORE W(K-1).
C
      CALL DAXPY(N,Z,WORK(1,5),1,X,1)
      CALL DCOPY(N,WORK(1,2),1,WORK(1,5),1)
C
C        UPDATE GMAX, GMIN AND YYNORM = NORM( M**(1/2)*XL ).
C
      GMAX = MAX(GMAX,ABS(GAMMA))
      GMIN = MIN(GMIN,ABS(GAMMA))
      YYNORM = A02ABF(Z,YYNORM)
C
C        COMPUTE RHS1 = -DELTA(K)*ZETA(K-1) - EPSLN(K)*ZETA(K-2)
C        AND     RHS2 = -EPSLN(K+1)*ZETA(K-1).
C
      RHS1 = RHS2 - DELTA*Z
      RHS2 = -EPSLN*Z
C
C        ESTIMATE NORMS AND TEST FOR CONVERGENCE.
C        ANORM  = NORM( T(K-1) ),
C        DIAG CONTAINS ABS( GAMMA(K-1)BAR ) VERY SLIGHTLY PERTURBED,
C        ELQNRM = NORM( RL(K-1) ),  CGNORM = NORM( RC(K-1) ).
C        ZBAR   = ZETA(K-1)BAR.
C
      ANORM = SQRT(TNORM2)
      EPSA = ANORM*EPS
      IF (GBAR.GE.ZERO) GPERT = GBAR + EPSA
      IF (GBAR.LT.ZERO) GPERT = GBAR - EPSA
      DIAG = ABS(GPERT)
      ELQNRM = A02ABF(RHS1,RHS2)
      QRNORM = ABS(SNPROD)*BETA1
      CGNORM = QRNORM*BETA/DIAG
      BESTNM = MIN(CGNORM,ELQNRM)
C
C        CGPT IS TRUE IF YC IS THE BEST CURRENT APPROXIMATION.
C
      CGPT = CGNORM .LE. ELQNRM
      IF (GBAR.NE.ZERO) ZBAR = RHS1/GBAR
      IF (GBAR.EQ.ZERO) ZBAR = RHS1/GPERT
      IF (CGPT) GO TO 60
      BESTNM = ELQNRM
      YNORM = YYNORM
      DENOM = GMIN
      GO TO 80
   60 CONTINUE
      BESTNM = CGNORM
      ZBAR = RHS1/GPERT
      YNORM = A02ABF(YYNORM,ZBAR)
      DENOM = MIN(GMIN,DIAG)
   80 CONTINUE
      EPSX = EPSA*YNORM
      EPSR = RTOL*YNORM*ANORM
C
C        ESTIMATE  COND( A ).
C        IN THIS VERSION WE LOOK AT THE DIAGONALS OF LBAR IN THE
C        FACTORIZATION OF THE TRIDIAGONAL MATRIX,  T = LBAR*Q.
C
C        THE ABSOLUTE VALUE OF THE LATEST DIAGONAL ELEMENT IS IN
C        DIAG. IT IS INCLUDED AS A CANDIDATE FOR THE SMALLEST DIAGONAL
C        ELEMENT OF LBAR ONLY IF CGPT IS TRUE.
C
      ACOND = GMAX/DENOM
C
      IF (ITN.GE.ITNLM) INFORM = 4
      IF (EPSX.GE.BETA1) INFORM = 3
      IF (BESTNM.LE.EPSX) INFORM = 2
      IF (BESTNM.LE.EPSR) INFORM = 1
C
C        SEE IF IT IS TIME TO PRINT SOMETHING.
C
      IF ((MSGLVL.LE.1) .OR. (ITN.GT.10 .AND. ITN.LT.(ITNLM-10)
     *    .AND. MOD(ITN,10).NE.0 .AND. BESTNM.GE.10.0D0*EPSX .AND.
     *    BESTNM.GE.10.0D0*EPSR .AND. INFORM.EQ.0)) GO TO 100
C
C           PRINT SOMETHING FOR THIS ITERATION.
C           X1LQ AND X1CG ARE THE FIRST ELEMENTS OF XL AND XC.
C
      X1LQ = X(1)
      X1CG = X1LQ + WORK(1,5)*ZBAR
      IF (ITN.EQ.1) THEN
         WRITE (REC,FMT=99996)
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
         CALL X04BAF(NOUT,REC(3))
      END IF
      IF (CGPT) WRITE (REC,FMT=99995) ITN, X1LQ, X1CG, BESTNM, ANORM,
     *    ACOND
      IF ( .NOT. CGPT) WRITE (REC,FMT=99994) ITN, X1LQ, X1CG, BESTNM,
     *    ANORM, ACOND
      CALL X04BAF(NOUT,REC(1))
      IF (MOD(ITN,10).EQ.0) THEN
         WRITE (REC,FMT=99993)
         CALL X04BAF(NOUT,REC(1))
      END IF
  100 CONTINUE
C
C        ******************************
C        * END OF MAIN ITERATION LOOP *
C        ******************************
C
      GO TO 40
  120 CONTINUE
C     +    END OF WHILE LOOP
C
C     IF CGPT IS TRUE COMPUTE XC.
C
      IF (CGPT) CALL DAXPY(N,ZBAR,WORK(1,5),1,X,1)
C
C     DISPLAY STATUS AT END OF ITERATIONS
C
  140 CONTINUE
      IF (MSGLVL.LE.0) GO TO 160
      WRITE (REC,FMT=99992) ITN, INFORM
      CALL X04BAF(NOUT,REC(1))
      CALL X04BAF(NOUT,REC(2))
      CALL X04BAF(NOUT,REC(3))
      IF (INFORM.EQ.0) WRITE (REC,FMT=99991)
      IF (INFORM.EQ.1) WRITE (REC,FMT=99990)
      IF (INFORM.EQ.2) WRITE (REC,FMT=99989)
      IF (INFORM.EQ.3) WRITE (REC,FMT=99988)
      IF (INFORM.EQ.4) WRITE (REC,FMT=99987)
      IF (INFORM.GE.0 .AND. INFORM.LE.4) CALL X04BAF(NOUT,REC(1))
      WRITE (REC,FMT=99985) EPSR, EPSX
      CALL X04BAF(NOUT,REC(1))
      CALL X04BAF(NOUT,REC(2))
      CALL X04BAF(NOUT,REC(3))
      CALL X04BAF(NOUT,REC(4))
  160 CONTINUE
C
C     COMPUTE FINAL RESIDUAL AND ITS NORM TOGETHER WITH NORM( X ).
C
      CALL APROD(IFLAG,N,X,WORK,RWORK,LRWORK,IWORK,LIWORK)
      IF (IFLAG.LT.0) GO TO 260
      CALL DAXPY(N,-SHIFT,X,1,WORK,1)
C
      DO 180 I = 1, N
         WORK(I,1) = B(I) - WORK(I,1)
  180 CONTINUE
C
      RNORM = DNRM2(N,WORK,1)
      XNORM = DNRM2(N,X,1)
      IF (MSGLVL.GT.0) THEN
         WRITE (REC,FMT=99984) BESTNM, YNORM, RNORM, XNORM, ANORM, ACOND
         DO 200 I = 1, 6
            CALL X04BAF(NOUT,REC(I))
  200    CONTINUE
      END IF
      IF (INFORM.EQ.4) GO TO 220
      IFAIL = 0
      RETURN
  220 CONTINUE
      IFAIL = P01ABF(IFAIL,3,SRNAME,0,P01REC)
      RETURN
C
C     ERROR --  M  IS APPARENTLY NOT POSITIVE DEFINITE
C
  240 CONTINUE
      INFORM = 5
      IF (MSGLVL.GT.0) THEN
         WRITE (REC,FMT=99986)
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
      END IF
      IFAIL = P01ABF(IFAIL,2,SRNAME,0,P01REC)
      RETURN
  260 INFORM = IFLAG
      IF (MSGLVL.LT.0) GO TO 280
      WRITE (REC,FMT=99992) ITN, INFORM
      CALL X04BAF(NOUT,REC(1))
      CALL X04BAF(NOUT,REC(2))
      CALL X04BAF(NOUT,REC(3))
      WRITE (REC,FMT=99983)
      CALL X04BAF(NOUT,REC(1))
  280 IFAIL = P01ABF(IFAIL,INFORM,SRNAME,0,P01REC)
      RETURN
C
C
C     END OF F04MBF. (SYMMLQ.)
C
99999 FORMAT (' OUTPUT FROM F04MBF.',/)
99998 FORMAT ('     N =',I5,10X,'PRECON =',L3,5X,'SHIFT =',1P,D17.7,
     *  /'  RTOL =',1P,D12.2,3X,'ITNLIM =',I5)
99997 FORMAT (/' BETA1 =',1P,D12.2,/' ALFA1 =',1P,D12.2)
99996 FORMAT (//'    ITN',3X,'X1( LQ )',5X,'X1( CG )',2X,'NORM( RBAR )',
     *  1X,'NORM( T )',1X,'COND( L )',1X,'LQ/CG')
99995 FORMAT (1X,I6,1P,2D13.5,1X,1P,3D10.2,4X,'C')
99994 FORMAT (1X,I6,1P,2D13.5,1X,1P,3D10.2,4X,'L')
99993 FORMAT (1X)
99992 FORMAT (/' NO. OF ITERATIONS              ',I7,/' STOPPING CONDI',
     *  'TION WAS         ',I7)
99991 FORMAT (' ( EXACT SOLUTION IS  X = 0 )')
99990 FORMAT (' ( REQUESTED ACCURACY ACHIEVED )')
99989 FORMAT (' ( REASONABLE ACCURACY ACHIEVED )')
99988 FORMAT (' ( EIGENVECTOR CONVERGED )')
99987 FORMAT (' ( ITERATION LIMIT REACHED )')
99986 FORMAT (/' XXX  THE PRECONDITIONING MATRIX  M  DOES NOT APPEAR T',
     *  'O BE POSITIVE DEFINITE.')
99985 FORMAT (//' REQUESTED  NORM( RBAR ) WAS                    ',1P,
     *  D12.2,/' ESTIMATE OF SMALLEST ATTAINABLE NORM( RBAR )   ',1P,
     *  D12.2)
99984 FORMAT (/' ESTIMATES OF  NORM( RBAR ),  NORM( Y )         ',1P,
     *  2D12.2,/'                          ( Y = M**( 1/2 )* X ) ',
     *  //' ACTUAL        NORM( R ),     NORM( X )         ',1P,2D12.2,
     *  /' ESTIMATES OF  NORM( ABAR ),  COND( ABAR )      ',1P,2D12.2)
99983 FORMAT (' ( TERMINATION REQUESTED BY USER ROUTINE )')
      END
