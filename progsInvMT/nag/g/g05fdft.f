      SUBROUTINE G05FDF(A,B,N,X)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C     MARK 16A REVISED. IER-1038 (JUN 1993).
C
C     Returns a vector of N pseudo-random numbers from a normal
C     distribution with mean A and standard deviation B.
C
C     Pseudo-random numbers are generated by the auxiliary routine
C     G05CAY, 63 at a time, and stored in the array RV in common block
C     CG05CA. G05FDF copies numbers from RV to X, using the Box-Muller
C     method to transform to the normal distribution two at a time,
C     and calling G05CAY to replenish RV when necessary.
C
C     A call of G05FDF does *not* return the same sequence of
C     pseudo-random numbers as N consecutive calls to G05DDF,
C     because G05DDF uses a different transformation (Brent's method).
C     G05FDF uses the Box-Muller method because it is more amenable
C     to vectorization.
C
C     Jeremy Du Croz, NAG Ltd, May 1989.
C
C     .. Parameters ..
      INTEGER           LV
      PARAMETER         (LV=63)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, B
      INTEGER           N
C     .. Array Arguments ..
      DOUBLE PRECISION  X(N)
C     .. Scalars in Common ..
      DOUBLE PRECISION  VNORML
      INTEGER           KV
C     .. Arrays in Common ..
      DOUBLE PRECISION  RV(LV)
C     .. Local Scalars ..
      DOUBLE PRECISION  T1, T2, TWOPI
      INTEGER           I, I1, I2, IV
      LOGICAL           INIT
C     .. External Functions ..
      DOUBLE PRECISION  X01AAF
      EXTERNAL          X01AAF
C     .. External Subroutines ..
      EXTERNAL          G05CAY, G05CAZ
C     .. Intrinsic Functions ..
      INTRINSIC         COS, LOG, MIN, SIN, SQRT
C     .. Common blocks ..
      COMMON            /CG05CA/RV, KV
      COMMON            /DG05CA/VNORML
C     .. Save statement ..
      SAVE              /CG05CA/, /DG05CA/, INIT, TWOPI
C     .. Data statements ..
      DATA              INIT/.TRUE./
C     .. Executable Statements ..
      IF (N.LE.0) RETURN
C
C     Ensure that the basic generator has been initialized
C
      IF (INIT) THEN
         CALL G05CAZ(INIT)
         TWOPI = 2*X01AAF(TWOPI)
      END IF
C
C     Replenish the buffer if necessary
C
      IF (KV.GE.LV) CALL G05CAY(.FALSE.)
C
C     Fill the array X in segments: I1 and I2 are indices of first and
C     last elements in current segment
C
      I1 = 1
      I2 = -KV
      IF (VNORML.NE.256.0D0) I2 = I2 + 1
   20 CONTINUE
C
C     The value 256.0 is used to indicate that no useful value is saved
C     in VNORML. A useful value of T1*SIN(T2) must be bounded in
C     absolute value by sqrt(120*log(2)) = 9.12... .
C
      IF (VNORML.NE.256.0D0) THEN
C
C        Use the value saved in VNORML to generate one value
C
         X(I1) = A + B*VNORML
         VNORML = 256.0D0
         I1 = I1 + 1
      END IF
      I2 = MIN(I2+LV,N)
      IV = KV - I1 + 1
C
C     Generate values for the current segment of X in pairs.
C     This loop should be vectorizable; its length is at most LV.
C
CDIR$ SHORTLOOP
      DO 40 I = I1, I2 - 1, 2
         T1 = SQRT(-2*LOG(RV(I+IV)))
         T2 = TWOPI*RV(I+IV+1)
         X(I) = A + B*T1*COS(T2)
         X(I+1) = A + B*T1*SIN(T2)
   40 CONTINUE
      KV = KV + I - I1
C
      IF (I.EQ.I2) THEN
C
C        Generate first element of a pair to fill the current segment
C        of X; save the unused value of T1*SIN(T2) in VNORML.
C
         KV = KV + 1
         T1 = SQRT(-2*LOG(RV(KV)))
C
C        Replenish buffer if necessary
C
         IF (KV.GE.LV) CALL G05CAY(.FALSE.)
         KV = KV + 1
         T2 = TWOPI*RV(KV)
         X(I2) = A + B*T1*COS(T2)
         VNORML = T1*SIN(T2)
      ELSE
C
C        Replenish buffer if necessary and set VNORML to indicate that
C        no useful value is saved
C
         IF (KV.GE.LV) CALL G05CAY(.FALSE.)
         VNORML = 256.0D0
      END IF
C
      IF (I2.GE.N) RETURN
C
C     Go back to generate next segment
C
      I1 = I2 + 1
      GO TO 20
      END
