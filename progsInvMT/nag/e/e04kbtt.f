      SUBROUTINE E04KBT(N,NFREE,STEP,BL,BU,ISTATE,Y,P,SPOS,SNEG,IFAIL)
C
C     MARK 6 RELEASE NAG COPYRIGHT 1977
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C
C     **************************************************************
C
C     E04KBT (LOCSD2) FINDS A VECTOR ORTHOGONAL TO (X - Y) AT THE
C     POINT Y, SETTING EACH OF ITS NON-ZERO ELEMENTS TO THE SAME
C     VALUE (+ 1 OR - 1) AS THE CORRESPONDING ELEMENT OF (X - Y) AND
C     THE NEGATIVED VALUE ALTERNATELY. IF NFREE IS ODD, THE LAST TWO
C     NON-ZERO ELEMENTS ARE CHOSEN SUCH THAT THEIR MODULI DIFFER BUT
C     SUM TO UNITY. E04KBT THEN CALCULATES SPOS AND SNEG AS THE
C     MAXIMUM FEASIBLE STEP-LENGTHS IN THE POSITIVE AND NEGATIVE
C     DIRECTIONS RESPECTIVELY AND COMPUTES THE SEARCH DIRECTION P AS
C     A FEASIBLE BUT SIGNIFICANT SCALAR MULTIPLE OF THE ORTHOGONAL
C     VECTOR.
C
C     PHILIP E. GILL, WALTER MURRAY, SUSAN M. PICKEN, MARGARET H.
C     WRIGHT AND ENID M. R. LONG, D.N.A.C., NATIONAL PHYSICAL
C     LABORATORY, ENGLAND
C
C     **************************************************************
C
C
C     TWO MACHINE-DEPENDENT CONSTANTS ARE SET HERE. EPSMCH IS THE
C     SMALLEST POSITIVE REAL NUMBER SUCH THAT 1 + EPSMCH .GT. 1.
C     RMAX IS THE LARGEST POSITIVE REAL NUMBER SUCH THAT BOTH RMAX
C     AND - RMAX CAN BE HELD IN THE MACHINE.
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  SNEG, SPOS, STEP
      INTEGER           IFAIL, N, NFREE
C     .. Array Arguments ..
      DOUBLE PRECISION  BL(N), BU(N), P(N), Y(N)
      INTEGER           ISTATE(N)
C     .. Local Scalars ..
      DOUBLE PRECISION  DNEG, DPOS, DUMMY, EPSMCH, PJ, RATIO, RMAX,
     *                  SCALAR, SIGNUM, TEMP, YJ
      INTEGER           J, KOUNT, NEVEN
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02ALF
      EXTERNAL          X02AJF, X02ALF
C     .. Executable Statements ..
      EPSMCH = X02AJF()
      RMAX = X02ALF()
C
      IFAIL = 5
      KOUNT = 0
      NEVEN = NFREE/2*2
      IF (NEVEN.EQ.NFREE) KOUNT = -1
      RATIO = 0.3579D+0
      SIGNUM = 1.0D+0
      SPOS = 1.0D+6
      SNEG = 1.0D+6
      DO 100 J = 1, N
         IF (ISTATE(J).LE.0) GO TO 100
         KOUNT = KOUNT + 1
         PJ = SIGNUM*P(J)
         IF (KOUNT.GE.NEVEN) GO TO 20
         SIGNUM = -SIGNUM
         GO TO 40
   20    PJ = RATIO*PJ
         RATIO = 1.0D+0 - RATIO
   40    P(J) = PJ
         YJ = Y(J)
         IF (PJ.GT.0.0D+0) GO TO 60
         DPOS = (BL(J)-YJ)/PJ
         DNEG = (YJ-BU(J))/PJ
         GO TO 80
   60    DPOS = (BU(J)-YJ)/PJ
         DNEG = (YJ-BL(J))/PJ
   80    IF (SPOS.GT.DPOS) SPOS = DPOS
         IF (SNEG.GT.DNEG) SNEG = DNEG
  100 CONTINUE
      IF (SPOS.LT.SNEG) GO TO 140
      IF (SPOS.LT.EPSMCH) RETURN
      IF (SPOS.LT.STEP) STEP = SPOS
      SCALAR = STEP
      IF (STEP.LT.1.0D+0) GO TO 120
      SPOS = SPOS/STEP
      SNEG = SNEG/STEP
      GO TO 180
  120 DUMMY = STEP*RMAX
      IF (SPOS.LT.DUMMY) SPOS = SPOS/STEP
      IF (SNEG.LT.DUMMY) SNEG = SNEG/STEP
      GO TO 180
  140 IF (SNEG.LT.EPSMCH) RETURN
      IF (SNEG.LT.STEP) STEP = SNEG
      TEMP = SPOS
      SCALAR = -STEP
      IF (STEP.LT.1.0D+0) GO TO 160
      SPOS = SNEG/STEP
      SNEG = TEMP/STEP
      GO TO 180
  160 DUMMY = STEP*RMAX
      IF (SNEG.LT.DUMMY) SPOS = SNEG/STEP
      IF (TEMP.LT.DUMMY) SNEG = TEMP/STEP
  180 DO 200 J = 1, N
         P(J) = SCALAR*P(J)
  200 CONTINUE
      IFAIL = 0
      RETURN
C
C     END OF E04KBT (LOCSD2)
C
      END
