      SUBROUTINE E04VDZ(MODFYG,MODFYR,ORTHOG,UNITQ,INFORM,IFIX,IADD,
     *                  JADD,NACTIV,NCOLR,NCOLZ,NFREE,N,NQ,NROWA,NROWRT,
     *                  NCOLRT,KFREE,CONDMX,CSLAST,SNLAST,A,QTG,RT,ZY,
     *                  WRK1,WRK2)
C     MARK 12 RE-ISSUE. NAG COPYRIGHT 1986.
C
C *********************************************************************
C     E04VDZ UPDATES THE FACTORIZATION OF THE MATRIX OF
C     CONSTRAINTS IN THE WORKING SET,  A(FREE) * (Z Y) = (0 T).
C     IF THE LOGICAL VARIABLE  MODFYR  IS TRUE, THE CHOLESKY
C     FACTORIZATION OF THE PROJECTED HESSIAN, R(T)*R, IS UPDATED ALSO.
C
C     THERE ARE THREE SEPARATE CASES TO CONSIDER (ALTHOUGH EACH CASE
C     SHARES CODE WITH ANOTHER)...
C
C     (1) A FREE VARIABLE BECOMES FIXED ON ONE OF ITS BOUNDS WHEN THERE
C      ARE ALREADY SOME GENERAL CONSTRAINTS IN THE WORKING SET.
C
C     (2) A FREE VARIABLE BECOMES FIXED ON ONE OF ITS BOUNDS WHEN THERE
C      ARE ONLY BOUND CONSTRAINTS IN THE WORKING SET.
C
C     (3) A GENERAL CONSTRAINT (CORRESPONDING TO ROW  IADD  OF  A) IS
C      ADDED TO THE WORKING SET.
C
C      IN CASES (1) AND (2), WE ASSUME THAT  KFREE(IFIX) = JADD.
C     IN ALL CASES,  JADD  IS THE INDEX OF THE CONSTRAINT BEING ADDED.
C
C     IF THERE ARE NO GENERAL CONSTRAINTS IN THE WORKING SET,  THE
C     MATRIX  Q = (Z Y)  IS THE IDENTITY AND WILL NOT BE TOUCHED.
C
C     IF  MODFYR  IS TRUE AND  NCOLZ IS GREATER THAN ONE ON ENTRY,
C     CSLAST AND SNLAST CONTAIN THE LAST OF THE SEQUENCE OF GIVENS
C     ROTATIONS USED TO REDUCE THE INTERMEDIATE UPPER-HESSENBERG MATRIX
C     TO UPPER-TRIANGULAR FORM.  THESE ELEMENTS ARE NEEDED BY E04NAX.
C
C     IF  MODFYG  IS TRUE ON ENTRY, THE COLUMN TRANSFORMATIONS ARE
C     APPLIED TO THE VECTOR  Q(T)GRAD,  STORED IN  QTG.
C
C     SYSTEMS OPTIMIZATION LABORATORY, STANFORD UNIVERSITY.
C     VERSION OF JANUARY 1982.  REV. OCT. 1982.  MARCH 1983.
C     MARCH 1983.  HOUSEHOLDER REFLECTION USED TO ADD GENERAL
C     CONSTRAINT.
C     APRIL 1983.  ELIMINATIONS ADDED AS AN OPTION.
C *********************************************************************
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  CONDMX, CSLAST, SNLAST
      INTEGER           IADD, IFIX, INFORM, JADD, N, NACTIV, NCOLR,
     *                  NCOLRT, NCOLZ, NFREE, NQ, NROWA, NROWRT
      LOGICAL           MODFYG, MODFYR, ORTHOG, UNITQ
C     .. Array Arguments ..
      DOUBLE PRECISION  A(NROWA,N), QTG(N), RT(NROWRT,NCOLRT), WRK1(N),
     *                  WRK2(N), ZY(NQ,NQ)
      INTEGER           KFREE(N)
C     .. Scalars in Common ..
      DOUBLE PRECISION  ASIZE, DTMAX, DTMIN
      INTEGER           ISTART, MSG, NOUT
C     .. Arrays in Common ..
      DOUBLE PRECISION  WMACH(15)
C     .. Local Scalars ..
      DOUBLE PRECISION  BETA, COND, CONDBD, CS, D, DELTA, DTNEW, EPSMCH,
     *                  FLMAX, ONE, POINT9, SN, TDTMAX, TDTMIN, ZERO
      INTEGER           I, INCT, ISWAP, ITRANS, J, K, KP1, LDIAG, LENQ,
     *                  LENRT, LROWA, LROWR, NACT1, NCOLZ1, NELM, NFREE1
      LOGICAL           IFAIL
C     .. Local Arrays ..
      CHARACTER*80      REC(6)
C     .. External Functions ..
      DOUBLE PRECISION  F06BLF, DDOT, DNRM2
      EXTERNAL          F06BLF, DDOT, DNRM2
C     .. External Subroutines ..
      EXTERNAL          E04NAP, E04NAQ, E04NAR, E04VDN, F06BAF, F06FBF,
     *                  F06FLF, F06FPF, F06FSF, DAXPY, DCOPY, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC         MAX, MIN
C     .. Common blocks ..
      COMMON            /AE04VC/NOUT, MSG, ISTART
      COMMON            /AX02ZA/WMACH
      COMMON            /HE04VC/ASIZE, DTMAX, DTMIN
C     .. Save statement ..
      SAVE              /AX02ZA/
C     .. Data statements ..
      DATA              ZERO, POINT9, ONE/0.0D+0, 0.9D+0, 1.0D+0/
C     .. Executable Statements ..
C
      EPSMCH = WMACH(3)
      FLMAX = WMACH(7)
C
C     IF THE CONDITION ESTIMATOR OF THE UPDATED FACTORS IS GREATER THAN
C     CONDBD,  A WARNING MESSAGE IS PRINTED.
C
      CONDBD = EPSMCH**(-POINT9)
      LENQ = NQ*(NQ-1) + 1
      LROWA = NROWA*(N-1) + 1
      NCOLZ1 = NCOLZ - 1
      IF (JADD.GT.N) GO TO 60
C
C ---------------------------------------------------------------------
C     A SIMPLE BOUND HAS ENTERED THE WORKING SET.  IADD  IS NOT USED.
C ---------------------------------------------------------------------
      IF (MSG.GE.80) THEN
         WRITE (REC,FMT=99999) NACTIV, NCOLZ, NFREE, IFIX, JADD, UNITQ
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
         CALL X04BAF(NOUT,REC(3))
         CALL X04BAF(NOUT,REC(4))
      END IF
C
C     SET  WRK1 = APPROPRIATE ROW OF  Q.
C     REORDER THE ELEMENTS OF  KFREE (THIS REQUIRES REORDERING THE
C     CORRESPONDING ROWS OF  Q).
C
      NFREE1 = NFREE - 1
      NACT1 = NACTIV
      IF (UNITQ) GO TO 20
C
C     Q  IS STORED EXPLICITLY.  INTERCHANGE COMPONENTS  IFIX  AND  NFREE
C     OF  KFREE  AND SWAP THE CORRESPONDING ROWS OF  Q.
C
      CALL DCOPY(NFREE,ZY(IFIX,1),NQ,WRK1,1)
      IF (IFIX.EQ.NFREE) GO TO 180
      KFREE(IFIX) = KFREE(NFREE)
      CALL DCOPY(NFREE,ZY(NFREE,1),NQ,ZY(IFIX,1),NQ)
      GO TO 180
C
C     Q  IS NOT STORED, BUT  KFREE  DEFINES AN ORDERING OF THE COLUMNS
C     OF THE IDENTITY MATRIX THAT IMPLICITLY DEFINE  Z.
C     REORDER  KFREE  SO THAT VARIABLES  IFIX+1,...,NFREE  ARE MOVED ONE
C     POSITION TO THE LEFT.
C
   20 CALL F06FBF(NFREE,ZERO,WRK1,1)
      WRK1(IFIX) = ONE
      IF (IFIX.EQ.NFREE) GO TO 180
      DO 40 I = IFIX, NFREE1
         KFREE(I) = KFREE(I+1)
   40 CONTINUE
      GO TO 180
C
C ---------------------------------------------------------------------
C     A GENERAL CONSTRAINT HAS ENTERED THE WORKING SET.
C     IFIX IS NOT USED.
C ---------------------------------------------------------------------
   60 IF (MSG.GE.80) THEN
         WRITE (REC,FMT=99998) NACTIV, NCOLZ, NFREE, IADD, JADD, UNITQ
         CALL X04BAF(NOUT,REC(1))
         CALL X04BAF(NOUT,REC(2))
         CALL X04BAF(NOUT,REC(3))
         CALL X04BAF(NOUT,REC(4))
      END IF
C
      NACT1 = NACTIV + 1
C
C     TRANSFORM THE INCOMING ROW OF  A  BY  Q(T).
C
      CALL DCOPY(N,A(IADD,1),NROWA,WRK1,1)
      CALL E04VDN(8,N,NACTIV,NCOLZ,NFREE,NQ,UNITQ,KFREE,KFREE,WRK1,ZY,
     *            WRK2)
C
      IF ( .NOT. UNITQ) GO TO 100
C
C     THIS IS THE FIRST GENERAL CONSTRAINT TO BE ADDED  --  SET  Q = I.
C
      DO 80 J = 1, NFREE
         CALL F06FBF(NFREE,ZERO,ZY(1,J),1)
         ZY(J,J) = ONE
   80 CONTINUE
      UNITQ = .FALSE.
C
C     CHECK THAT THE INCOMING ROW IS NOT DEPENDENT UPON THOSE
C     ALREADY IN THE WORKING SET.
C
  100 DTNEW = DNRM2(NCOLZ,WRK1,1)
      IF (NACT1.GT.1) GO TO 140
C
C     THIS IS THE ONLY GENERAL CONSTRAINT IN THE WORKING SET.
C
      COND = F06BLF(ASIZE,DTNEW,IFAIL)
      IF (IFAIL .AND. ASIZE.EQ.ZERO) COND = FLMAX
      IF (COND.GE.CONDMX) GO TO 480
      IF (COND.GE.CONDBD .AND. MSG.GE.0) THEN
         WRITE (REC,FMT=99997) JADD
         DO 120 J = 1, 6
            CALL X04BAF(NOUT,REC(J))
  120    CONTINUE
      END IF
      DTMAX = DTNEW
      DTMIN = DTNEW
      GO TO 180
C
C     THERE ARE ALREADY SOME GENERAL CONSTRAINTS IN THE WORKING SET.
C     UPDATE THE ESTIMATE OF THE CONDITION NUMBER.
C
  140 TDTMAX = MAX(DTNEW,DTMAX)
      TDTMIN = MIN(DTNEW,DTMIN)
      COND = F06BLF(TDTMAX,TDTMIN,IFAIL)
      IF (IFAIL .AND. TDTMAX.EQ.ZERO) COND = FLMAX
      IF (COND.GE.CONDMX) GO TO 480
      IF (COND.GE.CONDBD .AND. MSG.GE.0) THEN
         WRITE (REC,FMT=99997) JADD
         DO 160 J = 1, 6
            CALL X04BAF(NOUT,REC(J))
  160    CONTINUE
      END IF
      DTMAX = TDTMAX
      DTMIN = TDTMIN
C
C ---------------------------------------------------------------------
C     USE ONE OR MORE COLUMN TRANSFORMATIONS TO REDUCE THE FIRST  NCOLZ1
C     ELEMENTS OF  WRK1  TO ZERO.  THIS AFFECTS  ZY,  EXCEPT IF (UNITQ).
C     THE TRANSFORMATIONS MAY ALSO BE APPLIED TO  QTG  AND  R.
C ---------------------------------------------------------------------
C
  180 IF (NCOLZ1.EQ.0) GO TO 360
      IF (MODFYR .OR. UNITQ) GO TO 320
C
C ---------------------------------------------------------------------
C     THERE IS NO  R.  USE A SINGLE ELIMINATION OR HOUSEHOLDER MATRIX.
C ---------------------------------------------------------------------
      IF (ORTHOG) GO TO 240
C
C *********************************************************************
C     ELIMINATION.
C     WE USE  E04NAR( ..., ZERO, ZERO )   TO PERFORM AN INTERCHANGE.
C *********************************************************************
      CALL E04NAP(NCOLZ1,WRK1(NCOLZ),WRK1,NCOLZ1,1,ISWAP,ITRANS)
      IF (ISWAP.GT.0) CALL E04NAR(ORTHOG,NFREE,ZY(1,NCOLZ),NFREE,1,ZY(1,
     *                            ISWAP),NFREE,1,ZERO,ZERO)
C
      IF (ITRANS.EQ.0) GO TO 220
C
      DO 200 J = 1, NCOLZ1
         D = WRK1(J)
         IF (D.EQ.ZERO) GO TO 200
         CALL DAXPY(NFREE,D,ZY(1,NCOLZ),1,ZY(1,J),1)
  200 CONTINUE
C
  220 IF ( .NOT. MODFYG) GO TO 360
      IF (ISWAP.GT.0) CALL E04NAR(ORTHOG,1,QTG(NCOLZ),1,1,QTG(ISWAP),1,
     *                            1,ZERO,ZERO)
C
      IF (ITRANS.GT.0) CALL DAXPY(NCOLZ1,QTG(NCOLZ),WRK1,1,QTG,1)
      GO TO 360
C
C *********************************************************************
C     ORTHOGONAL TRANSFORMATION.
C     WE USE A HOUSEHOLDER REFLECTION,   I  -  1/BETA  V V(T).
C
C     THERE ARE TWO WAYS OF APPLYING THE REFLECTION.  THE UPDATE TO  Z
C     IS DONE VIA   W  =  Z * V,   Z  =  Z  -  1/BETA  W V(T),
C     WHERE  V = WRK1 (FROM HOUSEHOLDER), AND  W = WRK2 (WORKSPACE).
C
C     THE UPDATE TO  QTG  IS THE MORE USUAL  D =  - QTG(T)*V / BETA,
C     QTG  =  QTG  +  D * V.
C
C     NOTE THAT  DELTA  HAS TO BE STORED AFTER THE REFLECTION IS USED.
C *********************************************************************
  240 DELTA = WRK1(NCOLZ)
      CALL F06FSF(NCOLZ1,DELTA,WRK1,1,EPSMCH,BETA)
      IF (BETA.NE.ZERO) WRK1(NCOLZ) = BETA
      IF (BETA.LE.ZERO) GO TO 360
      CALL F06FBF(NFREE,ZERO,WRK2,1)
C
      DO 260 J = 1, NCOLZ
         D = WRK1(J)
         IF (D.EQ.ZERO) GO TO 260
         CALL DAXPY(NFREE,D,ZY(1,J),1,WRK2,1)
  260 CONTINUE
C
      DO 280 J = 1, NCOLZ
         D = WRK1(J)
         IF (D.EQ.ZERO) GO TO 280
         D = -D/BETA
         CALL DAXPY(NFREE,D,WRK2,1,ZY(1,J),1)
  280 CONTINUE
C
      IF ( .NOT. MODFYG) GO TO 300
      D = DDOT(NCOLZ,WRK1,1,QTG,1)
      D = -D/BETA
      CALL DAXPY(NCOLZ,D,WRK1,1,QTG,1)
C
  300 WRK1(NCOLZ) = DELTA
      GO TO 360
C
C ---------------------------------------------------------------------
C     R  HAS TO BE MODIFIED.  USE A SEQUENCE OF 2*2 TRANSFORMATIONS.
C ---------------------------------------------------------------------
  320 LROWR = NCOLR
C
      DO 340 K = 1, NCOLZ1
C
C        COMPUTE THE TRANSFORMATION THAT REDUCES WRK1(K) TO ZERO,
C        THEN APPLY IT TO THE RELEVANT COLUMNS OF  Z  AND  GRAD(T)Q.
C
         KP1 = K + 1
         CALL E04NAQ(ORTHOG,WRK1(KP1),WRK1(K),CS,SN)
         IF ( .NOT. UNITQ) CALL E04NAR(ORTHOG,NFREE,ZY(1,KP1),NFREE,1,
     *                                 ZY(1,K),NFREE,1,CS,SN)
         IF (MODFYG) CALL E04NAR(ORTHOG,1,QTG(KP1),1,1,QTG(K),1,1,CS,SN)
C
C        APPLY THE SAME TRANSFORMATION TO THE COLS OF  R  IF RELEVANT.
C        THIS GENERATES A SUBDIAGONAL ELEMENT IN  R  WHICH MUST BE
C        ELIMINATED BY A ROW ROTATION.  THE LAST SUCH ROW ROTATION
C        IS NEEDED BY  E04NAX.
C
         IF ( .NOT. (MODFYR .AND. K.LT.NCOLR)) GO TO 340
         RT(KP1,K) = ZERO
         CALL E04NAR(ORTHOG,KP1,RT(1,KP1),KP1,1,RT(1,K),KP1,1,CS,SN)
         CALL F06BAF(RT(K,K),RT(KP1,K),CSLAST,SNLAST)
         RT(KP1,K) = ZERO
         LROWR = LROWR - 1
         LENRT = NROWRT*(LROWR-1) + 1
         CALL F06FPF(LROWR,RT(K,KP1),NROWRT,RT(KP1,KP1),NROWRT,CSLAST,
     *               SNLAST)
  340 CONTINUE
C
C ---------------------------------------------------------------------
C     IF ADDING A GENERAL CONSTRAINT, INSERT THE NEW ROW OF  T  AND
C     EXIT.
C ---------------------------------------------------------------------
  360 IF (JADD.LE.N) GO TO 380
      LENRT = NROWRT*NACTIV + 1
      CALL DCOPY(NACT1,WRK1(NCOLZ),1,RT(NACT1,NCOLZ),NROWRT)
      GO TO 460
C
C ---------------------------------------------------------------------
C     WE ARE ADDING A BOUND.  CONTINUE REDUCING THE ELEMENTS OF  WRK1
C     TO ZERO.  THIS AFFECTS  Y,  T  AND  QTG.
C ---------------------------------------------------------------------
C     FIRST, SET THE SUPER-DIAGONAL ELEMENTS OF T TO ZERO.
C
  380 IF (NACTIV.EQ.0) GO TO 440
      LENRT = NROWRT*(NACTIV-1) + 1
      CALL F06FBF(NACTIV,ZERO,RT(NACTIV,NCOLZ),(NROWRT-1))
      NELM = 1
      LDIAG = NACTIV
C
      DO 400 K = NCOLZ, NFREE1
         CALL E04NAQ(ORTHOG,WRK1(K+1),WRK1(K),CS,SN)
         CALL E04NAR(ORTHOG,NFREE,ZY(1,K+1),NQ,1,ZY(1,K),NQ,1,CS,SN)
         CALL E04NAR(ORTHOG,NELM,RT(LDIAG,K+1),NROWRT,1,RT(LDIAG,K),
     *               NROWRT,1,CS,SN)
         IF (MODFYG) CALL E04NAR(ORTHOG,1,QTG(K+1),1,1,QTG(K),1,1,CS,SN)
         NELM = NELM + 1
         LDIAG = LDIAG - 1
  400 CONTINUE
C
C ---------------------------------------------------------------------
C     THE DIAGONALS OF  T  HAVE BEEN ALTERED.  RECOMPUTE THE LARGEST AND
C     SMALLEST VALUES.
C ---------------------------------------------------------------------
      LENRT = NROWRT*(NACTIV-1) + 1
      INCT = NROWRT - 1
      CALL F06FLF(NACTIV,RT(NACTIV,NCOLZ1+1),INCT,DTMAX,DTMIN)
      IF ((DTMIN/DTMAX)*CONDMX.LT.ONE) GO TO 480
      IF ((DTMIN/DTMAX)*CONDBD.LT.ONE .AND. MSG.GE.0) THEN
         WRITE (REC,FMT=99997) JADD
         DO 420 J = 1, 6
            CALL X04BAF(NOUT,REC(J))
  420    CONTINUE
      END IF
C
C     THE LAST ROW OF  ZY  HAS BEEN TRANSFORMED TO A MULTIPLE OF THE
C     UNIT VECTOR  E(NFREE).  IF ORTHOGONAL TRANSFORMATIONS HAVE BEEN
C     USED THROUGHOUT, THE LAST COLUMN OF  ZY  IS THE SAME.   WE CAN
C     THEREFORE RESURRECT THE GRADIENT ELEMENT OF THE NEWLY FIXED
C     VARIABLE.
C
  440 IF (ORTHOG .AND. MODFYG) QTG(NFREE) = QTG(NFREE)/WRK1(NFREE)
C
C
C ---------------------------------------------------------------------
C     THE FACTORIZATION HAS BEEN SUCCESSFULLY UPDATED.
C ---------------------------------------------------------------------
  460 INFORM = 0
      RETURN
C
C     THE PROPOSED WORKING SET APPEARS TO BE LINEARLY DEPENDENT.
C
  480 INFORM = 1
      IF ( .NOT. MSG.GE.80) RETURN
C
      WRITE (REC,FMT=99996)
      CALL X04BAF(NOUT,REC(1))
      CALL X04BAF(NOUT,REC(2))
      IF (JADD.LE.N) WRITE (REC,FMT=99995) ASIZE, DTMAX, DTMIN
      IF (JADD.GT.N) WRITE (REC,FMT=99994) ASIZE, DTMAX, DTMIN, DTNEW
      CALL X04BAF(NOUT,REC(1))
      CALL X04BAF(NOUT,REC(2))
      CALL X04BAF(NOUT,REC(3))
      RETURN
C
C
C     END OF E04VDZ (ADDCON)
99999 FORMAT (/' //E04VDZ//  SIMPLE BOUND ADDED.',/' //E04VDZ//  NACTI',
     *  'V NCOLZ NFREE  IFIX  JADD UNITQ',/' //E04VDZ//  ',5I6,L6)
99998 FORMAT (/' //E04VDZ//  GENERAL CONSTRAINT ADDED.',/' //E04VDZ// ',
     *  ' NACTIV NCOLZ NFREE  IADD  JADD UNITQ',/' //E04VDZ//  ',5I6,L6)
99997 FORMAT (/' *** WARNING',/' *** SERIOUS ILL-CONDITIONING IN THE W',
     *  'ORKING SET AFTER ADDING CONSTRAINT ',I5,/' *** OVERFLOW MAY O',
     *  'CCUR IN SUBSEQUENT ITERATIONS',//)
99996 FORMAT (/' //E04VDZ//  DEPENDENT CONSTRAINT REJECTED')
99995 FORMAT (/' //E04VDZ//     ASIZE     DTMAX     DTMIN',/' //E04VDZ',
     *  '//',1P,3D10.2)
99994 FORMAT (/' //E04VDZ//     ASIZE     DTMAX     DTMIN     DTNEW',
     *  /' //E04VDZ//',1P,4D10.2)
      END
