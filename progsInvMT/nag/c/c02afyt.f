      SUBROUTINE C02AFY(DX,DY,NDEG,A,P,PPRIME,PDPRIM,ERROR,DEFLAT)
C     MARK 14 RELEASE. NAG COPYRIGHT 1989.
C     MARK 15 REVISED. IER-891 (APR 1991).
C
C     BASED ON THE ROUTINE  CPOLYR, WRITTEN BY BRIAN T. SMITH
C
C     THIS SUBROUTINE EVALUATES A POLYNOMIAL OF DEGREE NDEG WITH
C     COMPLEX COEFFICIENTS AT A COMPLEX POINT (DX, DY), ITS FIRST
C     DERIVATIVE AND HALF ITS SECOND DERIVATIVE AT THAT POINT AND AN
C     ESTIMATE OF THE ERROR IN THE POLYNOMIAL VALUE.  THE ESTIMATE IS
C     A GUARANTEED UPPER BOUND, ASSUMING THE COEFFICIENTS ARE EXACT,
C     AND THE FLOATING POINT ARITHMETIC IS 'WELL-BEHAVED'.
C     THAT IS,
C
C           FL(C+D) = (C+D)(1+E),  ABS(E) <= DEPS * (SMALL INTEGER)
C           FL(C*D) = (C*D)(1+F),  ABS(F) <= DEPS * (SMALL INTEGER)
C
C     WHERE FL(.) IS THE MACHINE VALUE FOR THE ENCLOSED OPERATION
C           AND  DEPS  IS A SMALL CONSTANT, USUALLY EQUAL TO THE
C           RELATIVE MACHINE PRECISION.
C
C     THE POLYNOMIAL IS ASSUMED TO BE OF THE FORM
C
C        P(X) = SUM(A(NDEG-I)*X**I, I=0,1,...,NDEG )
C
C     WHERE  A(I)=CMPLX(AR(I),AI(I)) AND  X=CMPLX(DX,DY)  ARE COMPLEX.
C     NOTE: A(0) IS THE COEFFICIENT OF X**NDEG AND  A(NDEG) IS THE
C           CONSTANT COEFFICIENT.
C
C     USAGE: THIS PROGRAM CAN BE USED TO EVALUATE A COMPLEX POLYNOMIAL
C            AT A COMPLEX POINT AND TO CHECK WHETHER THE POLYNOMIAL
C            VALUE IS ESSENTIALLY ZERO.  THAT IS, IF  ABS(P) <= ERROR,
C            THE POINT X IS INDISTINGUISHABLE FROM A ZERO OF P, BECAUSE
C            OF ROUNDING ERROR INTRODUCED BY THE FLOATING POINT
C            ARITHMETIC.
C
C            AS A SECOND USAGE, THE CIRCLE CENTERED AT X AND OF RADIUS
C            R = NDEG*(ABS(P)+ERROR)/ABS(PPRIME)  IS KNOWN TO CONTAIN A
C            ZERO OF P.
C
C     HISTORY: THIS CODE WAS TAKEN FROM THE PROGRAM  ZERPOL, A ZERO-
C              FINDING ALGORITHM FOR POLYNOMIALS, UNIV. OF TORONTO,
C              COMPUTER SCIENCE DEPARTMENT, 1965.  THE CODE HAS BEEN
C              MODIFIED BY B. T. SMITH TO BE PORTABLE TO FORTRAN 77
C              SYSTEMS.
C
C     THIS PROGRAM IS DESIGNED TO TAKE ADVANTAGE OF SYSTEMS THAT REPORT
C     OVERFLOW AND UNDERFLOW CONDITIONS IN AN EFFICIENT WAY.  THAT IS,
C     IF, WHENEVER AN OVERFLOW OR UNDERFLOW OCCURS, CERTAIN FLAGS ARE
C     SET (THAT IS, THE LOGICAL VARIABLES OVFLOW AND UNFLOW IN THE
C     COMMON BLOCK AC02AF), C02AFY CAN USE THESE INDICATORS TO INDICATE
C     THAT THE COEFFICIENTS OF THE POLYNOMIAL NEED TO BE SCALED. SUCH
C     SCALING PERMITS THE DETERMINATION OF THE ROOTS OF THE POLYNOMIAL
C     WITHOUT INTERMEDIATE UNDERFLOW/OVERFLOW CONTAMINATING THE COMPUTED
C     ROOTS.
C
C     HOWEVER, AS IMPLEMENTED IN THE NAG LIBRARY, THE ROUTINE SIMPLY
C     ASSUMES THAT THE MACHINE TERMINATES ON OVERFLOW AND IGNORES
C     UNDERFLOW.
C
C     .. Parameters ..
      DOUBLE PRECISION  SXTEEN, THREE, TWO, TO3RDS, ZERO
      PARAMETER         (SXTEEN=16.0D0,THREE=3.0D0,TWO=2.0D0,
     *                  TO3RDS=TWO/THREE,ZERO=0.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  DX, DY, ERROR
      INTEGER           NDEG
C     .. Array Arguments ..
      DOUBLE PRECISION  A(2,0:NDEG), DEFLAT(2,0:NDEG), P(2), PDPRIM(2),
     *                  PPRIME(2)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DEPS, FINITY, SQRTFY, SQRTTY, TINY
      INTEGER           EMAX, EMIN, EXPDEP, LRGEXP
      LOGICAL           OVFLOW, UNFLOW
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSX, DT, DVI, DVR, WI, WR
      INTEGER           I
C     .. External Functions ..
      DOUBLE PRECISION  A02ABF
      EXTERNAL          A02ABF
C     .. Intrinsic Functions ..
      INTRINSIC         DBLE
C     .. Common blocks ..
      COMMON            /AC02AF/OVFLOW, UNFLOW
      COMMON            /BC02AF/DEPS, FINITY, SQRTFY, SQRTTY, TINY,
     *                  EMAX, EMIN, EXPDEP, LRGEXP
C     .. Executable Statements ..
      IF (NDEG.GE.1) THEN
C
C        ASSUME THE POLYNOMIAL IS SCALED SO THAT NO OVER/UNDERFLOW
C        OCCURS.  IF THE LARGEST COEFFICIENT IS LARGER THAN THE
C        SQRT(FINITY), UNDERFLOW CAN PROBABLY BE IGNORED.  HOWEVER,
C        OVERFLOW CANNOT BE IGNORED IN THESE CALCULATIONS IN GENERAL.
C
         ABSX = A02ABF(DX,DY)
         WR = ZERO
         WI = ZERO
         DVR = A(1,0)
         DVI = A(2,0)
         DEFLAT(1,0) = DVR
         DEFLAT(2,0) = DVI
         DEFLAT(1,1) = A(1,1) + (DX*DEFLAT(1,0)-DY*DEFLAT(2,0))
         DEFLAT(2,1) = A(2,1) + (DX*DEFLAT(2,0)+DY*DEFLAT(1,0))
C
         DO 20 I = 2, NDEG
            DT = DVR + (DX*WR-DY*WI)
            WI = DVI + (DX*WI+DY*WR)
            WR = DT
            DT = DEFLAT(1,I-1) + (DX*DVR-DY*DVI)
            DVI = DEFLAT(2,I-1) + (DX*DVI+DY*DVR)
            DVR = DT
            DEFLAT(1,I) = A(1,I) + (DX*DEFLAT(1,I-1)-DY*DEFLAT(2,I-1))
            DEFLAT(2,I) = A(2,I) + (DX*DEFLAT(2,I-1)+DY*DEFLAT(1,I-1))
   20    CONTINUE
C
         P(1) = DEFLAT(1,NDEG)
         P(2) = DEFLAT(2,NDEG)
C
C        IF OVFLOW, THE COEFFICIENTS MUST BE SCALED DOWN.
C        THIS RESCALING IS TO BE PERFORMED BY THE CALLING PROGRAM.
C        THE NEED TO RESCALE IS INDICATED BY THE FLAG  OVFLOW.
C
         IF ( .NOT. OVFLOW) THEN
C
            ERROR = TO3RDS*A02ABF(A(1,0),A(2,0))
C
            DO 40 I = 1, NDEG - 1
               ERROR = A02ABF(DEFLAT(1,I),DEFLAT(2,I)) + ABSX*ERROR
   40       CONTINUE
C
            ERROR = SXTEEN*DEPS*(A02ABF(DEFLAT(1,NDEG),DEFLAT(2,NDEG))
     *              +THREE*ABSX*ERROR)
C
C           CHECK TO SEE IF THE ERROR BOUND COMPUTATION HAS OVERFLOWED.
C           IF SO, MULTIPLY IT BY NDEG TO INSURE IT IS LARGE AND IGNORE
C           THE OVERFLOW CONDITION.
C
            IF (OVFLOW) THEN
C
               ERROR = DBLE(NDEG)*ERROR
               OVFLOW = .FALSE.
C
            END IF
C
C           COMPUTE THE FIRST AND SECOND DERIVATIVES.
C
            PPRIME(1) = DVR
            PPRIME(2) = DVI
            PDPRIM(1) = WR
            PDPRIM(2) = WR
C
         END IF
C
      ELSE IF (NDEG.EQ.0) THEN
C
         P(1) = A(1,0)
         P(2) = A(2,0)
         ERROR = ZERO
         PPRIME(1) = ZERO
         PPRIME(2) = ZERO
         PDPRIM(1) = ZERO
         PDPRIM(2) = ZERO
C
      END IF
C
      RETURN
      END
