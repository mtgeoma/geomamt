      SUBROUTINE C02AGW(XR,XI,NDEG,A,P,PPRIME,PDPRIM,ERROR,DEFLAT)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     BASED ON THE ROUTINE  CPOLYR, WRITTEN BY BRIAN T. SMITH
C
C     THIS SUBROUTINE EVALUATES A POLYNOMIAL OF DEGREE NDEG WITH REAL
C     COEFFICIENTS AT A COMPLEX POINT (XR, XI), ITS FIRST DERIVATIVE
C     AND HALF ITS SECOND DERIVATIVE AT THAT POINT AND AN ESTIMATE OF
C     THE ERROR IN THE POLYNOMIAL VALUE.  THE ESTIMATE IS A GUARANTEED
C     UPPER BOUND, ASSUMING THE COEFFICIENTS ARE EXACT, AND THE FLOATING
C     POINT ARITHMETIC IS 'WELL-BEHAVED'.
C     THAT IS,
C
C           FL(C+D) = (C+D)(1+E),  ABS(E) <= DEPS * (SMALL INTEGER)
C           FL(C*D) = (C*D)(1+F),  ABS(F) <= DEPS * (SMALL INTEGER)
C
C     WHERE FL(.) IS THE MACHINE VALUE FOR THE ENCLOSED OPERATION
C           AND  DEPS  IS A SMALL CONSTANT, USUALLY EQUAL TO THE
C           RELATIVE MACHINE PRECISION.
C
C     THE POLYNOMIAL IS ASSUMED TO BE OF THE FORM
C
C        P(X) = SUM(A(NDEG-I)*X**I, I=0,1,...,NDEG )
C
C     WHERE  A(I)  AND  X  (THE INDETERMINATE) ARE OF TYPE COMPLEX.
C     NOTE: A(0) IS THE COEFFICIENT OF X**NDEG AND  A(NDEG) IS THE
C           CONSTANT COEFFICIENT.
C
C     USAGE: THIS PROGRAM CAN BE USED TO EVALUATE A REAL POLYNOMIAL
C            AT A COMPLEX POINT AND TO CHECK WHETHER THE POLYNOMIAL
C            VALUE IS ESSENTIALLY ZERO.  THAT IS, IF  ABS(P) <= ERROR,
C            THE POINT X IS INDISTINGUISHABLE FROM A ZERO OF P, BECAUSE
C            OF ROUNDING ERROR INTRODUCED BY THE FLOATING POINT
C            ARITHMETIC.
C
C            AS A SECOND USAGE, THE CIRCLE CENTERED AT X AND OF RADIUS
C            R = NDEG*(ABS(P)+ERROR)/ABS(PPRIME)  IS KNOWN TO CONTAIN A
C            ZERO OF P.  IF IT IS KNOWN THAT THERE IS NO COMPLEX ZERO
C            IN THIS REGION, THEN THERE IS A REAL ZERO IN THE CLOSED
C            INTERVAL  [X-R,X+R].
C
C     HISTORY: THIS CODE WAS TAKEN FROM THE PROGRAM  ZERPOL, A ZERO-
C              FINDING ALGORITHM FOR POLYNOMIALS, UNIV. OF TORONTO,
C              COMPUTER SCIENCE DEPARTMENT, 1965.  THE CODE HAS BEEN
C              MODIFIED BY B. T. SMITH TO BE PORTABLE TO FORTRAN 77
C              SYSTEMS.
C
C     THIS PROGRAM IS DESIGNED TO TAKE ADVANTAGE OF SYSTEMS THAT REPORT
C     OVERFLOW AND UNDERFLOW CONDITIONS IN AN EFFICIENT WAY.  THAT IS,
C     IF, WHENEVER AN OVERFLOW OR UNDERFLOW OCCURS, CERTAIN FLAGS ARE
C     SET (THAT IS, THE LOGICAL VARIABLES OVFLOW AND UNFLOW IN THE
C     COMMON BLOCK AC02AG), C02AGW CAN USE THESE INDICATORS TO INDICATE
C     THAT THE COEFFICIENTS OF THE POLYNOMIAL NEED TO BE SCALED. SUCH
C     SCALING PERMITS THE DETERMINATION OF THE ROOTS OF THE POLYNOMIAL
C     WITHOUT INTERMEDIATE UNDERFLOW/OVERFLOW CONTAMINATING THE
C     COMPUTED ROOTS.
C
C     HOWEVER, AS IMPLEMENTED IN THE NAG LIBRARY, THE ROUTINE SIMPLY
C     ASSUMES THAT THE MACHINE TERMINATES ON OVERFLOW AND IGNORES
C     UNDERFLOW.
C
C     .. Parameters ..
      DOUBLE PRECISION  ZERO, TWO, NINE, SXTEEN, THREE
      PARAMETER         (ZERO=0.0D0,TWO=2.0D0,NINE=9.0D0,SXTEEN=16.0D0,
     *                  THREE=3.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ERROR, XI, XR
      INTEGER           NDEG
C     .. Array Arguments ..
      DOUBLE PRECISION  A(0:NDEG), DEFLAT(0:NDEG), P(2), PDPRIM(2),
     *                  PPRIME(2)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DEPS, FINITY, SQRTFY, SQRTTY, TINY
      INTEGER           EMAXM1, EMINM1, EXPDEP, LRGEXP
      LOGICAL           OVFLOW, UNFLOW
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSP, ABSX, DR, DSC, DT, DT1, DV, DX, DX2, DY,
     *                  S, S1, SC, V, XC1, XC2
      INTEGER           I
C     .. Local Arrays ..
      DOUBLE PRECISION  CX(2)
C     .. External Functions ..
      DOUBLE PRECISION  A02ABF
      EXTERNAL          A02ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /AC02AG/OVFLOW, UNFLOW
      COMMON            /BC02AG/FINITY, SQRTFY, SQRTTY, TINY, DEPS,
     *                  EMINM1, EMAXM1, EXPDEP, LRGEXP
C     .. Statement Functions ..
      DOUBLE PRECISION  APXABS
C     .. Save statement ..
      SAVE              /AC02AG/, /BC02AG/
C     .. Statement Function definitions ..
      APXABS(XC1,XC2) = ABS(XC1) + ABS(XC2)
C     .. Executable Statements ..
      IF (NDEG.GE.1) THEN
C
C        ASSUME THE POLYNOMIAL IS SCALED SO THAT NO OVER/UNDERFLOW
C        OCCURS.  IF THE LARGEST COEFFICIENT IS LARGER THAN THE
C        SQRT(FINITY), UNDERFLOW CAN PROBABLY BE IGNORED.  HOWEVER,
C        OVERFLOW CANNOT BE IGNORED IN THESE CALCULATIONS IN GENERAL.
C
         S = ZERO
         S1 = ZERO
         DT1 = ZERO
         DT = A(0)
         DEFLAT(0) = A(0)
         DX = XR
         DY = XI
C
C        SC  IS COMPUTED TO CHECK IF SCALING IS NEEDED TO AVOID
C        SPURIOUS OVERFLOW OR UNDERFLOW.  THE SCALE FACTOR NEEDS TO BE
C        AN UPPER BOUND FOR THE MODULUS OF THE ROOT TO AVOID SUCH RANGE
C        EXCEPTIONS.  HOWEVER, THE EXACT MODULUS OF THE ROOT IS NEEDED
C        TO COMPUTE AN ESTIMATE OF THE ERROR IN THE POLYNOMIAL VALUE.
C
         CX(1) = DX
         CX(2) = DY
         ABSX = A02ABF(CX(1),CX(2))
         SC = APXABS(CX(1),CX(2))
C
C        IF  ABS(CMPLX(X,Y)).LE.SQRT(SMALLEST NO.), SCALE UP   X AND Y.
C        IF  ABS(CMPLX(X,Y)).GE.SQRT(LARGEST  NO.), SCALE DOWN X AND Y.
C
         IF (SC.LT.SQRTFY .AND. SC.GE.SQRTTY) THEN
C
C           SCALING OF  DX2  AND  DR  IS UNNECESSARY.
C
            DX2 = DX + DX
            DR = DX*DX + DY*DY
            IF (NDEG.GE.3) THEN
               DEFLAT(1) = A(1) + DX2*A(0)
               DEFLAT(2) = A(2) + (DX2*DEFLAT(1)-DR*A(0))
               DO 20 I = 3, NDEG - 1
                  V = S1*DR
                  S1 = S
                  S = DT1 + (DX2*S-V)
                  DV = DT1*DR
                  DT1 = DT
                  DT = (DX2*DT-DV) + DEFLAT(I-2)
                  DEFLAT(I) = A(I) + (DX2*DEFLAT(I-1)-DR*DEFLAT(I-2))
   20          CONTINUE
               V = S1*DR
               S1 = S
               S = DT1 + (DX*S-V)
               DV = DT1*DR
               DT1 = DT
               DT = (DX*DT-DV) + DEFLAT(NDEG-2)
               DEFLAT(NDEG) = A(NDEG) + (DX*DEFLAT(NDEG-1)
     *                        -DR*DEFLAT(NDEG-2))
            ELSE IF (NDEG.EQ.2) THEN
               DEFLAT(1) = A(1) + DX2*A(0)
               DEFLAT(2) = A(2) + (DX*DEFLAT(1)-DR*A(0))
            ELSE
C
C              NDEG IS 1.
C
               DT = ZERO
               DEFLAT(1) = A(1) + DX*A(0)
            END IF
         ELSE
C
C           SCALE  DX  AND  DY  LEST  DR  OVERFLOWS OR UNDERFLOWS.
C
            DSC = SC
            DX = DX/DSC
            DY = DY/DSC
C
C           DR  CANNOT OVERFLOW, FORTUNATELY.
C
            DR = (DX*DX+DY*DY)*DSC
            DX2 = DX + DX
            IF (NDEG.GE.3) THEN
               DEFLAT(1) = A(1) + (DX2*A(0))*DSC
               DEFLAT(2) = A(2) + (DX2*DEFLAT(1)-DR*A(0))*DSC
               DO 40 I = 3, NDEG - 1
                  V = S1*DR
                  S1 = S
                  S = DT1 + (DX2*S-V)*DSC
                  DV = DT1*DR
                  DT1 = DT
                  DV = DX2*DT - DV
                  DT = DEFLAT(I-2) + DV*DSC
                  DEFLAT(I) = A(I) + (DX2*DEFLAT(I-1)-DR*DEFLAT(I-2))
     *                        *DSC
   40          CONTINUE
               V = S1*DR
               S1 = S
               S = DT1 + (DX*S-V)*DSC
               DV = DT1*DR
               DT1 = DT
               DV = DX*DT - DV
               DT = DEFLAT(NDEG-2) + DV*DSC
               DEFLAT(NDEG) = A(NDEG) + (DX*DEFLAT(NDEG-1)
     *                        -DR*DEFLAT(NDEG-2))*DSC
            ELSE IF (NDEG.EQ.2) THEN
               DEFLAT(1) = A(1) + (DX2*A(0))*DSC
               DEFLAT(2) = A(2) + (DX*DEFLAT(1)-DR*A(0))*DSC
            ELSE
C
C              NDEG IS 1.
C
               DT = ZERO
               DEFLAT(1) = A(1) + (DX*A(0))*DSC
            END IF
            DY = DY*DSC
         END IF
C
C        COMPUTE THE POLYNOMIAL VALUE.
C
         P(1) = DEFLAT(NDEG)
         P(2) = DY*DEFLAT(NDEG-1)
C
C        IF OVFLOW, THE COEFFICIENTS MUST BE SCALED DOWN.
C        THIS RESCALING IS TO BE PERFORMED BY THE CALLING PROGRAM.
C        THE NEED TO RESCALE IS INDICATED BY THE FLAG  OVFLOW.
C
C        FOR A MACHINE THAT USES IEEE ARITHMETIC, AN EFFECTIVE BUT
C        INCOMPLETE TEST FOR OVERFLOW IS TO CHECK WHETHER THE RESULT
C        P IS EQUAL TO INFINITY.  THIS MAY WORK ON OTHER MACHINES IF
C        AN OVERFLOW DOES NOT TERMINATE THE COMPUTATION AND IS REPLACED
C        WITH A VALUE THAT PERSISTS THROUGH SUBSEQUENT COMPUTATIONS.
C
         ABSP = A02ABF(P(1),P(2))
         OVFLOW = ABSP .GE. FINITY
         IF ( .NOT. OVFLOW) THEN
            ERROR = ABS(A(0))
            DO 60 I = 2, NDEG - 1
               ERROR = ABS(DEFLAT(I-1)) + ABSX*ERROR
   60       CONTINUE
            ERROR = SXTEEN*DEPS*((NINE*ERROR*ABSX+THREE*ABS(DEFLAT(NDEG-
     *              1)))*ABSX+ABS(DEFLAT(NDEG)))
C
C           CHECK TO SEE IF THE ERROR BOUND COMPUTATION HAS OVERFLOWED.
C           IF SO, MULTIPLY IT BY NDEG TO INSURE IT IS LARGE AND IGNORE
C           THE OVERFLOW CONDITION.
C
C           FOR A MACHINE THAT USES IEEE ARITHMETIC, AN EFFECTIVE BUT
C           INCOMPLETE TEST FOR OVERFLOW IS TO CHECK WHETHER THE RESULT
C           ERROR IS EQUAL TO INFINITY.  THIS MAY WORK ON OTHER MACHINES
C           IF AN OVERFLOW DOES NOT TERMINATE THE COMPUTATION AND IS
C           REPLACED WITH A VALUE THAT PERSISTS THROUGH SUBSEQUENT
C           COMPUTATIONS.
C
            OVFLOW = ERROR .GE. FINITY
            IF (OVFLOW) THEN
               ERROR = NDEG*ERROR
               OVFLOW = .FALSE.
            END IF
C
C           COMPUTE THE FIRST AND SECOND DERIVATIVES.  IF OVERFLOW
C           OCCURS IN THIS COMPUTATION, THE FLAG OVFLOW WILL BE SET.
C
            DV = TWO*DY
            PPRIME(1) = DEFLAT(NDEG-1) - DV*DT1*DY
            PPRIME(2) = DV*DT
            PDPRIM(1) = DT - DV*(DV*S)
            PDPRIM(2) = DY*(THREE*DT1-DV*(DV*S1))
         END IF
      ELSE IF (NDEG.EQ.0) THEN
         ERROR = ZERO
         P(1) = A(0)
         P(2) = ZERO
         PPRIME(1) = ZERO
         PPRIME(2) = ZERO
         PDPRIM(1) = ZERO
         PDPRIM(2) = ZERO
      END IF
      RETURN
      END
