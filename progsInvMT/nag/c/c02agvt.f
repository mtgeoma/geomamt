      SUBROUTINE C02AGV(DX,NDEG,A,P,PPRIME,PDPRIM,ERROR,DEFLAT)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     BASED ON THE ROUTINE  RPOLYR, WRITTEN BY BRIAN T. SMITH
C
C     THIS SUBROUTINE EVALUATES A POLYNOMIAL OF DEGREE NDEG WITH REAL
C     COEFFICIENTS AT A REAL POINT, ITS FIRST DERIVATIVE AND HALF ITS
C     SECOND DERIVATIVE AT THAT POINT AND AN ESTIMATE OF THE ERROR IN
C     THE POLYNOMIAL VALUE.  THE ESTIMATE IS A GUARANTEED UPPER BOUND,
C     ASSUMING THE COEFFICIENTS ARE EXACT, AND THE FLOATING POINT
C     ARITHMETIC IS 'WELL-BEHAVED'.
C     THAT IS,
C
C           FL(C+D) = (C+D)(1+E),  ABS(E) <= DEPS * (SMALL INTEGER)
C           FL(C*D) = (C*D)(1+F),  ABS(F) <= DEPS * (SMALL INTEGER)
C
C     WHERE FL(.) IS THE MACHINE VALUE FOR THE ENCLOSED OPERATION
C           AND  DEPS  IS A SMALL CONSTANT, USUALLY EQUAL TO THE
C           RELATIVE MACHINE PRECISION.
C
C     THE POLYNOMIAL IS ASSUMED TO BE OF THE FORM
C
C        P(X) = SUM(A(NDEG-I)*X**I, I=0,1,...,NDEG )
C
C     WHERE  A(I) AND  X  ARE DOUBLE PRECISION.
C     NOTE: A(0) IS THE COEFFICIENT OF X**NDEG AND  A(NDEG) IS THE
C           CONSTANT COEFFICIENT.
C
C     USAGE: THIS PROGRAM CAN BE USED TO EVALUATE A REAL POLYNOMIAL
C            AT A REAL POINT AND TO CHECK WHETHER THE POLYNOMIAL VALUE
C            IS ESSENTIALLY ZERO.  THAT IS, IF  ABS(P) <= ERROR, THE
C            POINT X IS INDISTINGUISHABLE FROM A ZERO OF P, BECAUSE OF
C            ROUNDING ERROR INTRODUCED BY THE FLOATING POINT ARITHMETIC.
C
C            AS A SECOND USAGE, THE CIRCLE CENTERED AT X AND OF RADIUS
C            R = NDEG*(ABS(P)+ERROR)/ABS(PPRIME)  IS KNOWN TO CONTAIN A
C            ZERO OF P.  IF IT IS KNOWN THAT THERE IS NO COMPLEX ZERO
C            IN THIS REGION, THEN THERE IS A REAL ZERO IN THE CLOSED
C            INTERVAL  [X-R,X+R].
C
C     HISTORY: THIS CODE WAS TAKEN FROM THE PROGRAM  ZERPOL, A ZERO-
C              FINDING ALGORITHM FOR POLYNOMIALS, UNIV. OF TORONTO,
C              COMPUTER SCIENCE DEPARTMENT, 1965.  THE CODE HAS BEEN
C              MODIFIED BY B. T. SMITH TO BE PORTABLE TO FORTRAN 77
C              SYSTEMS.
C
C     THIS PROGRAM IS DESIGNED TO TAKE ADVANTAGE OF SYSTEMS THAT REPORT
C     OVERFLOW AND UNDERFLOW CONDITIONS IN AN EFFICIENT WAY.  THAT IS,
C     IF, WHENEVER AN OVERFLOW OR UNDERFLOW OCCURS, CERTAIN FLAGS ARE
C     SET (THAT IS, THE LOGICAL VARIABLES OVFLOW AND UNFLOW IN THE
C     COMMON BLOCK AC02AG), C02AGV CAN USE THESE INDICATORS TO INDICATE
C     THAT THE COEFFICIENTS OF THE POLYNOMIAL NEED TO BE SCALED.  SUCH
C     SCALING PERMITS THE DETERMINATION OF THE ROOTS OF THE POLYNOMIAL
C     WITHOUT INTERMEDIATE UNDERFLOW/OVERFLOW CONTAMINATING THE
C     COMPUTED ROOTS.
C
C     HOWEVER, AS IMPLEMENTED IN THE NAG LIBRARY, THE ROUTINE SIMPLY
C     ASSUMES THAT THE MACHINE TERMINATES ON OVERFLOW AND IGNORES
C     UNDERFLOW.
C
C     .. Parameters ..
      DOUBLE PRECISION  SXTEEN, THREE, TWO, TO3RDS, ZERO
      PARAMETER         (SXTEEN=16.0D0,THREE=3.0D0,TWO=2.0D0,
     *                  TO3RDS=TWO/THREE,ZERO=0.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  DX, ERROR, P, PDPRIM, PPRIME
      INTEGER           NDEG
C     .. Array Arguments ..
      DOUBLE PRECISION  A(0:NDEG), DEFLAT(0:NDEG)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DEPS, FINITY, SQRTFY, SQRTTY, TINY
      INTEGER           EMAXM1, EMINM1, EXPDEP, LRGEXP
      LOGICAL           OVFLOW, UNFLOW
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSP, ABSX, DV, SX, W
      INTEGER           I
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /AC02AG/OVFLOW, UNFLOW
      COMMON            /BC02AG/FINITY, SQRTFY, SQRTTY, TINY, DEPS,
     *                  EMINM1, EMAXM1, EXPDEP, LRGEXP
C     .. Save statement ..
      SAVE              /AC02AG/, /BC02AG/
C     .. Executable Statements ..
      IF (NDEG.GE.1) THEN
C
C        ASSUME THE POLYNOMIAL IS SCALED SO THAT NO OVER/UNDERFLOW
C        OCCURS.  IF THE LARGEST COEFFICIENT IS LARGER THAN THE
C        SQRT(FINITY), UNDERFLOW CAN PROBABLY BE IGNORED.  HOWEVER,
C        OVERFLOW CANNOT BE IGNORED IN THESE CALCULATIONS IN GENERAL.
C
         SX = DX
         ABSX = ABS(SX)
         W = ZERO
         DV = A(0)
         DEFLAT(0) = DV
         DEFLAT(1) = A(1) + DX*DEFLAT(0)
         DO 20 I = 2, NDEG
            W = DV + SX*W
            DV = DEFLAT(I-1) + DX*DV
            DEFLAT(I) = A(I) + DX*DEFLAT(I-1)
   20    CONTINUE
         P = DEFLAT(NDEG)
C
C        IF OVFLOW, THE COEFFICIENTS MUST BE SCALED DOWN.
C        THIS RESCALING IS TO BE PERFORMED BY THE CALLING PROGRAM.
C        THE NEED TO RESCALE IS INDICATED BY THE FLAG  OVFLOW.
C
C        FOR A MACHINE THAT USES IEEE ARITHMETIC, AN EFFECTIVE BUT
C        INCOMPLETE TEST FOR OVERFLOW IS TO CHECK WHETHER THE RESULT
C        P IS EQUAL TO INFINITY.  THIS MAY WORK ON OTHER MACHINES IF
C        AN OVERFLOW DOES NOT TERMINATE THE COMPUTATION AND IS REPLACED
C        WITH A VALUE THAT PERSISTS THROUGH SUBSEQUENT COMPUTATIONS.
C
         ABSP = ABS(P)
         OVFLOW = ABSP .GE. FINITY
         IF ( .NOT. OVFLOW) THEN
            ERROR = TO3RDS*ABS(A(0))
            DO 40 I = 1, NDEG - 1
               ERROR = ABS(DEFLAT(I)) + ABSX*ERROR
   40       CONTINUE
            ERROR = SXTEEN*DEPS*(ABS(DEFLAT(NDEG))+THREE*ABSX*ERROR)
C
C           CHECK TO SEE IF THE ERROR BOUND COMPUTATION HAS OVERFLOWED.
C           IF SO, MULTIPLY IT BY NDEG TO INSURE IT IS LARGE AND IGNORE
C           THE OVERFLOW CONDITION.
C
C           FOR A MACHINE THAT USES IEEE ARITHMETIC, AN EFFECTIVE BUT
C           INCOMPLETE TEST FOR OVERFLOW IS TO CHECK WHETHER THE RESULT
C           ERROR IS EQUAL TO INFINITY.  THIS MAY WORK ON OTHER MACHINES
C           IF AN OVERFLOW DOES NOT TERMINATE THE COMPUTATION AND IS
C           REPLACED WITH A VALUE THAT PERSISTS THROUGH SUBSEQUENT
C           COMPUTATIONS.
C
            OVFLOW = ERROR .GE. FINITY
            IF (OVFLOW) THEN
               P = FINITY
               PPRIME = FINITY
               PDPRIM = FINITY
               ERROR = TINY
               OVFLOW = .FALSE.
            ELSE
C
C              COMPUTE THE FIRST AND SECOND DERIVATIVES.
C
               PPRIME = DV
               PDPRIM = W
            END IF
         END IF
      ELSE IF (NDEG.EQ.0) THEN
         P = A(0)
         ERROR = ZERO
         PPRIME = ZERO
         PDPRIM = ZERO
      END IF
      RETURN
      END
