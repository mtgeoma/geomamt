      SUBROUTINE D02QFP(IREVCM,NEQ,TWANT,B,Y,YPRIME,ETOL,MORDER,SMALL,
     *                  BIG,SPY,PV,YP,SF,H)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     D02QFP COMPUTES A STARTING STEP SIZE TO BE USED IN SOLVING INITIAL
C     VALUE PROBLEMS IN ORDINARY DIFFERENTIAL EQUATIONS.
C     ******************************************************************
C
C     ABSTRACT
C
C     SUBROUTINE D02QFP COMPUTES A STARTING STEP SIZE TO BE USED BY AN
C     INITIAL VALUE METHOD IN SOLVING ORDINARY DIFFERENTIAL EQUATIONS.
C     IT IS BASED ON AN ESTIMATE OF THE LOCAL LIPSCHITZ CONSTANT FOR THE
C     DIFFERENTIAL EQUATION   (LOWER BOUND ON A NORM OF THE JACOBIAN) ,
C     A BOUND ON THE DIFFERENTIAL EQUATION  (FIRST DERIVATIVE) , AND
C     A BOUND ON THE PARTIAL DERIVATIVE OF THE EQUATION WITH RESPECT TO
C     THE INDEPENDENT VARIABLE.
C     (ALL APPROXIMATED NEAR THE INITIAL POINT A)
C
C     SUBROUTINE D02QFP USES A FUNCTION SUBPROGRAM D02QFN FOR COMPUTING
C     A VECTOR NORM. THE MAXIMUM NORM IS PRESENTLY UTILIZED THOUGH IT
C     CAN EASILY BE REPLACED BY ANY OTHER VECTOR NORM. IT IS PRESUMED
C     THAT ANY REPLACEMENT NORM ROUTINE WOULD BE CAREFULLY CODED TO
C     PREVENT UNNECESSARY UNDERFLOWS OR OVERFLOWS FROM OCCURRING, AND
C     ALSO, WOULD NOT ALTER THE VECTOR OR NUMBER OF COMPONENTS.
C
C     *****************************************************************
C     ON INPUT YOU MUST PROVIDE THE FOLLOWING
C
C      F   -- THIS IS A SUBROUTINE OF THE FORM
C                               F(X,U,UPRIME,RPAR,IPAR)
C             WHICH DEFINES THE SYSTEM OF FIRST ORDER DIFFERENTIAL
C             EQUATIONS TO BE SOLVED. FOR THE GIVEN VALUES OF X AND THE
C             VECTOR  U(*)=(U(1),U(2),...,U(NEQ)) , THE SUBROUTINE MUST
C             EVALUATE THE NEQ COMPONENTS OF THE SYSTEM OF DIFFERENTIAL
C             EQUATIONS  DU/DX=F(X,U)  AND STORE THE DERIVATIVES IN THE
C             ARRAY UPRIME(*), THAT IS,  UPRIME(I) = * DU(I)/DX *  FOR
C             EQUATIONS I=1,...,NEQ.
C
C             SUBROUTINE F MUST NOT ALTER X OR U(*). YOU MUST DECLARE
C             THE NAME F IN AN EXTERNAL STATEMENT IN YOUR PROGRAM THAT
C             CALLS D02QFP. YOU MUST DIMENSION U AND UPRIME IN F.
C
C             RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C             YOU CAN USE FOR COMMUNICATION BETWEEN YOUR PROGRAM AND
C             SUBROUTINE F. THEY ARE NOT USED OR ALTERED BY D02QFP. IF
C             YOU DO NOT NEED RPAR OR IPAR, IGNORE THESE PARAMETERS BY
C             TREATING THEM AS DUMMY ARGUMENTS. IF YOU DO CHOOSE TO USE
C             THEM, DIMENSION THEM IN YOUR PROGRAM AND IN F AS ARRAYS
C             OF APPROPRIATE LENGTH.
C
C      NEQ -- THIS IS THE NUMBER OF (FIRST ORDER) DIFFERENTIAL EQUATIONS
C             TO BE INTEGRATED.
C
C      A   -- THIS IS THE INITIAL POINT OF INTEGRATION.
C
C      B   -- THIS IS A VALUE OF THE INDEPENDENT VARIABLE USED TO DEFINE
C             THE DIRECTION OF INTEGRATION. A REASONABLE CHOICE IS TO
C             SET  B  TO THE FIRST POINT AT WHICH A SOLUTION IS DESIRED.
C             YOU CAN ALSO USE  B, IF NECESSARY, TO RESTRICT THE LENGTH
C             OF THE FIRST INTEGRATION STEP BECAUSE THE ALGORITHM WILL
C             NOT COMPUTE A STARTING STEP LENGTH WHICH IS BIGGER THAN
C             ABS(B-A), UNLESS  B  HAS BEEN CHOSEN TOO CLOSE TO  A.
C             (IT IS PRESUMED THAT D02QFP HAS BEEN CALLED WITH  B
C             DIFFERENT FROM  A  ON THE MACHINE BEING USED. ALSO SEE THE
C             DISCUSSION ABOUT THE PARAMETER  SMALL.)
C
C      Y(*) -- THIS IS THE VECTOR OF INITIAL VALUES OF THE NEQ SOLUTION
C             COMPONENTS AT THE INITIAL POINT  A.
C
C      YPRIME(*) -- THIS IS THE VECTOR OF DERIVATIVES OF THE NEQ
C             SOLUTION COMPONENTS AT THE INITIAL POINT  A.
C             (DEFINED BY THE DIFFERENTIAL EQUATIONS IN SUBROUTINE F)
C
C      ETOL -- THIS IS THE VECTOR OF ERROR TOLERANCES CORRESPONDING TO
C             THE NEQ SOLUTION COMPONENTS. IT IS ASSUMED THAT ALL
C             ELEMENTS ARE POSITIVE. FOLLOWING THE FIRST INTEGRATION
C             STEP, THE TOLERANCES ARE EXPECTED TO BE USED BY THE
C             INTEGRATOR IN AN ERROR TEST WHICH ROUGHLY REQUIRES THAT
C                        ABS(LOCAL ERROR) .LE. ETOL
C             FOR EACH VECTOR COMPONENT.
C
C      MORDER -- THIS IS THE ORDER OF THE FORMULA WHICH WILL BE USED BY
C             THE INITIAL VALUE METHOD FOR TAKING THE FIRST INTEGRATION
C             STEP.
C
C      SMALL -- THIS IS A SMALL POSITIVE MACHINE DEPENDENT CONSTANT
C             WHICH IS USED FOR PROTECTING AGAINST COMPUTATIONS WITH
C             NUMBERS WHICH ARE TOO SMALL RELATIVE TO THE PRECISION OF
C             FLOATING POINT ARITHMETIC.  SMALL  SHOULD BE SET TO
C             (APPROXIMATELY) THE SMALLEST POSITIVE REAL NUMBER SUCH
C             THAT  (1.+SMALL) .GT. 1.  ON THE MACHINE BEING USED. THE
C             QUANTITY  SMALL**(3/8)  IS USED IN COMPUTING INCREMENTS OF
C             VARIABLES FOR APPROXIMATING DERIVATIVES BY DIFFERENCES.
C             ALSO THE ALGORITHM WILL NOT COMPUTE A STARTING STEP LENGTH
C             WHICH IS SMALLER THAN  100*SMALL*ABS(A).
C
C      BIG -- THIS IS A LARGE POSITIVE MACHINE DEPENDENT CONSTANT WHICH
C             IS USED FOR PREVENTING MACHINE OVERFLOWS. A REASONABLE
C             CHOICE IS TO SET BIG TO (APPROXIMATELY) THE SQUARE ROOT OF
C             THE LARGEST REAL NUMBER WHICH CAN BE HELD IN THE MACHINE.
C
C      SPY(*),PV(*),YP(*),SF(*) -- THESE ARE REAL WORK ARRAYS OF LENGTH
C             NEQ WHICH PROVIDE THE ROUTINE WITH NEEDED STORAGE SPACE.
C
C      RPAR,IPAR -- THESE ARE PARAMETER ARRAYS, OF REAL AND INTEGER
C             TYPE, RESPECTIVELY, WHICH CAN BE USED FOR COMMUNICATION
C             BETWEEN YOUR PROGRAM AND THE F SUBROUTINE. THEY ARE NOT
C             USED OR ALTERED BY D02QFP.
C
C     *****************************************************************
C     ON OUTPUT  (AFTER THE RETURN FROM D02QFP),
C
C      H -- IS AN APPROPRIATE STARTING STEP SIZE TO BE ATTEMPTED BY THE
C             DIFFERENTIAL EQUATION METHOD.
C
C           ALL PARAMETERS IN THE CALL LIST REMAIN UNCHANGED EXCEPT FOR
C           THE WORKING ARRAYS SPY(*),PV(*),YP(*) AND SF(*).
C
C     *****************************************************************
C
C     REVISION DATE  861016   (YYMMDD)
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  B, BIG, H, SMALL, TWANT
      INTEGER           IREVCM, MORDER, NEQ
C     .. Array Arguments ..
      DOUBLE PRECISION  ETOL(NEQ), PV(NEQ), SF(NEQ), SPY(NEQ), Y(NEQ),
     *                  YP(NEQ), YPRIME(NEQ)
C     .. Scalars in Common ..
      DOUBLE PRECISION  A, ABSDX, DA, DELX, DFDUB, DFDXB, DX, FBND,
     *                  POWER, RELPER, YNORM, YPNORM
      INTEGER           ICASE, K, LK
C     .. Local Scalars ..
      DOUBLE PRECISION  DELF, DELXB, DELY, DY, SRYDPB, WTJ, YDPB
      INTEGER           J
C     .. External Functions ..
      DOUBLE PRECISION  D02QFN
      EXTERNAL          D02QFN
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, DBLE, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /JD02QF/A, ABSDX, DA, DELX, DFDUB, DFDXB, DX,
     *                  FBND, POWER, RELPER, YNORM, YPNORM, ICASE, K, LK
C     .. Save statement ..
      SAVE              /JD02QF/
C     .. Executable Statements ..
C
C     ..................................................................
C
      GO TO (20,320,380) IREVCM - 2
      A = TWANT
      DX = B - A
      ABSDX = ABS(DX)
      RELPER = SMALL**0.375D0
C     YNORM = VNORM(Y,NEQ)
      YNORM = D02QFN(Y,NEQ)
C
C     ..................................................................
C
C     COMPUTE A WEIGHTED APPROXIMATE BOUND (DFDXB) ON THE PARTIAL
C     DERIVATIVE OF THE EQUATION WITH RESPECT TO THE
C     INDEPENDENT VARIABLE. PROTECT AGAINST AN OVERFLOW. ALSO
C     COMPUTE A WEIGHTED BOUND (FBND) ON THE FIRST DERIVATIVE LOCALLY.
C
      DA = SIGN(MAX(MIN(RELPER*ABS(A),ABSDX),100.D0*SMALL*ABS(A)),DX)
      IF (DA.EQ.0.D0) DA = RELPER*DX
C     CALL F(A+DA,Y,SF,RPAR,IPAR)
      IREVCM = 3
      TWANT = A + DA
      RETURN
   20 CONTINUE
      IREVCM = 0
C
      IF (MORDER.EQ.1) GO TO 60
      POWER = 2.D0/DBLE(MORDER+1)
      DO 40 J = 1, NEQ
         WTJ = ETOL(J)**POWER
         SPY(J) = SF(J)/WTJ
         YP(J) = YPRIME(J)/WTJ
         PV(J) = SPY(J) - YP(J)
   40 CONTINUE
      GO TO 100
C
   60 DO 80 J = 1, NEQ
         SPY(J) = SF(J)/ETOL(J)
         YP(J) = YPRIME(J)/ETOL(J)
         PV(J) = SPY(J) - YP(J)
   80 CONTINUE
C
C     100 DELF = VNORM(PV,NEQ)
  100 DELF = D02QFN(PV,NEQ)
      DFDXB = BIG
      IF (DELF.LT.BIG*ABS(DA)) DFDXB = DELF/ABS(DA)
C     YPNORM = VNORM(YP,NEQ)
      YPNORM = D02QFN(YP,NEQ)
C     FBND = MAX(VNORM(SPY,NEQ),YPNORM)
      FBND = MAX(D02QFN(SPY,NEQ),YPNORM)
C
C     ..................................................................
C
C     COMPUTE AN ESTIMATE (DFDUB) OF THE LOCAL LIPSCHITZ CONSTANT FOR
C     THE SYSTEM OF DIFFERENTIAL EQUATIONS. THIS ALSO REPRESENTS AN
C     ESTIMATE OF THE NORM OF THE JACOBIAN LOCALLY.
C     THREE ITERATIONS (TWO WHEN NEQ=1) ARE USED TO ESTIMATE THE
C     LIPSCHITZ CONSTANT BY NUMERICAL DIFFERENCES. THE FIRST
C     PERTURBATION VECTOR IS BASED ON THE INITIAL DERIVATIVES AND
C     DIRECTION OF INTEGRATION. THE SECOND PERTURBATION VECTOR IS
C     FORMED USING ANOTHER EVALUATION OF THE DIFFERENTIAL EQUATION.
C     THE THIRD PERTURBATION VECTOR IS FORMED USING PERTURBATIONS BASED
C     ONLY ON THE INITIAL VALUES. COMPONENTS THAT ARE ZERO ARE ALWAYS
C     CHANGED TO NON-ZERO VALUES (EXCEPT ON THE FIRST ITERATION). WHEN
C     INFORMATION IS AVAILABLE, CARE IS TAKEN TO ENSURE THAT COMPONENTS
C     OF THE PERTURBATION VECTOR HAVE SIGNS WHICH ARE CONSISTENT WITH
C     THE SLOPES OF LOCAL SOLUTION CURVES.
C     ALSO CHOOSE THE LARGEST BOUND (FBND) FOR THE FIRST DERIVATIVE.
C     NO ATTEMPT IS MADE TO KEEP THE PERTURBATION VECTOR SIZE CONSTANT.
C
      IF (YPNORM.EQ.0.D0) GO TO 140
C                       USE INITIAL DERIVATIVES FOR FIRST PERTURBATION
      ICASE = 1
      DO 120 J = 1, NEQ
         SPY(J) = YPRIME(J)
         YP(J) = YPRIME(J)
  120 CONTINUE
      GO TO 180
C                       CANNOT HAVE A NULL PERTURBATION VECTOR
  140 ICASE = 2
      DO 160 J = 1, NEQ
         SPY(J) = YPRIME(J)
         YP(J) = ETOL(J)
  160 CONTINUE
C
  180 DFDUB = 0.D0
      LK = MIN(NEQ+1,3)
C     DO 260 K=1,LK
      K = 0
  200 K = K + 1
C                       SET YPNORM AND DELX
C     YPNORM = VNORM(YP,NEQ)
      YPNORM = D02QFN(YP,NEQ)
      IF (ICASE.EQ.1 .OR. ICASE.EQ.3) GO TO 220
      DELX = SIGN(1.0D0,DX)
      GO TO 280
C                       TRY TO ENFORCE MEANINGFUL PERTURBATION VALUES
  220 DELX = DX
      IF (ABS(DELX)*YPNORM.GE.RELPER*YNORM) GO TO 240
      DELXB = BIG
      IF (RELPER*YNORM.LT.BIG*YPNORM) DELXB = RELPER*YNORM/YPNORM
      DELX = SIGN(DELXB,DX)
  240 DO 260 J = 1, NEQ
         IF (ABS(DELX*YP(J)).GT.ETOL(J)) DELX = SIGN(ETOL(J)/YP(J),DX)
  260 CONTINUE
C                       DEFINE PERTURBED VECTOR OF INITIAL VALUES
  280 DO 300 J = 1, NEQ
         PV(J) = Y(J) + DELX*YP(J)
  300 CONTINUE
      IF (K.EQ.2) GO TO 360
C                       EVALUATE DERIVATIVES ASSOCIATED WITH PERTURBED
C                       VECTOR  AND  COMPUTE CORRESPONDING DIFFERENCES
C       CALL F(A,PV,YP,RPAR,IPAR)
      IREVCM = 4
      TWANT = A
      RETURN
  320 CONTINUE
      IREVCM = 0
      DO 340 J = 1, NEQ
         PV(J) = YP(J) - YPRIME(J)
  340 CONTINUE
      GO TO 420
C                       USE A SHIFTED VALUE OF THE INDEPENDENT VARIABLE
C                                             IN COMPUTING ONE ESTIMATE
C     150   CALL F(A+DA,PV,YP,RPAR,IPAR)
  360 CONTINUE
      IREVCM = 5
      TWANT = A + DA
      RETURN
  380 CONTINUE
      IREVCM = 0
      DO 400 J = 1, NEQ
         PV(J) = YP(J) - SF(J)
  400 CONTINUE
C                       CHOOSE LARGEST BOUND ON THE WEIGHTED FIRST
C                                                   DERIVATIVE
  420 IF (MORDER.EQ.1) GO TO 460
      DO 440 J = 1, NEQ
         YP(J) = YP(J)/ETOL(J)**POWER
  440 CONTINUE
      GO TO 500
  460 DO 480 J = 1, NEQ
         YP(J) = YP(J)/ETOL(J)
  480 CONTINUE
C     500 FBND = MAX(FBND,VNORM(YP,NEQ))
  500 FBND = MAX(FBND,D02QFN(YP,NEQ))
C                       COMPUTE BOUND ON A LOCAL LIPSCHITZ CONSTANT
C     DELF = VNORM(PV,NEQ)
      DELF = D02QFN(PV,NEQ)
      IF (DELF.EQ.0.D0) GO TO 520
      DELY = ABS(DELX)*YPNORM
      IF (DELF.GE.BIG*DELY) GO TO 600
      DFDUB = MAX(DFDUB,DELF/DELY)
C
  520 IF (K.EQ.LK) GO TO 620
C                       CHOOSE NEXT PERTURBATION VECTOR
      DO 580 J = 1, NEQ
         IF (K.EQ.LK-1) GO TO 540
         ICASE = 3
         DY = ABS(PV(J))
         IF (DY.EQ.0.D0) DY = MAX(DELF,ETOL(J))
         GO TO 560
  540    ICASE = 4
         DY = MAX(RELPER*ABS(Y(J)),ETOL(J))
  560    IF (SPY(J).EQ.0.D0) SPY(J) = YP(J)
         IF (SPY(J).NE.0.D0) DY = SIGN(DY,SPY(J))
         YP(J) = DY
  580 CONTINUE
C     260   CONTINUE
      IF (K.LT.LK) GO TO 200
C
C                       PROTECT AGAINST AN OVERFLOW
  600 DFDUB = BIG
C
C     ..................................................................
C
C     COMPUTE A BOUND (YDPB) ON THE NORM OF THE SECOND DERIVATIVE
C
  620 YDPB = DFDXB + DFDUB*FBND
C
C     ..................................................................
C
C     COMPUTE A STARTING STEP SIZE BASED ON THE ABOVE FIRST AND SECOND
C     DERIVATIVE INFORMATION
C
C                       RESTRICT THE STEP LENGTH TO BE NOT BIGGER THAN
C                       ABS(B-A).   (UNLESS  B  IS TOO CLOSE TO  A)
      H = ABSDX
C
      IF (YDPB.NE.0.D0 .OR. FBND.NE.0.D0) GO TO 640
C
C                       BOTH FIRST DERIVATIVE TERM (FBND) AND SECOND
C                                    DERIVATIVE TERM (YDPB) ARE ZERO
      GO TO 680
C
  640 IF (YDPB.NE.0.D0) GO TO 660
C
C                       ONLY SECOND DERIVATIVE TERM (YDPB) IS ZERO
      IF (1.0D0.LT.FBND*ABSDX) H = 1.D0/FBND
      GO TO 680
C
C                       SECOND DERIVATIVE TERM (YDPB) IS NON-ZERO
  660 SRYDPB = SQRT(0.5D0*YDPB)
      IF (1.0D0.LT.SRYDPB*ABSDX) H = 1.D0/SRYDPB
C
C                       FURTHER RESTRICT THE STEP LENGTH TO BE NOT
C                                                 BIGGER THAN  1/DFDUB
  680 IF (H*DFDUB.GT.1.D0) H = 1.D0/DFDUB
C
C                       FINALLY, RESTRICT THE STEP LENGTH TO BE NOT
C                       SMALLER THAN  100*SMALL*ABS(A).  HOWEVER, IF
C                       A=0. AND THE COMPUTED H UNDERFLOWED TO ZERO,
C                       THE ALGORITHM RETURNS  SMALL*ABS(B)  FOR THE
C                                                       STEP LENGTH.
      H = MAX(H,100.D0*SMALL*ABS(A))
      IF (H.EQ.0.D0) H = SMALL*ABS(B)
C
C                       NOW SET DIRECTION OF INTEGRATION
      H = SIGN(H,DX)
C
      RETURN
C
C
C     END OF D02QFP (HSTART)
C
C
      END
