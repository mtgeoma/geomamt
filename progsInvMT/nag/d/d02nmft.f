      SUBROUTINE D02NMF(NEQ,NEQMAX,T,TOUT,Y,YDOTI,RWORK,RTOL,ATOL,ITOL,
     *                  INFORM,YSAVE,NY2DIM,WKJAC,NWKJAC,JACPVT,NJCPVT,
     *                  IMON,INLN,IRES,IREVCM,ITASK,JTRACE,IFAIL)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C     MARK 14C REVISED. IER-874 (NOV 1990).
C     MARK 16A REVISED. IER-974 (JUN 1993).
C-----------------------------------------------------------------------
C THE FOLLOWING INTERNAL COMMON BLOCKS ARE DEFINED AS FOLLOWS;
C     AD02NM CONTAINS TRACE LEVEL AND CHANNEL FOR DEBUGGING
C     BD02NM CONTAINS THE INTEGRATION STATISTICS PARAMETERS SUCH
C            NUMBER OF JACOBIAN EVALUATIONS AND STEPS. THE PARAMETER
C            NINTER CONTAINS THE EFFECTIVE SIZE OF THE MEMORY ARRAY
C            YH(NEQMAX,NINTER) IF INTERPOLATION IS TO BE USED ON IT.
C     DD02NM CONTAINS THE VARIABLES USED IN THE TIME MANAGEMENT
C            SCHEME AND THE WORKSPACE POINTERS.
C     ED02NM CONTAINS THE COMMUNICATION POINTERS USED IN REVERSE
C            COMMUNICATION BETWEEN THE TIME MANAGEMENT SCHEME AND
C            THE MODULES CALLED BY IT.
C     FD02NM CONTAINS THE IFIP TRANSPORTABLE NUMERICAL SOFTWARE
C            PARAMETERS WHICH ARE INITIALISED IN THE BLOCK DATA .
C     GD02NM CONTAINS INFORMATION USED BY THE NONLINEAR EQUATIONS
C            SOLVER CAN BE USED BY THE STEP MODULE TO IMPLEMENT
C            A DAMPED NEWTON METHOD  OR TO GOVERN THE NUMBER OF
C            ITERATIONS PERFORMED.
C     HD02NM PASSES THE TYPE OF NORM TO BE USED TO THE FUNCTION D02ZAF.
C   IMPORTANT
C   ---------
C      THE RESIDUAL, STEP, NONLINEAR EQUATIONS AND LINEAR ALGEBRA
C   MODULES ALL COMMUNICATE BY USING REVERSE COMMUNICATION THROUGH
C   THE TIME MANAGEMENT SCHEME IN D02NMF. ACCESS TO THESE MODULES IS
C   ONLY THROUGH THE PARAMETER LIST USED IN D02NMF. INTERNAL
C   COMMUNICATION BETWEEN THE GROUPS OF ROUTINES WHICH MAKE UP A
C   MODULE IS BY COMMON BLOCKS. FOR EXAMPLE THERE ARE THREE ROUTINES
C   IN THE B.D.F./ ADAMS METHOD TIME INTEGRATION MODULE :BDFSET, D02NMX
C   AND D02XJY. INTERCOMMUNICATION BETWEEN THESE ROUTINES IS VIA COMMON
C   BLOCKS.
C-----------------------------------------------------------------------
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D02NMF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  T, TOUT
      INTEGER           IFAIL, IMON, INLN, IRES, IREVCM, ITASK, ITOL,
     *                  JTRACE, NEQ, NEQMAX, NJCPVT, NWKJAC, NY2DIM
C     .. Array Arguments ..
      DOUBLE PRECISION  ATOL(*), RTOL(*), RWORK(4*NEQMAX+50),
     *                  WKJAC(NWKJAC), Y(NEQMAX), YDOTI(NEQMAX),
     *                  YSAVE(NEQMAX,NY2DIM)
      INTEGER           INFORM(23), JACPVT(NJCPVT)
C     .. Scalars in Common ..
      DOUBLE PRECISION  ATOLI, BIG, BIGBIG, CRATE, DAMP, DSQU, DUNFLO,
     *                  EL0, ELC, ELS, EWTI, H, H0, HMAX, HMIN, HMXI,
     *                  HMXSTT, HNEXT, HOLD, HU, QTYMIN, RH, RJNORM,
     *                  ROOTN, RTOLI, SIZE, TCRIT, TEM, TN, TOLSF, TP,
     *                  TS, UROUND, WB
      INTEGER           I, ICHMAX, ICRASH, IDACHK, IDACNT, IDAOLD, IDEV,
     *                  IER, IEWSET, IFJ, IFLAG, IFN, IFUNC, IMXER,
     *                  INIT, INITL, INORM, IODE, IOVFLO, IRETUR, ISAVE,
     *                  ISTEP, ITRACE, J, KCUR, KGO, LACOR, LDAE, LENRW,
     *                  LEWT, LSAVR, MAXIT, MXHNIL, MXHNL0, MXSTEP,
     *                  MXSTP0, N, NHNIL, NINTER, NITER, NJE, NOLD, NQ,
     *                  NQU, NRE, NSLAST, NST
      LOGICAL           CRIT1, CRIT2, IHIT, NT1STP
C     .. Local Scalars ..
      INTEGER           IERT, IFZAF, MJCPVT, MWKJAC, MY2DIM
      LOGICAL           FAILED, INCICH, SUCCES
      CHARACTER*200     ERRMSG
C     .. Local Arrays ..
      DOUBLE PRECISION  AARG(1)
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  D02ZAF, X02AJF, X02ALF, X02AMF
      INTEGER           P01ABF
      EXTERNAL          D02ZAF, X02AJF, X02ALF, X02AMF, P01ABF
C     .. External Subroutines ..
      EXTERNAL          D02MVY, D02MWX, D02NMM, D02NMN, D02NMQ, D02NMS,
     *                  D02NMU, D02NMV, D02NMX, D02NMZ, D02NNN, D02NNQ,
     *                  D02NNV, D02NNW, D02NNX, D02XJY, X04ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, DBLE, INT, MAX, MIN, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /AD02NM/ITRACE, IDEV
      COMMON            /BD02NM/HOLD, NQ, NQU, NST, NRE, NJE, NITER,
     *                  NINTER, KCUR
      COMMON            /CD02NM/HMXSTT
      COMMON            /DD02NM/H, EL0, TN, HU, HMIN, HMXI, DSQU, ELS,
     *                  WB, ELC, TS, INIT, LEWT, LACOR, LSAVR, LDAE,
     *                  MXSTEP, MXHNIL, NHNIL, NSLAST
      COMMON            /ED02NM/IFUNC, ISTEP, IER, IEWSET, IRETUR,
     *                  IDACNT, IDAOLD, INITL, IODE, ICRASH, IFN, IDACHK
      COMMON            /FD02NM/DUNFLO, UROUND, IOVFLO
      COMMON            /GD02NM/DAMP, RJNORM, CRATE, MAXIT
      COMMON            /HD02NM/INORM
      COMMON            /JD02NM/BIGBIG, QTYMIN, ROOTN
      COMMON            /KD02NM/IHIT
      COMMON            /LD02NM/ATOLI, BIG, EWTI, H0, RH, RTOLI, SIZE,
     *                  TCRIT, TEM, HNEXT, TOLSF, TP, HMAX, I, IFJ,
     *                  IFLAG, ICHMAX, IMXER, J, KGO, LENRW, MXHNL0,
     *                  MXSTP0, N, ISAVE, NOLD, CRIT1, CRIT2, NT1STP
C     .. Save statement ..
      SAVE              /BD02NM/, /DD02NM/, /ED02NM/, /FD02NM/,
     *                  /GD02NM/, /HD02NM/, /LD02NM/, /KD02NM/,
     *                  /JD02NM/, /AD02NM/, /CD02NM/
C     .. Executable Statements ..
C-----------------------------------------------------------------------
C BLOCK A.
C THIS CODE BLOCK IS EXECUTED ON EVERY CALL.
C IT TESTS ISTATE AND ITASK FOR LEGALITY AND BRANCHES APPROPIATELY.
C IF ISTATE .GT. 1 BUT THE FLAG INIT SHOWS THAT INITIALIZATION HAS
C NOT YET BEEN DONE, AN ERROR RETURN OCCURS.
C IF ISTATE = 0 OR 1 AND TOUT = T RETURN IMMEDIATELY.
C-----------------------------------------------------------------------
C
C  COPY THE CONTROL PARAMETERS FROM THE INFORM ARRAY
C
      GO TO (420,2320,960,1060,1680,2320,2320,1040,20,
     *       80) IREVCM
      GO TO 140
   20 CONTINUE
      GO TO (1260,1260,1260,80,1260,40,60) IMON + 3
      GO TO 1260
   40 CONTINUE
      H = RWORK(16)
   60 CONTINUE
      HMIN = RWORK(17)
      HMAX = RWORK(18)
   80 CONTINUE
      IF (ITASK.NE.4 .AND. ITASK.NE.5) GO TO 120
      FAILED = IREVCM .EQ. 10
      SUCCES = IREVCM .EQ. 9
      IHIT = .FALSE.
  100 CONTINUE
      IF ( .NOT. CRIT1 .AND. .NOT. CRIT2) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            ISTEP = 3
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) THEN
               H = 0.5D0*(TCRIT-TN)
               ISTEP = 3
            END IF
         END IF
      ELSE IF (CRIT1 .AND. SUCCES) THEN
         CRIT1 = .FALSE.
         CRIT2 = .FALSE.
         IHIT = .TRUE.
      ELSE IF (CRIT1 .AND. FAILED) THEN
         IF (KCUR.NE.0) THEN
            CRIT1 = .FALSE.
            GO TO 100
         ELSE
            KCUR = 1
         END IF
      ELSE IF (CRIT2 .AND. FAILED) THEN
         IF (KCUR.NE.0) THEN
            CRIT2 = .FALSE.
            GO TO 100
         ELSE
            KCUR = 1
         END IF
      ELSE IF (CRIT2 .AND. SUCCES) THEN
         IF (ABS(H).GE.ABS(HU)) THEN
            CRIT2 = .FALSE.
            CRIT1 = .TRUE.
            H = HU
            ISTEP = 3
         ELSE
            CRIT1 = .FALSE.
            CRIT2 = .FALSE.
            GO TO 100
         END IF
      END IF
  120 CONTINUE
      GO TO (1260,820) IREVCM - 8
C
  140 CONTINUE
      NT1STP = ITASK .NE. 2 .AND. ITASK .NE. 5
C
      ISAVE = 0
      ITRACE = JTRACE
      CALL X04ABF(0,IDEV)
C
      IF (RWORK(49).EQ.1.0D0) THEN
         INORM = 1
      ELSE IF (RWORK(49).EQ.2.0D0) THEN
         INORM = 2
      ELSE
         GO TO 2260
      END IF
      IF (RWORK(40).LT.0.0D0 .OR. RWORK(40).GT.1.0D0) GO TO 2260
      IF (ITASK.LT.1 .OR. ITASK.GT.5) GO TO 1860
      IF (RWORK(40).EQ.0.0D0) GO TO 160
      IF (INIT.EQ.0) GO TO 1880
      IF (RWORK(40).EQ.1.0D0 .AND. RWORK(8).EQ.1.0D0) GO TO 620
      GO TO 180
  160 CONTINUE
      INIT = 0
      IF (TOUT.EQ.T) GO TO 2120
C                            ABORT THE RUN
  180 CONTINUE
C-----------------------------------------------------------------------
C BLOCK B.
C THE NEXT CODE BLOCK IS EXECUTED FOR THE INITIAL CALL (ISTATE = 0     )
C OR FOR A CONTINUATION CALL WITH PARAMETER CHANGES (ISTATE = 2).
C IT CONTAINS CHECKING OF ALL INPUTS AND VARIOUS INITIALIZATIONS.
C
C FIRST CHECK LEGALITY OF THE NON-OPTIONAL INPUTS NEQ, ITOL         .
C-----------------------------------------------------------------------
      IF (NEQ.LE.0) GO TO 1900
      IF (RWORK(40).EQ.0.0D0) NOLD = NEQ
      IF (NEQ.GT.NEQMAX) GO TO 1920
  200 CONTINUE
      N = NEQ
      ROOTN = SQRT(DBLE(N))
      BIGBIG = X02ALF()
      UROUND = X02AJF()
      DUNFLO = X02AMF()
      QTYMIN = SQRT(DUNFLO)
      IF (ITOL.LT.1 .OR. ITOL.GT.4) GO TO 1940
  220 CONTINUE
      ICRASH = 0
C ICRASH COUNTS THE NUMBER OF STEP ERROR TEST OR CONVERGENCE FAILURES---
C NEXT PROCESS AND CHECK THE OPTIONAL INPUTS. --------------------------
  240 CONTINUE
      MXSTEP = INT(RWORK(2))
      IF (MXSTEP.LT.0) GO TO 1960
      MXHNIL = INT(RWORK(3))
      IF (MXHNIL.LT.0) GO TO 1980
      IF (MXHNIL.EQ.0) MXHNIL = 10
      IF (RWORK(40).EQ.1.0D0) GO TO 260
      H0 = RWORK(5)
      IF ((TOUT-T)*H0.LT.0.0D0) GO TO 2000
  260 CONTINUE
      HMAX = RWORK(6)
      IF (HMAX.LT.0.0D0) GO TO 2020
      HMXI = 0.0D0
      IF (HMAX.GT.0.0D0) HMXI = 1.0D0/HMAX
      IF (RWORK(40).EQ.1.0D0) GO TO 280
      ICHMAX = 0
      HMXSTT = ABS(TOUT-T)
      IF (ITASK.EQ.4) THEN
         HMXSTT = ABS(0.5D0*(RWORK(1)-T))
         IF (HMAX.GT.0.0D0) HMXSTT = MIN(HMAX,HMXSTT)
      END IF
  280 CONTINUE
      HMIN = RWORK(7)
      IF (HMIN.LT.0.0D0) GO TO 2040
C-----------------------------------------------------------------------
C SET WORK ARRAY POINTERS .
C POINTERS TO SEGMENTS OF RWORK ARE NAMED BY PREFIXING L TO
C THE NAME OF THE SEGMENT.  E.G. THE SEGMENT EWT STARTS AT RWORK(LEWT).
C SEGMENTS OF RWORK (IN ORDER) ARE DENOTED EWT, ACOR, SAVR.
C-----------------------------------------------------------------------
  300 CONTINUE
      LEWT = 51
      LACOR = LEWT + NEQMAX
      LSAVR = LACOR + NEQMAX
      LDAE = LSAVR + NEQMAX
      LENRW = LSAVR + NEQMAX - 1
C
C     CHECK NY2DIM FOR LEGALITY
C
      MY2DIM = INT(RWORK(33))
      MWKJAC = INT(RWORK(46))
      MJCPVT = INT(RWORK(47))
      IF (NY2DIM.NE.MY2DIM) GO TO 2300
      IF (NWKJAC.NE.MWKJAC) GO TO 2340
      IF (RWORK(34).NE.1.0D0 .AND. NJCPVT.NE.MJCPVT) GO TO 2360
C
C     CHECK RTOL AND ATOL FOR LEGALITY.
C
      RTOLI = RTOL(1)
      ATOLI = ATOL(1)
      DO 320 I = 1, N
C205
C205     NOT EASILY VECTORISED
C205
         IEWSET = -I
         IF (ITOL.GE.3) RTOLI = RTOL(I)
         IF (ITOL.EQ.2 .OR. ITOL.EQ.4) ATOLI = ATOL(I)
         IF (RTOLI.LT.0.0D0) GO TO 2060
         IF (ATOLI.LT.0.0D0) GO TO 2080
         IEWSET = 0
  320 CONTINUE
      DSQU = SQRT(UROUND)
      IF (RWORK(40).EQ.0.0D0) GO TO 340
C
C IF ISTATE = 3, SET FLAG TO SIGNAL PARAMETER CHANGES TO STEP MODULE.---
C
      GO TO 620
C-----------------------------------------------------------------------
C BLOCK C.    INITIALISATION BLOCK
C THE NEXT BLOCK IS FOR THE INITIAL CALL ONLY (ISTATE = 0 OR 1) OR FOR
C A RESTART FORCED BY THE MONITOR ROUTINE. IN THE LATTER CASE THE ENTRY
C POINT TO THIS BLOCK IS AT THE POINT INDICATED.
C IT CONTAINS ALL REMAINING INITIALIZATIONS AND CALLS TO THE NONLINEAR
C SOLVER AND THE CALCULATION OF THE INITIAL STEP SIZE.
C THE ERROR WEIGHTS IN EWT ARE INVERTED AFTER BEING LOADED.
C-----------------------------------------------------------------------
  340 CONTINUE
      TN = T
      IHIT = .FALSE.
      HU = 0.0D0
CMKM
C  NEW BLOCK OF CODE HERE  WITH TWO NEW LINES AND SOME RESTRUCTURING.
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         TCRIT = RWORK(1)
         IF ((TCRIT-TOUT)*(TOUT-T).LT.0.0D0) GO TO 2180
         IF (H0.NE.0.0D0 .AND. (T+H0-TCRIT)*H0.GT.0.0D0) H0 = TCRIT - T
         HMAX = MAX(ABS(TCRIT-T),UROUND)
         HMXI = MAX(1.0D0/HMAX,HMXI)
      END IF
CMKM
  360 CONTINUE
      ISTEP = -1
      NHNIL = 0
      NST = 0
      IFN = 0
      NRE = 1
      NJE = 0
      NSLAST = 0
      HU = 0.0D0
      NQU = 0
      NITER = 0
      IF (RWORK(40).EQ.0.0D0) THEN
C        SET YDOTI TO 0 TO PREVENT UNDEFINED REFERENCES
         DO 380 I = 1, N
            YDOTI(I) = 0.0D0
  380    CONTINUE
      END IF
      INITL = 1
      H = H0
C-----------------------------------------------------------------------
C          CHECK IF THE USER OVERWRITES Y             IN  FCN.
C----------------------------------------------------------------------
      DO 400 I = 1, N
         YSAVE(I,1) = Y(I)
         RWORK(LACOR+I-1) = 0.0D0
  400 CONTINUE
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 2100
      IRES = 1
C
C     CALL RESID(NEQ,TN,Y,RWORK(LACOR),RWORK(LSAVR),IRES,WKRES,NWKRES)
C
      IREVCM = 1
      GO TO 1780
  420 CONTINUE
      DO 440 I = 1, N
         RWORK(LACOR+I-1) = ABS(YSAVE(I,1)-Y(I))
  440 CONTINUE
      IFZAF = 1
      TEM = D02ZAF(NEQ,RWORK(LACOR),RWORK(LEWT),IFZAF)
      IF (TEM.GE.UROUND) THEN
         CALL D02NNQ(
     *' THE  ROUTINE WHICH EVALUATES THE FUNCTIONS IN THE
     * EQUATIONS APPEARS TO OVERWRITE THE SOLUTION VECTOR WHEN
     * CALLED. INTEGRATION WILL NOT BE ATTEMPTED .',1,0,0,0,0,0.0D0,
     *               0.0D0)
         DO 460 I = 1, N
            Y(I) = YSAVE(I,1)
  460    CONTINUE
         GO TO 2400
      END IF
      IF (IRES.NE.1) THEN
         IF (IRES.EQ.2) THEN
            IERT = 1
         ELSE
            IERT = 2
         END IF
         CALL D02NNQ(
     *' THE ROUTINE WHICH EVALUATES THE FUNCTIONS IN THE
     *  EQUATION SETS IRES TO (=I1) WHEN
     *  CALLED FOR TESTING WITH IRES = -1
     *  AT TIME  T  (= R1) . INTEGRATION
     *  WILL CONTINUE UNLESS IRES = 2 ',IERT,1,IRES,0,1,TN,0.0D0)
         IF (IRES.EQ.2) THEN
            ISAVE = 11
            GO TO 2420
         END IF
      END IF
C-----------------------------------------------------------------------
C ENTRY TO BLOCK FOR A RESTART FORCED BY THE MONITOR ROUTINE
C-----------------------------------------------------------------------
  480 CONTINUE
      NQ = 1
      EL0 = 1.0D0
C-----------------------------------------------------------------------
C LOAD AND INVERT THE EWT ARRAY AND THEN CALL THE INITIALISATION MODULE
C----------------------------------------------------------------------
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 2100
      INLN = 0
      CALL D02NNW(NEQ,TN,TOUT,H,Y,YDOTI,RWORK(LEWT),RTOL,ATOL,ITOL)
C
C        ERROR RETURN FOR INITIAL STEP UNOBTAINABLE
      IF (H.EQ.0.0D0) GO TO 2400
C
      RH = ABS(H)*HMXI*100
      IF (RH.GT.1.0D0) H = H/RH
      IF (INITL.EQ.1) THEN
         TEM = DSQU*100.0D0
CMKM THIS IS IN THE DZ2NNF CODE. WHAT SHOULD RICHARD DO ABOUT IT?
C        TEM = 0.315D-5
CMKM
         H = MIN(ABS(H),TEM)*SIGN(1.0D0,H)
      END IF
      RH = HMIN/ABS(H)
      IF (RH.GT.1.0D0) H = H*RH
      IRETUR = 1
      INLN = 3
      GO TO 860
C        EXIT TO NONLINEAR SOLVER FOR A FCN EVALUATION
  500 CONTINUE
      DO 520 I = 1, N
         YDOTI(I) = RWORK(LSAVR+I-1)
  520 CONTINUE
      DO 540 I = 1, N
         RWORK(LDAE-1+I) = 1.0D0
  540 CONTINUE
      DO 560 I = 1, N
         YSAVE(I,2) = YDOTI(I)*H
  560 CONTINUE
      IF (INLN.EQ.-4) THEN
C           FCN MONITOR PATH
         IMON = -2
         GO TO 1240
      ELSE IF (INLN.EQ.-2 .OR. INLN.EQ.-3) THEN
C           FCN RETURNED ERROR
         ISTEP = INLN - 1
         GO TO 1200
      END IF
      MAXIT = 3
      DAMP = 1.0D0
      HU = H
      IF (ITASK.EQ.6) THEN
C         RETURN TO THE CALLING PROGRAM WITH CALCULATED INITIAL VALUES.
         T = TN
         TOUT = TN
         RWORK(40) = 1.0D0
         GO TO 1760
      END IF
  580 CONTINUE
      CALL D02NNW(NEQ,TN,TOUT,H0,Y,YDOTI,RWORK(LEWT),RTOL,ATOL,ITOL)
C          TO COMPUTE THE INITIAL STEPSIZE H0 , ADJUST IT ON
C          RETURN TO MEET HMAX BOUND AND LOAD H0 INTO H.
C
CMKM 5 NEW LINES AND LABEL 600 SHIFTED UP
  600 CONTINUE
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         HMAX = MAX(ABS(TCRIT-TN),UROUND)
         HMXI = MAX(1/HMAX,HMXI)
      END IF
CMKM
      RH = ABS(H0)*HMXI
      H = H0
      IF (RH.GT.1.0D0) H = H0/RH
      IF (ABS(H).LT.HMIN) H = HMIN*SIGN(1.0D0,H0)
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            CRIT2 = .FALSE.
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) H = 0.5D0*(TCRIT-TN)
         END IF
      END IF
      IF (ITRACE.GE.1) THEN
         AARG(1) = H
         CALL D02NNN(AARG,1,1)
      END IF
      H0 = 0.0D0
      INITL = 1
CMKM TWO NEW LINES INC POSS JUMP
C    CHECK TO SEE IF OUTPUT POINT HAS BEEN PASSED IN INITIALISATION.
      IF ((TN-TOUT)*H.GE.0.0D0) GO TO 620
CMKM
      GO TO 760
C-----------------------------------------------------------------------
C BLOCK D.
C THE NEXT CODE BLOCK IS FOR CONTINUATION CALLS ONLY (ISTATE = 2 OR 3)
C AND IS TO CHECK STOP CONDITIONS BEFORE TAKING A STEP.
C-----------------------------------------------------------------------
  620 CONTINUE
      NSLAST = NST
      IHIT = .FALSE.
      GO TO (640,740,660,680,700) ITASK
  640 CONTINUE
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 740
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      IF (IFLAG.NE.0) GO TO 2220
      T = TOUT
      GO TO 1460
  660 CONTINUE
      TP = TN - HU*(1.0D0+100.0D0*UROUND)
      IF ((TP-TOUT)*H.GT.0.0D0) GO TO 2140
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 740
      T = TN
      GO TO 1420
  680 CONTINUE
      TCRIT = RWORK(1)
      IF ((TN-TCRIT)*H.GT.0.0D0) GO TO 2160
      IF ((TCRIT-TOUT)*H.LT.0.0D0) GO TO 2180
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 720
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      IF (IFLAG.NE.0) GO TO 2220
      T = TOUT
      GO TO 1460
  700 CONTINUE
      TCRIT = RWORK(1)
      IF ((TN-TCRIT)*H.GT.0.0D0) GO TO 2160
  720 CONTINUE
      IF ( .NOT. CRIT1 .AND. .NOT. CRIT2) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            ISTEP = 3
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) THEN
               H = 0.5D0*(TCRIT-TN)
               ISTEP = 3
            END IF
         END IF
      END IF
      IF (IHIT) GO TO 1400
C-----------------------------------------------------------------------
C BLOCK E.
C THE NEXT BLOCK IS NORMALLY EXECUTED FOR ALL CALLS AND CONTAINS
C THE CALL TO THE STEP CORE INTEGRATOR.
C
C THIS IS A LOOPING POINT FOR THE INTEGRATION STEPS.
C
C FIRST CHECK FOR TOO MANY STEPS BEING TAKEN, UPDATE EWT (IF NOT AT
C START OF PROBLEM), CHECK FOR TOO MUCH ACCURACY BEING REQUESTED, AND
C CHECK FOR H BELOW THE ROUNDOFF LEVEL IN T.
C-----------------------------------------------------------------------
  740 CONTINUE
      IF (RWORK(8).EQ.2.0D0) THEN
         HNEXT = RWORK(9)
         IF (HNEXT.NE.0.0D0 .AND. HNEXT.NE.ABS(H)) THEN
            IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
               IF (CRIT1 .AND. ABS(H).GT.HNEXT) THEN
                  CRIT1 = .FALSE.
                  H = SIGN(1.0D0,H)*HNEXT
               ELSE
                  CRIT1 = .FALSE.
                  CRIT2 = .FALSE.
                  IF (HNEXT.GT.ABS(TCRIT-TN)) CRIT1 = .TRUE.
                  H = SIGN(1.0D0,H)*MIN(HNEXT,ABS(TCRIT-TN))
               END IF
            ELSE
               H = SIGN(1.0D0,H)*HNEXT
            END IF
            ISTEP = 3
         END IF
         RWORK(8) = 1.0D0
      END IF
      IF (RWORK(40).EQ.1.0D0 .AND. N.NE.NOLD) ISTEP = 2
      NOLD = N
      IF ((NST-NSLAST).GE.MXSTEP .AND. MXSTEP.GT.0) GO TO 1520
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 1540
  760 CONTINUE
      IFZAF = 1
      TOLSF = UROUND*D02ZAF(N,Y,RWORK(LEWT),IFZAF)
      IF (TOLSF.LE.1.0D0) GO TO 780
      TOLSF = TOLSF*2.0D0
      IF (NST.EQ.0) GO TO 2200
      GO TO 1560
  780 CONTINUE
      IF ((TN+H).NE.TN) GO TO 800
      NHNIL = NHNIL + 1
      IF (NHNIL.GT.MXHNIL) GO TO 800
      CALL D02NNQ(
     *' WARNING... THE TIME T (=R1) AND THE STEPSIZE H (=R2) ARE
     *  SUCH THAT T + H = T ON THE NEXT STEP - SOLVER WILL
     *  CONTINUE. ',2,0,0,0,2,TN,H)
      IF (NHNIL.LT.MXHNIL) GO TO 800
      CALL D02NNQ(
     *' ABOVE WARNING HAS NOW BEEN ISSUED I1 TIMES
     *  AND WILL NOT BE USED AGAIN. ',2,1,MXHNIL,0,0,0.0D0,0.0D0)
  800 CONTINUE
      INLN = 0
      TS = TN
  820 CONTINUE
      IF (RWORK(21).EQ.1.0D0) THEN
         CALL D02NMX(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
      ELSE IF (RWORK(21).EQ.2.0D0) THEN
         CALL D02NMZ(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
CMKM
C  NEXT 8 LINES ARE ADDITION BY M.B.
      ELSE IF (RWORK(21).EQ.3.0D0) THEN
         CALL D02MWX(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
      ELSE IF (RWORK(21).EQ.4.0D0) THEN
         CALL D02MVY(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
CMKM
      ELSE
         GO TO 2260
      END IF
C
      IF (IREVCM.EQ.10) GO TO 1780
C
      IRETUR = 0
      IF (INLN.GT.0) THEN
C        REVERSE COMMUNICATIONS CALL TO NLSLVR IN PROGRESS SET THE
C        RETURN FLAG AND CALL THE SOLVER.
         IRETUR = 2
         GO TO 860
      ELSE
C        FIND THE LARGEST LOCAL ERROR COMPONENT
         BIG = 0.0D0
C205
C205     REPLACE THE FOLLOWING BLOCK OF CODE WITH SOMETHING LIKE:
C205     ASSIGN TEMP1(1),.DYN.N
C205     TEMP1(1) = VABS ( RWORK(LACOR;N), TEMP1(1) )
C205     TEMP1(1) = TEMP(1) * RWORK(LEWT;N)
C205     IMXER = Q8SMAXI(TEMP1) + 1
C205     FREE
C205
         DO 840 I = 1, N
            SIZE = ABS(RWORK(I+LACOR-1)*RWORK(LEWT+I-1))
            IF (BIG.LE.SIZE) THEN
               BIG = SIZE
               IMXER = I
            END IF
  840    CONTINUE
         GO TO 1200
      END IF
C-----------------------------------------------------------------------
C BLOCK F
C ------- CALL TO NONLINEAR EQUATIONS SOLVER PART OF PACKAGE
C         **************************************************
C
C         INLN = 1   SOLVE THE NONLINEAR SYSTEM OF EQUATIONS
C                    AFTER FORMING A NEW JACOBIAN MATRIX.
C         INLN = 2   AS FOR INLN = 1 BUT USING THE OLD JACOBIAN.
C         INLN = 3   FORM THE RESIDUAL OF THE D.A.E. STARTING
C                    THE VALUES AT RWORK(LSAVR).
C         INLN = 4   PERFORM ONE BACKSUBSTITUTION ONLY ON THE VECTOR
C                    WHICH STARTS AT RWORK(LSAVR) USING THE ALREADY
C                    FACTORED JACOBIAN MATRIX .
C         INLN = 5   PETZOLD LOCAL ERROR ESTIMATE- PREMULTIPLY
C                    USUAL LOCAL ERROR ESTIMATE BY DF/DYDOT AND THEN
C                    BY THE INVERSE OF THE JACOBIAN.
C         INLN = 6   SOLVE THE NONLINEAR SYSTEM OF EQUATIONS USING
C                    FUNCTIONAL ITERATION.
C         INLN = 7   SOLVE FOR THE INITIAL VALUES OF THE ALGEBRAIC EQNS
C                    AND FOR THE INITIAL DERIVATIVES USING FUNCTIONAL
C                    ITERATION . THIS ASSUMES THAT BOTH THE ALGEBRAIC
C                    AND DIFFERENTIAL PARTS ARE WRITTEN IN NORMAL FORM.
C-----------------------------------------------------------------------
  860 CONTINUE
      IDACHK = 0
      IF (INLN.GE.3 .AND. INLN.LE.5) THEN
C         AVOID THE CALL TO NLSLVR
         IFUNC = INLN
         IF (IFUNC.EQ.4) GO TO 1120
         GO TO 900
      END IF
  880 CONTINUE
      CALL D02NMV(NEQ,Y,YDOTI,YSAVE,NEQMAX,RWORK(LSAVR),RWORK(LACOR),
     *            RWORK(LEWT),IFUNC,INLN,H,EL0,RWORK(LDAE))
C
C          IF IFUNC = 0 RETURN TO CALLING POINT AS SOLVER HAS FINISHED
C
      IF (IFUNC.EQ.0) GO TO 1180
  900 CONTINUE
      DO 920 I = 1, N
         RWORK(LSAVR+I-1) = 0.0D0
  920 CONTINUE
      IF (IFUNC.EQ.5) THEN
C205
C205     REPLACE THE FOLLOWING LOOP WITH
C205     RWORK(LSAVR;N) = -RWORK(LACOR;N)
C205
         DO 940 I = 1, N
            RWORK(LSAVR+I-1) = -RWORK(LACOR+I-1)
  940    CONTINUE
         IRES = -1
         GO TO 1000
      END IF
C     ORDINARY FCN EVALUATION TO PUT SAVR TO WHAT IT SHOULD BE
      IRES = 1
      IREVCM = 3
      GO TO 1780
  960 CONTINUE
      DO 980 I = 1, N
         RWORK(LSAVR+I-1) = RWORK(LSAVR+I-1) - YDOTI(I)
  980 CONTINUE
 1000 CONTINUE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      NRE = NRE + 1
      I = IRES*IRES
      IF (I.NE.1) GO TO 1160
      GO TO (1020,1120,1180,880,1120,880,880) IFUNC
C
C                                  JACOBIAN EVALUATION
 1020 CONTINUE
      IFJ = 0
      NJE = NJE + 1
      ELS = H*EL0
 1040 CONTINUE
      IF (RWORK(34).EQ.1.0D0) THEN
         CALL D02NMU(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE IF (RWORK(34).EQ.2.0D0) THEN
         CALL D02NMS(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE IF (RWORK(34).EQ.3.0D0) THEN
         CALL D02NMM(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE
         GO TO 2280
      END IF
C
      IF (IREVCM.EQ.8) GO TO 1780
C     USER SUPPLIED ROUTINE BEING USED TO FORM JACOBIAN
      IF (IFJ.EQ.0) GO TO 1100
      IF (IFJ.EQ.-1) THEN
         INLN = -1
         GO TO 1180
      ELSE IF (IFJ.EQ.-2) THEN
         INLN = -5
         GO TO 1180
      END IF
C     DIFFERENCING IS BEING USED TO FORM JACOBIAN
      IRES = 1
      IREVCM = 4
      GO TO 1780
 1060 CONTINUE
      DO 1080 I = 1, N
         RWORK(LACOR+I-1) = RWORK(LACOR+I-1) - YDOTI(I)
 1080 CONTINUE
      NRE = NRE + 1
      I = IRES*IRES
      IF (I.NE.1) GO TO 1160
      GO TO 1040
 1100 CONTINUE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      BACKSUBSTITUTION FOLLOWED BY A RETURN TO NLSLVR
 1120 CONTINUE
      NITER = NITER + 1
C      SCALE THE RESIDUAL VECTOR BY THE RELAX FACTOR
      ELC = EL0*H
      WB = ELC*ELS*2.0D0/(ELC+ELS) - 1
C205
C205   REPLACE THE FOLLOWING LOOP WITH SOMETHING LIKE:
C205   ASSIGN TEMP1(1),.DYN.N
C205   TEMP1(1) = RWORK(LDAE;N)*WB + 1.0
C205   RWORK(LSAVR;N) = RWORK(LSAVR;N) * TEMP1(1)
C205
      DO 1140 I = 1, N
         RWORK(LSAVR+I-1) = RWORK(LSAVR+I-1)*(RWORK(LDAE-1+I)*WB+1.0D0)
 1140 CONTINUE
      J = 0
      IF (RWORK(34).EQ.1.0D0) THEN
         CALL D02NMQ(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE IF (RWORK(34).EQ.2.0D0) THEN
         CALL D02NMN(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE IF (RWORK(34).EQ.3.0D0) THEN
         CALL D02NNV(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE
         GO TO 2280
      END IF
CMKM MAJOR CHANGE NEXT THREE LINES COMMENTED OUT.... DO 1160 LOOP GONE
C       AND NOW RESCALE THE RESULT
C     DO 1160 I = 1, N
C        RWORK(LSAVR+I-1) = RWORK(LSAVR+I-1)/ELC
C1160 CONTINUE
CMKM
      IF (J.NE.0) INLN = -5
      IF (INLN.EQ.0) GO TO 880
      GO TO 1180
C
C      ERROR IN FCN FORMATION
 1160 CONTINUE
      INLN = -IRES
      IF ((IRES.GT.4) .OR. (IRES.EQ.0) .OR. (IRES.LT.-2)) THEN
         ERRMSG =
     *' THE ROUTINE TO EVALUATE THE FUNCTIONS IN THE EQUATIONS
     * HAS  ILLEGALLY SET IRES (=I1) . IRES HAS BEEN RESET TO 3
     * TO TRY AND CONTINUE THE INTEGRATION '
         CALL D02NNQ(ERRMSG,2,1,IRES,0,0,0.0D0,0.0D0)
         IRES = 3
         INLN = -3
      END IF
C
C      RETURN TO THE PROGRAM SEGMENT WHICH CALLED THE SOLVER
 1180 CONTINUE
      IFUNC = 0
      GO TO (500,820,1240) IRETUR
C
C-----------------------------------------------------------------------
C BLOCK G
C           EXIT FROM THE STEP MODULE- CHECK IF MONITR IS TO BE CALLED
C-----------------------------------------------------------------------
 1200 CONTINUE
      IF (IRES.EQ.4) THEN
         IMON = -2
         GO TO 1240
      ELSE IF (ISTEP.EQ.-1 .OR. ISTEP.EQ.-2) THEN
         IMON = -1
      END IF
      KGO = 2 - ISTEP
      GO TO (1220,860,1240,1240,1420,1580,1580,2400,2380) KGO
C             1    2    3    4    5    6    7    8    9
C
C KGO = 1,SUCCESS.   2, CALL TO NLSLVR.  3,ERROR TEST FAILURE.
C       4, CONVERGENCE FAILURE.          5,RES ORDERED RETURN.
C       6,RES RETURNED ERROR.      7,SINGULAR JACOBIAN MATRIX.
C       8,NO CALL TO INIT MODULE.     9,IMPOSS ERR IN LIN ALG.
 1220 CONTINUE
      INIT = 1
      HU = HOLD
      IF ((ITASK.EQ.4 .OR. ITASK.EQ.5) .AND. CRIT1) TN = TCRIT
      NST = NST + 1
      INCICH = NT1STP .AND. (ABS(HU).EQ.HMAX .OR. NST.LT.3 .AND. ABS(HU)
     *         .EQ.HMXSTT)
      IF (INCICH) ICHMAX = ICHMAX + 1
      IMON = 1
 1240 CONTINUE
      IREVCM = 9
      GO TO 1780
 1260 CONTINUE
      IF (HMAX.LT.0.0D0) THEN
         GO TO 2020
      ELSE
         HMXI = 0.0D0
         IF (HMAX.GT.0.0D0) HMXI = 1.0D0/HMAX
      END IF
      IF (NEQ.NE.N) THEN
C        THE DIMENSION OF THE O.D.E. SYSTEM HAS CHANGED.
         IF (NEQ.GT.NEQMAX) GO TO 2240
         IF (NEQ.LT.1) GO TO 1900
         N = NEQ
         ROOTN = SQRT(DBLE(N))
      END IF
      IF (IMON.EQ.0) IRETUR = 3
      IF (IMON.EQ.2) THEN
         ISTEP = -1
         RWORK(40) = 0.0D0
         H0 = H
      END IF
      IF (IMON.EQ.3 .OR. IMON.EQ.4) THEN
         I = ISTEP
         ISTEP = IMON - 1
         IF (I.LT.0) GO TO 800
      END IF
      IF (IMON.EQ.-1 .AND. ISTEP.LT.0) IMON = -3
      I = IMON + 4
C             -3     -2   -1   0    1    2    3    4    IMON
      GO TO (1480,1420,1620,860,1280,480,1280,1280) I
C          RESTART    ERROR   NON-      RE-    NORMAL CONTINUE
C                    RETURNS  LIN SOLVER  START
      GO TO 1620
C-----------------------------------------------------------------------
C BLOCK H :HANDLES A SUCCESSFUL RETURN FROM THE CORE INTEGRATOR,ISTEP=1.
C THE TEST FOR STOP CONDITIONS IS MADE ,ON FAILURE WE JUMP TO THE
C START OF BLOCK E.
C IF THE STOP CONDITIONS ARE SATISFIED AND ITASK .NE. 1 ,Y IS LOADED
C FROM YH AND T IS SET ACCORDINGLY. THE RETURN IS MADE FROM THE SECTION
C BEGINNING WITH THE COMMENT 'EXIT POINT FOR SUCCESSFUL RUNS'
C-----------------------------------------------------------------------
 1280 CONTINUE
      IF (ITRACE.GE.1) THEN
         AARG(1) = TN
         CALL D02NNN(AARG,1,2)
      END IF
      TEM = -TOUT*10.0D0*H*UROUND
      GO TO (1300,1340,1320,1360,1380) ITASK
C
C          ITASK = 1. IF TOUT HAS BEEN REACHED, INTERPOLATE.
C
 1300 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) GO TO 740
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      T = TOUT
      GO TO 1460
C
C         ITASK =2,3. JUMP TO EXIT IF TOUT WAS REACHED.
C
 1320 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) GO TO 740
 1340 CONTINUE
      T = TN
      GO TO 1420
C
C          ITASK = 4. SEE IF TOUT OR TCRIT WAS REACHED AND ADJUST H.
C
 1360 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) THEN
         IF (IHIT) GO TO 1400
CMKM  THREE NEW LINES TO RESET HMAX, HMIN AND HMXI
         HMAX = MIN(ABS(TCRIT-TN),ABS(TOUT-TN))
         HMAX = MAX(HMAX,UROUND)
         HMXI = MAX(1.D0/HMAX,HMXI)
CMKM
         GO TO 740
      ELSE
         IFLAG = 0
         CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,
     *               RWORK(21))
         T = TOUT
         GO TO 1460
      END IF
C
C         ITASK = 5.  SEE IF TCRIT WAS REACHED AND JUMP TO EXIT.
C
 1380 CONTINUE
      T = TN
 1400 CONTINUE
      IF (IHIT) T = TCRIT
C        .
C A SUCCESSFUL RETURN FROM D02NMF. SET Y FROM YH AND JUMP TO THE SECTION
C BEGINNING WITH COMMENT 'EXIT POINT FOR SUCCESSFUL RUNS'
C
 1420 CONTINUE
      DO 1440 I = 1, N
         Y(I) = YSAVE(I,1)
 1440 CONTINUE
 1460 CONTINUE
      ISAVE = 0
C     IF (ISTEP.EQ.-3) ISAVE = 11
C     IF (IMON.EQ.-2) ISAVE = 12
      IF (ISTEP.EQ.-3 .OR. IMON.EQ.-2) THEN
         T = TN
         ISAVE = 11
         IF (IMON.EQ.-2) ISAVE = 12
      END IF
      GO TO 1760
C-----------------------------------------------------------------------
C  BLOCK I
C  THIS BLOCK ENTERED AFTER ERROR TEST OR CONVERGENCE FAILURES AND
C  PROVIDING THAT THE MONITR ROUTINE HAS NOT SET IMON = -2
C  ICRASH COUNTS THE FAILURES AND ALLOWS A MAXIMUM OF THREE PER RUN.
C-----------------------------------------------------------------------
 1480 CONTINUE
      ICRASH = ICRASH + 1
      IF (ICRASH.EQ.3) GO TO 1580
C       ELSE RESTART MODE
      IF (ITRACE.GE.1) THEN
         AARG(1) = TN
         CALL D02NNN(AARG,1,3)
      END IF
      DO 1500 I = 1, N
         YDOTI(I) = 0.0D0
 1500 CONTINUE
      H = H*0.1D0
      H0 = H
      ISTEP = -1
      GO TO 480
C-----------------------------------------------------------------------
C BLOCK J.
C THE FOLLOWING BLOCK HANDLES ALL RETURNS OTHER THAN THOSE FOR ILLEGAL
C INPUT. IN THE CASE OF INTEGRATOR FAILURE THE ERROR MESSAGE ROUTINE IS
C CALLED Y IS LOADED FROM YH AND T IS SET TO TN. IN EITHER CASE THE   .
C OPTIONAL OUTPUTS ARE  LOADED INTO THE WORK ARRAYS BEFORE RETURNING.
C-----------------------------------------------------------------------
C THE MAXIMUM NUMBER OF STEPS WAS TAKEN BEFORE REACHING TOUT.
C
 1520 CONTINUE
      CALL D02NNQ(
     *' AT CURRENT TIME (=R1), MAXIMUM NUMBER OF ALLOWED STEPS (=I1)
     * ON THIS CALL WAS TAKEN BEFORE REACHING THE NEXT OUTPUT POINT
     *  TOUT (=R2) ',1,1,MXSTEP,0,2,TN,TOUT)
      ISAVE = 2
CMKM CHANGED 1700 TO 1780
      GO TO 1700
C EWT(I) .LE. 0.0 FOR SOME I (NOT AT START OF PROBLEM). ----------------
 1540 CONTINUE
      EWTI = RWORK(LEWT+I-1)
      I = -IEWSET
      CALL D02NNQ(
     *' AT T (=R1), THE ERROR TEST WEIGHT COMPONENT EWT(I1) HAS
     * BECOME (=R2) LESS OR EQAUL TO 0. CHECK THE VALUES OF ATOL RTOL
     * AND ITOL SUPPLIED (ATOL(I1) AND RTOL(I1) IF ARRAYS ARE
     * BEING USED).',1,1,I,0,2,TN,EWTI)
      ISAVE = 6
      GO TO 1700
C TOO MUCH ACCURACY REQUESTED FOR MACHINE PRECISION. -------------------
 1560 CONTINUE
      CALL D02NNQ(
     *' AT T (=R1), TOO MUCH ACCURACY REQUESTED FOR PRECISION
     * OF MACHINE . SEE OPTIONAL OUTPUT RWORK(14) (=R2)',1,0,0,0,2,TN,
     *            TOLSF)
      RWORK(14) = TOLSF
      ISAVE = 3
      GO TO 1700
C
C ERROR RETURNS FOR VALUES OF  ISTEP  =  -1, -2  OR  -4
C
 1580 CONTINUE
      IF (ISTEP.EQ.-4) THEN
         ISAVE = 7
         GO TO 1700
      ELSE
         ISAVE = 3 - ISTEP
         IF (ISAVE.EQ.8) ISAVE = 9
         GO TO 1640
      END IF
C
C INITIALISATION FAILED IN D02NNY
C
 1600 CONTINUE
      CALL D02NNQ(' ATTEMPT TO INITIALIZE DY/DT AND Y FAILED. ',1,0,0,0,
     *            0,0.0D0,0.0D0)
      ISAVE = 8
      GO TO 2420
 1620 CONTINUE
      CALL D02NNQ(
     *' MONITR ROUTINE ERROR- ILLEGAL VALUE OF IMON(=I1) RETURNED
     * TO D02NMF',1,1,IMON,0,0,0.0D0,0.0D0)
      ISAVE = 1
      GO TO 2420
C
C COMPUTE IMXER IF RELEVANT. -------------------------------------------
C
 1640 CONTINUE
      BIG = 0.0D0
C205
C205     REPLACE THE FOLLOWING BLOCK OF CODE WITH SOMETHING LIKE:
C205     ASSIGN TEMP1(1),.DYN.N
C205     TEMP1(1) = VABS ( RWORK(LACOR;N), TEMP1(1) )
C205     TEMP1(1) = TEMP(1) * RWORK(LEWT;N)
C205     IMXER = Q8SMAXI(TEMP1) + 1
C205     FREE
C205
      IMXER = 1
      DO 1660 I = 1, N
         SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
         IF (BIG.LT.SIZE) THEN
            BIG = SIZE
            IMXER = I
         END IF
 1660 CONTINUE
CMKM BLOCK DOWN TO 1780 COMMENTED OUT
C COMPUTE RESIDUAL IF RELEVANT. ----------------------------------------
C
C1700 DO 1720 I = 1, N
C        RWORK(I+LSAVR-1) = YSAVE(I,2)/H
C        Y(I) = YSAVE(I,1)
C1720 CONTINUE
C     IRES = 1
C
C     CALL RESID ( NEQ, TN, Y, RWORK(LSAVR), YDOTI, IRES, WKRES, NWKRES)
C
C     IREVCM = 5
C     GO TO 1860
 1680 CONTINUE
C     DO 1760 I = 1, N
C        YDOTI(I) = YDOTI(I) - RWORK(LSAVR+I-1)
C1760 CONTINUE
C     NRE = NRE + 1
C     IF (IRES.GT.1) THEN
C        CALL D02NNQ(
C    *' FCN ROUTINE SET ITS FLAG IRES TO (I1) WHEN CALLED
C    * FOR FINAL OUTPUT',2,1,IRES,0,0,0.0D0,0.0D0)
C     END IF
C
C SET Y VECTOR AND T
CMKM
 1700 CONTINUE
      DO 1720 I = 1, N
         Y(I) = YSAVE(I,1)
 1720 CONTINUE
 1740 CONTINUE
      T = TN
C***********************************************************************
C           EXIT POINT FOR SUCCESSFUL RUNS OR FOR RUN TIME FAILURES.   *
C           LOAD ISTATE AND THE OPTIONAL OUTPUTS                       *
C***********************************************************************
 1760 CONTINUE
      RWORK(11) = HU
      RWORK(12) = H
      RWORK(13) = TN
      RWORK(14) = TOLSF
      INFORM(1) = NST
      INFORM(2) = NRE
      INFORM(3) = NJE
      INFORM(4) = NQU
      INFORM(5) = NQ
      INFORM(6) = NITER
      INFORM(8) = IMXER
      IREVCM = 0
      RWORK(40) = 1.0D0
      IF (NT1STP .AND. NST.EQ.ICHMAX .AND. ISAVE.EQ.0) ISAVE = 13
      IFAIL = P01ABF(IFAIL,ISAVE,SRNAME,0,P01REC)
      RETURN
C***********************************************************************
C       EXIT POINT FOR REVERSE COMMUNICATION CALLS TO                  *
C             JAC , FCN AND MONITOR .                                  *
C***********************************************************************
 1780 CONTINUE
      RWORK(19) = TN
      GO TO (1840,1840,1840,1840,1840,1840,1840,1800,1820,
     *       1840) IREVCM
 1800 CONTINUE
      RWORK(16) = H
      RWORK(20) = EL0
      RETURN
 1820 CONTINUE
      RWORK(15) = HU
      RWORK(16) = H
      RWORK(17) = HMIN
      RWORK(18) = HMAX
      RWORK(10) = DBLE(NQU)
 1840 CONTINUE
      RETURN
C-----------------------------------------------------------------------
C BLOCK K.
C THE FOLLOWING BLOCK HANDLES ALL ERROR RETURNS DUE TO ILLEGAL INPUT
C (ISTATE = -3), AS DETECTED BEFORE CALLING THE CORE INTEGRATOR.
C FIRST THE ERROR MESSAGE ROUTINE IS CALLED AND THEN THE RUN IS HALTED.
C-----------------------------------------------------------------------
C
 1860 CONTINUE
      ERRMSG = ' THE INPUT VALUE OF ITASK (=I1) IS ILLEGAL'
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,0,0.0D0,0.0D0)
      GO TO 2400
 1880 CONTINUE
      ERRMSG =
     *' INTERNAL VARIABLES INDICATE THAT THE ROUTINE WAS
     * ENTERED ON A CONTINUATION CALL, BUT THAT THE INTERNAL
     * INITIALISATION HAD NOT BEEN DONE '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ERRMSG = ' THE USER HAS PROBABLY OVERWRITTEN THE WORK ARRAY '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2400
 1900 CONTINUE
      ERRMSG =
     *' THE NUMBER OF DIFFERENTIAL EQUATIONS HAS
     * ILLEGAL VALUE (=I1) LESS THAN  1.'
      CALL D02NNQ(ERRMSG,1,1,NEQ,0,0,0.0D0,0.0D0)
      GO TO 2400
 1920 CONTINUE
      ERRMSG =
     *' ON ENTRY  THE NUMBER OF DIFFERENTIAL EQUATIONS (=I1)    IS GREAT
     *ER THAN NEQMAX (=I2) '
      CALL D02NNQ(ERRMSG,1,2,NEQ,NEQMAX,0,0.0D0,0.0D0)
      GO TO 2400
 1940 CONTINUE
      ERRMSG =
     *' ROUTINE WAS ENTERED WITH THE  ILLEGAL VALUE OF          ITOL(=I1
     *) '
      CALL D02NNQ(ERRMSG,1,1,ITOL,0,0,0.0D0,0.0D0)
      GO TO 2400
 1960 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT MXSTEP HAS ILLEGAL VALUE(=I1)
     * LESS THAN 0.0.'
      CALL D02NNQ(ERRMSG,1,1,MXSTEP,0,0,0.0D0,0.0D0)
      GO TO 2400
 1980 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT MXHNIL NAS ILLEGAL VALUE (=I1)
     * LESS THAN 0.0. '
      CALL D02NNQ(ERRMSG,1,1,MXHNIL,0,0,0.0D0,0.0D0)
      GO TO 2400
 2000 CONTINUE
      ERRMSG = ' TOUT (=R1) LESS THAN  T (=R2) '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TOUT,T)
      ERRMSG =
     * ' INTEGRATION DIRECTION IS GIVEN BY THE OPTIONAL INPUT H0 (=R1) '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,H0,0.0D0)
      GO TO 2400
 2020 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT HMAX HAS PROVIDED AN ILLEGAL MAXIMUM
     * STEPSIZE (=R1) .LT. 0.0. '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,HMAX,0.0D0)
      GO TO 2400
 2040 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT   HMIN   HAS PROVIDED AN ILLEGAL MINIMUM
     * STEPSIZE (=R1) .LT. 0.0. '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,HMIN,0.0D0)
      GO TO 2400
 2060 CONTINUE
      ERRMSG = ' RTOL(=I1) HAS ILLEGAL VALUE (=R1) OF LESS THAN 0.0.'
      CALL D02NNQ(ERRMSG,1,1,I,0,1,RTOLI,0.0D0)
      GO TO 2400
 2080 CONTINUE
      ERRMSG = ' ATOL(=I1) HAS ILLEGAL VALUE (=R1) OF LESS THAN 0.0. '
      CALL D02NNQ(ERRMSG,1,1,I,0,1,ATOLI,0.0D0)
      GO TO 2400
 2100 CONTINUE
      EWTI = RWORK(LEWT+I-1)
      I = -IEWSET
      ERRMSG =
     *' THE WEIGHT USED IN THE LOCAL ERROR TEST EWT(I1) IS (=R1)
     * LESS THAN 0.0. CHECK THE VALUES OF RTOL AND ATOL. ATOL(I1)
     * AND Y(I1) MAY BOTH BE ZERO. '
      CALL D02NNQ(ERRMSG,1,1,I,0,1,EWTI,0.0D0)
      GO TO 2400
 2120 CONTINUE
      ERRMSG = ' TOUT (=R1) TOO CLOSE TO T(=R2) TO START INTEGRATION. '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TOUT,T)
      GO TO 2400
 2140 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK IS (=I1) AND TOUT (=R1) IS BEHIND
     * TCUR - HU (=R2) '
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,2,TOUT,TP)
      GO TO 2400
 2160 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK HAS BEEN SET TO 4 OR 5 AND THE
     * OPTIONAL INPUT TCRIT (=R1) IS BEHIND CURRENT TIME (=R2). '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TCRIT,TN)
      GO TO 2400
 2180 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK HAS BEEN SET TO 4 OR 5 AND THE
     *OPTIONAL INPUT TCRIT (=R1) IS BEHIND TOUT (=R2). '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TCRIT,TOUT)
      GO TO 2400
 2200 CONTINUE
      ERRMSG = ' AT START OF PROBLEM, TOO MUCH ACCURACY REQUIRED. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ERRMSG =
     *' REQUESTED FOR PRECISION OF MACHINE.  SEE TOLSF (=R1) AND THE
     *  DOCUMENTATION ON OPTIONAL OUTPUTS FOR THE MEANING OF THIS
     *  VALUE '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,TOLSF,0.0D0)
      RWORK(14) = TOLSF
      RWORK(11) = 0.0D0
      RWORK(12) = 0.0D0
      RWORK(13) = 0.0D0
      INFORM(1) = 0
      INFORM(2) = 0
      INFORM(3) = 0
      INFORM(4) = 0
      INFORM(5) = 0
      INFORM(6) = 0
      INFORM(8) = 0
      ISAVE = 14
      GO TO 2420
 2220 CONTINUE
      ERRMSG =
     *' TROUBLE FROM INTERNAL TIME INTERPOLATION ROUTINE
     * WHEN ITASK = I1, AND TOUT = R1'
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,1,TOUT,0.0D0)
      GO TO 2400
 2240 CONTINUE
      ERRMSG =
     *' MONITOR ERROR-SIZE OF O.D.E. SYSTEM WAS ILLEGALLY
     * INCREASED TO (=I1), IS GREATER THAN NEQMAX (=I2)'
      CALL D02NNQ(ERRMSG,1,2,NEQ,NEQMAX,0,0.0D0,0.0D0)
      GO TO 2400
 2260 CONTINUE
      ERRMSG =
     *' INTEGRATOR SETUP ROUTINE NOT CALLED OR USER HAS
     * OVERWRITTEN WORK ARRAY HE SUPPLIED TO SETUP ROUTINE. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2400
 2280 CONTINUE
      ERRMSG =
     *' LINEAR ALGEBRA SETUP ROUTINE NOT CALLED OR USER HAS
     * OVERWRITTEN WORKSPACE HE SUPPLIED TO SETUP ROUTINE'
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2400
 2300 CONTINUE
      ERRMSG =
     *' NY2DIM (=I1) SUPPLIED TO D02NMF NOT THE SAME AS NY2DIM
     * (=I2) SUPPLIED TO O.D.E SETUP ROUTINE OR THE USER HAS
     * OVERWRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE. '
      CALL D02NNQ(ERRMSG,1,2,NY2DIM,MY2DIM,0,0.0D0,0.0D0)
      GO TO 2400
 2320 CONTINUE
      ERRMSG =
     *' ILLEGAL VALUE FOR REVERSE COMMUNICATION INDEX IREVCM
     * (=I1) ON ENTRY '
      CALL D02NNQ(ERRMSG,1,1,IREVCM,0,0,0.0D0,0.0D0)
      GO TO 2400
 2340 CONTINUE
      ERRMSG =
     *' NWKJAC (=I1) SUPPLIED TO D02NMF NOT THE SAME NWKJAC (=I2)
     * SUPPLIED TO LINEAR ALGEBRA SETUP ROUTINE OR THE USER HAS
     * OVERWRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE. '
      CALL D02NNQ(ERRMSG,1,2,NWKJAC,MWKJAC,0,0.0D0,0.0D0)
      GO TO 2400
 2360 CONTINUE
      ERRMSG =
     *' NJCPVT (=I1) SUPPLIED TO D02NMF NOT THE SAME NJCPVT (=I2)
     * SUPPLIED TO LINEAR ALGEBRA SETUP ROUTINE OR THE USER HAS
     * OVERWRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE. '
      CALL D02NNQ(ERRMSG,1,2,NJCPVT,MJCPVT,0,0.0D0,0.0D0)
      GO TO 2400
 2380 CONTINUE
      ERRMSG =
     *' WORKSPACE ERROR OCCURRED IN THE
     *  LINEAR ALGEBRA ROUTINES -CHECK ARRAY SIZES '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ISAVE = 10
      GO TO 2420
C
 2400 CONTINUE
      ERRMSG = ' ILLEGAL INPUT '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ISAVE = 1
 2420 CONTINUE
      ERRMSG = ' RUN ABORTED.'
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
C***********************************************************************
C        OUTPUT POINT FOR ILLEGAL INPUTS                               *
C        COPY BACK ISTATE PARAMETER                                    *
C***********************************************************************
      IREVCM = 0
      IFAIL = P01ABF(IFAIL,ISAVE,SRNAME,0,P01REC)
      RETURN
C----------------------- END OF SUBROUTINE D02NMF-----------------------
      END
