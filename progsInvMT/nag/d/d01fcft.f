      SUBROUTINE D01FCF(NDIM,A,B,MINPTS,MAXPTS,FUNCTN,EPS,ACC,LENWRK,
     *                  WRKSTR,FINVAL,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 10B REVISED. IER-399 (JAN 1983).
C     MARK 11C REVISED. IER-464 (MAR 1985).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12A REVISED. IER-498 (AUG 1986).
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C
C     ADAPTIVE MULTIDIMENSIONAL INTEGRATION SUBROUTINE
C
C     *********  PARAMETERS FOR D01FCF  ****************************
C
C      INPUT PARAMETERS
C
C     NDIM    INTEGER NUMBER OF VARIABLES, MUST EXCEED 1 BUT
C             NOT EXCEED 15.
C
C     A       REAL ARRAY OF LOWER LIMITS, WITH DIMENSION NDIM
C
C     B       REAL ARRAY OF UPPER LIMITS, WITH DIMENSION NDIM
C
C     MINPTS  INTEGER MINIMUM NUMBER OF INTEGRAND VALUES TO BE
C             ALLOWED, WHICH MUST NOT EXCEED MAXPTS.
C
C     MAXPTS  INTEGER MAXIMUM NUMBER OF INTEGRAND VALUES TO BE
C             ALLOWED, WHICH MUST BE AT LEAST
C             2**NDIM+2*NDIM**2+2*NDIM+1.
C
C     FUNCTN  EXTERNALLY DECLARED USER DEFINED REAL FUNCTION
C             INTEGRAND. IT MUST HAVE PARAMETERS (NDIM,Z),
C             WHERE Z IS A REAL ARRAY OF DIMENSION NDIM.
C
C     EPS     REAL REQUIRED RELATIVE ACCURACY, MUST BE GREATER
C             THAN ZERO
C
C     LENWRK  INTEGER LENGTH OF ARRAY WRKSTR, MUST BE AT LEAST
C             2*NDIM+4.
C
C     IFAIL   INTEGER NAG FAILURE PARAMETER
C             IFAIL=0 FOR HARD FAIL
C             IFAIL=1 FOR SOFT FAIL
C
C      OUTPUT PARAMETERS
C
C     MINPTS  INTEGER NUMBER OF INTEGRAND VALUES USED BY THE
C             ROUTINE
C
C     WRKSTR  REAL ARRAY OF WORKING STORAGE OF DIMENSION (LENWRK).
C
C     ACC     REAL ESTIMATED RELATIVE ACCURACY OF FINVAL
C
C     FINVAL  REAL ESTIMATED VALUE OF INTEGRAL
C
C     IFAIL   IFAIL=0 FOR NORMAL EXIT, WHEN ESTIMATED RELATIVE
C                  LESS INTEGACCURACY RAND VALUES USED.
C
C          IFAIL=1 IF NDIM.LT.2, NDIM.GT.15, MINPTS.GT.MAXPTS,
C                  MAXPTS.LT.2**NDIM+2*NDIM*(NDIM+1)+1, EPS.LE.0
C                  OR LENWRK.LT.2*NDIM+4.
C
C          IFAIL=2 IF MAXPTS WAS TOO SMALL FOR D01FCF TO OBTAIN THE
C                  REQUIRED RELATIVE ACCURACY EPS.  IN THIS
C                  CASE D01FCF RETURNS A VALUE OF FINVAL
C                  WITH ESTIMATED RELATIVE ACCURACY ACC.
C
C          IFAIL=3 IF LENWRK TOO SMALL FOR MAXPTS INTEGRAND
C                  VALUES.  IN THIS CASE D01FCF RETURNS A
C                  VALUE OF FINVAL WITH ESTIMATED ACCURACY
C                  ACC USING THE WORKING STORAGE
C                  AVAILABLE, BUT ACC WILL BE GREATER
C                  THAN EPS.
C
C     **************************************************************
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01FCF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ACC, EPS, FINVAL
      INTEGER           IFAIL, LENWRK, MAXPTS, MINPTS, NDIM
C     .. Array Arguments ..
      DOUBLE PRECISION  A(NDIM), B(NDIM), WRKSTR(LENWRK)
C     .. Function Arguments ..
      DOUBLE PRECISION  FUNCTN
      EXTERNAL          FUNCTN
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSERR, DF1, DF2, DIFMAX, F1, F2, F3, F4, HALF,
     *                  LAMDA2, LAMDA4, LAMDA5, ONE, RATIO, RGNCMP,
     *                  RGNERR, RGNERT, RGNVAL, RGNVLT, RGNVOL, RLNDIM,
     *                  SUM1, SUM2, SUM3, SUM4, SUM5, TWO, TWONDM,
     *                  WEIT1, WEIT2, WEIT3, WEIT4, WEIT5, WEITP1,
     *                  WEITP2, WEITP3, WEITP4, ZERO
      INTEGER           DVAXES, DVAXIS, DVFLAG, FUNCLS, IERROR, J, K,
     *                  MAXAXS, MXRGNS, POINTR, RGNCLS, RULCLS, SBRGNS,
     *                  SUBRGN, SUBTMP, TPONTP, TPONTR
C     .. Local Arrays ..
      DOUBLE PRECISION  CENTER(15), DIF(15), OLDCNT(15), WIDTH(15),
     *                  Z(15)
      INTEGER           DVCNTL(15), DVCNTR(15)
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      INTEGER           P01ABF, X02BBF
      EXTERNAL          X02AJF, X02AMF, P01ABF, X02BBF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MIN, DBLE, SQRT, INT
C     .. Data statements ..
      DATA              ZERO, ONE, TWO, HALF/0.0D0, 1.0D0, 2.0D0, 0.5D0/
C     .. Executable Statements ..
C
C       SUBROUTINE INITIALISATION AND PARAMETER CHECKING
C
      FUNCLS = 0
      IF (NDIM.LT.2 .OR. NDIM.GT.15) GO TO 580
      IF (MINPTS.GT.MAXPTS) GO TO 580
      IF (EPS.LE.ZERO) GO TO 580
      IF (LENWRK.LT.2*NDIM+4) GO TO 580
      TWONDM = TWO**NDIM
      RGNVOL = TWONDM
      DVFLAG = 1
      MAXAXS = INT(MIN(DBLE(X02BBF(ONE)),1.0D0/X02AJF()))
      MAXAXS = (MAXAXS-NDIM)/(NDIM+1)
      MXRGNS = LENWRK/(2*NDIM+4)
      SBRGNS = 0
      RGNVLT = ZERO
      RGNERT = ZERO
      DO 20 J = 1, NDIM
         CENTER(J) = (A(J)+B(J))*HALF
         DIF(J) = ZERO
         WIDTH(J) = (B(J)-A(J))*HALF
         DVCNTL(J) = 1
         DVCNTR(J) = 1
         OLDCNT(J) = CENTER(J)
         RGNVOL = RGNVOL*WIDTH(J)
   20 CONTINUE
C
C       END SUBROUTINE INITIALISATION
C       BASIC RULE INITIALISATION
C
      RULCLS = 2**NDIM + 2*NDIM*NDIM + 2*NDIM + 1
      IF (MAXPTS.LT.RULCLS) GO TO 580
      FUNCLS = RULCLS
      RLNDIM = NDIM
      LAMDA2 = SQRT(9.0D0/70.0D0)
      LAMDA4 = SQRT(9.0D0/10.0D0)
      LAMDA5 = SQRT(9.0D0/19.0D0)
      WEIT1 = (12824.0D0-9120.0D0*RLNDIM+400.0D0*RLNDIM*RLNDIM)
     *        /19683.0D0
      WEIT2 = 980.0D0/6561.0D0
      WEIT3 = (1820.0D0-400.0D0*RLNDIM)/19683.0D0
      WEIT4 = 200.0D0/19683.0D0
      WEIT5 = 6859.0D0/19683.0D0/TWONDM
      WEITP1 = (729.0D0-950.0D0*RLNDIM+50.0D0*RLNDIM**2)/729.0D0
      WEITP2 = 245.0D0/486.0D0
      WEITP3 = (265.0D0-100.0D0*RLNDIM)/1458.0D0
      WEITP4 = 25.0D0/729.0D0
      RATIO = (LAMDA2/LAMDA4)**2
C
C       END BASIC RULE INITIALISATION
      GO TO 100
C       DIVIDE SUBREGION WITH LARGEST ERROR AND PREPARE TO USE
C       BASIC RULE ON EACH PORTION
C
   40 SUBRGN = 1
      POINTR = WRKSTR(1)
      RGNCLS = RULCLS
      RGNVOL = TWONDM
      TPONTR = POINTR + 2
      DO 60 J = 1, NDIM
         TPONTR = TPONTR + 2
         CENTER(J) = WRKSTR(TPONTR-1)
         WIDTH(J) = WRKSTR(TPONTR)
         DVCNTR(J) = 1
         DVCNTL(J) = 1
         OLDCNT(J) = CENTER(J)
         RGNVOL = RGNVOL*WIDTH(J)
   60 CONTINUE
      DVAXES = WRKSTR(POINTR+2)
      IF (DVAXES.LT.0) GO TO 620
   80 DVAXIS = DVAXES
      DVAXES = DVAXIS/(NDIM+1)
      DVAXIS = DVAXIS - (NDIM+1)*DVAXES
      DVCNTL(DVAXIS) = 2*DVCNTL(DVAXIS)
      RGNCLS = RGNCLS*2
      IF (DVAXES.GT.0) GO TO 80
      IF (FUNCLS+RGNCLS.GT.MAXPTS) GO TO 600
      IF (RGNCLS/RULCLS+SBRGNS-1.GT.MXRGNS) DVFLAG = 2
      FUNCLS = FUNCLS + RGNCLS
C
C       BEGIN BASIC RULE
  100 DO 120 J = 1, NDIM
         Z(J) = CENTER(J)
  120 CONTINUE
      SUM1 = FUNCTN(NDIM,Z)
      SUM2 = ZERO
      SUM3 = ZERO
      DO 140 J = 1, NDIM
         Z(J) = CENTER(J) - LAMDA2*WIDTH(J)
         F1 = FUNCTN(NDIM,Z)
         Z(J) = CENTER(J) + LAMDA2*WIDTH(J)
         F2 = FUNCTN(NDIM,Z)
         Z(J) = CENTER(J) - LAMDA4*WIDTH(J)
         F3 = FUNCTN(NDIM,Z)
         Z(J) = CENTER(J) + LAMDA4*WIDTH(J)
         F4 = FUNCTN(NDIM,Z)
         SUM2 = SUM2 + F1 + F2
         SUM3 = SUM3 + F3 + F4
         DF1 = F1 + F2 - TWO*SUM1
         DF2 = F3 + F4 - TWO*SUM1
         DIF(J) = DIF(J) + ABS(DF1-RATIO*DF2)
         Z(J) = CENTER(J)
  140 CONTINUE
      SUM4 = ZERO
      DO 200 J = 2, NDIM
         Z(J-1) = CENTER(J-1) - LAMDA4*WIDTH(J-1)
         DO 160 K = J, NDIM
            Z(K) = CENTER(K) - LAMDA4*WIDTH(K)
            SUM4 = SUM4 + FUNCTN(NDIM,Z)
            Z(K) = CENTER(K) + LAMDA4*WIDTH(K)
            SUM4 = SUM4 + FUNCTN(NDIM,Z)
            Z(K) = CENTER(K)
  160    CONTINUE
         Z(J-1) = CENTER(J-1) + LAMDA4*WIDTH(J-1)
         DO 180 K = J, NDIM
            Z(K) = CENTER(K) - LAMDA4*WIDTH(K)
            SUM4 = SUM4 + FUNCTN(NDIM,Z)
            Z(K) = CENTER(K) + LAMDA4*WIDTH(K)
            SUM4 = SUM4 + FUNCTN(NDIM,Z)
            Z(K) = CENTER(K)
  180    CONTINUE
         Z(J-1) = CENTER(J-1)
  200 CONTINUE
      SUM5 = ZERO
      DO 220 J = 1, NDIM
         Z(J) = CENTER(J) - LAMDA5*WIDTH(J)
  220 CONTINUE
  240 DO 260 J = 2, NDIM
         IF (Z(J-1).LT.CENTER(J-1)+WIDTH(J-1)) GO TO 280
         Z(J-1) = CENTER(J-1) - LAMDA5*WIDTH(J-1)
         Z(J) = Z(J) + TWO*LAMDA5*WIDTH(J)
  260 CONTINUE
      IF (Z(NDIM).GT.CENTER(NDIM)+WIDTH(NDIM)) GO TO 300
  280 SUM5 = SUM5 + FUNCTN(NDIM,Z)
      Z(1) = Z(1) + TWO*LAMDA5*WIDTH(1)
      GO TO 240
  300 RGNVAL = RGNVOL*(WEIT1*SUM1+WEIT2*SUM2+WEIT3*SUM3+WEIT4*SUM4+
     *         WEIT5*SUM5)
      RGNCMP = RGNVOL*(WEITP1*SUM1+WEITP2*SUM2+WEITP3*SUM3+WEITP4*SUM4)
      RGNERR = ABS(RGNVAL-RGNCMP)
C
C       END BASIC RULE
C       STORE RESULTS OF BASIC RULE APPLICATION
C
      RGNVLT = RGNVLT + RGNVAL
      RGNERT = RGNERT + RGNERR
      IF (DVFLAG.EQ.0) GO TO 340
      IF (DVFLAG.EQ.2) GO TO 500
      POINTR = MXRGNS + SBRGNS*(2*NDIM+3) + 1
      SBRGNS = SBRGNS + 1
      WRKSTR(SBRGNS) = POINTR
      SUBRGN = SBRGNS
      TPONTR = POINTR + 2
      DO 320 J = 1, NDIM
         TPONTR = TPONTR + 2
         WRKSTR(TPONTR-1) = CENTER(J)
         WRKSTR(TPONTR) = WIDTH(J)
  320 CONTINUE
  340 WRKSTR(POINTR) = RGNERT
      WRKSTR(POINTR+1) = RGNVLT
C       DETERMINE AXIS ALONG WHICH FOURTH DIFFERENCE IS LARGEST
      DIFMAX = ZERO
      DO 380 J = 1, NDIM
         IF (DIFMAX.GT.DIF(J)) GO TO 360
         DIFMAX = DIF(J)
         DVAXIS = J
  360    DIF(J) = ZERO
  380 CONTINUE
      TPONTR = POINTR + 2*(DVAXIS+1)
      WRKSTR(TPONTR) = WIDTH(DVAXIS)*HALF
      WRKSTR(TPONTR-1) = CENTER(DVAXIS) - WRKSTR(TPONTR)
      IF (DVFLAG.NE.2) GO TO 400
      DVAXES = WRKSTR(POINTR+2)
      IF (DVAXES.GT.MAXAXS) DVAXES = -1
      DVAXIS = DVAXIS + (NDIM+1)*DVAXES
  400 WRKSTR(POINTR+2) = DVAXIS
      IF (DVFLAG.EQ.1) GO TO 460
C       DETERMINE THE POSITION IN THE PARIALLY ORDERED LIST OF
C       THE SUBREGION WHICH REPLACES MOST RECENTLY DIVIDED SUBREGION
  420 SUBTMP = 2*SUBRGN
      IF (SUBTMP.GT.SBRGNS) GO TO 480
      TPONTR = WRKSTR(SUBTMP)
      IF (SUBTMP.EQ.SBRGNS) GO TO 440
      TPONTP = WRKSTR(SUBTMP+1)
      IF (WRKSTR(TPONTR).GE.WRKSTR(TPONTP)) GO TO 440
      SUBTMP = SUBTMP + 1
      TPONTR = TPONTP
  440 IF (RGNERT.GE.WRKSTR(TPONTR)) GO TO 480
      WRKSTR(SUBTMP) = POINTR
      WRKSTR(SUBRGN) = TPONTR
      SUBRGN = SUBTMP
      GO TO 420
C       WHEN WORKING STORAGE IS NOT USED UP, DETERMINE THE
C       POSITION IN THE PARTIALLY ORDERED LIST FOR THE DESCRIPTION
C       OF OTHER PORTION(S) OF MOST RECENTLY DIVIDED SUBREGION
  460 SUBTMP = SUBRGN/2
      IF (SUBTMP.LT.1) GO TO 480
      TPONTR = WRKSTR(SUBTMP)
      IF (RGNERT.LE.WRKSTR(TPONTR)) GO TO 480
      WRKSTR(SUBTMP) = POINTR
      WRKSTR(SUBRGN) = TPONTR
      SUBRGN = SUBTMP
      GO TO 460
  480 RGNVLT = ZERO
      RGNERT = ZERO
      IF (DVFLAG.EQ.2) GO TO 540
      DVFLAG = 1 - DVFLAG
C       COUNT TO DETERMINE THE NEXT PART OF THE RECENTLY DIVIDED
C       SUBREGION FOR APPLICATION OF THE BASIC RULE
  500 CENTER(1) = CENTER(1) + TWO*WIDTH(1)
      DVCNTR(1) = DVCNTR(1) + 1
      DO 520 J = 2, NDIM
         IF (DVCNTR(J-1).LE.DVCNTL(J-1)) GO TO 100
         DVCNTR(J-1) = 1
         CENTER(J-1) = OLDCNT(J-1)
         DVCNTR(J) = DVCNTR(J) + 1
         CENTER(J) = CENTER(J) + TWO*WIDTH(J)
  520 CONTINUE
      IF (DVCNTR(NDIM).LE.DVCNTL(NDIM)) GO TO 100
      CENTER(NDIM) = OLDCNT(NDIM)
      IF (DVFLAG.EQ.2) GO TO 340
C
C       END ORDERING OF BASIC RULE RESULTS
C       MAKE CHECKS FOR POSSIBLE TERMINATION OF ROUTINE
C
  540 ACC = ONE
      ABSERR = ZERO
      FINVAL = ZERO
      POINTR = MXRGNS + 1
      TPONTR = 2*NDIM + 3
      DO 560 J = 1, SBRGNS
         ABSERR = ABSERR + WRKSTR(POINTR)
         FINVAL = FINVAL + WRKSTR(POINTR+1)
         POINTR = POINTR + TPONTR
  560 CONTINUE
      IF (ABS(FINVAL).GT.X02AMF()) ACC = ABSERR/ABS(FINVAL)
      IF (ABSERR.EQ.ZERO) ACC = ZERO
      IF (ACC.GT.EPS .OR. FUNCLS.LT.MINPTS) GO TO 40
C
C       LOOP BACK TO APPLY BASIC RULE
C
C       TERMINATION POINT, SET IFAIL AND RETURN
C
      IERROR = 0
      GO TO 640
  580 IERROR = 1
      GO TO 640
  600 IERROR = 2
      GO TO 640
  620 IERROR = 3
  640 MINPTS = FUNCLS
      IFAIL = P01ABF(IFAIL,IERROR,SRNAME,0,P01REC)
      RETURN
      END
