      SUBROUTINE D02QFQ(IREVCM,TWANT,NEQN,Y,X,H,EPS,WT,START,HOLD,K,
     *                  KOLD,CRASH,PHI,P,YP,PSI,ALPHA,BETA,SIG,V,W,G,
     *                  PHASE1,NS,NORND,KSTEPS,TWOU,FOURU,XOLD,KPREV,
     *                  IVC,IV,KGI,GI,NSUCC,NFAIL)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C     PURPOSE
C     =======
C     INTEGRATES A SYSTEM OF FIRST ORDER ODES ONE STEP.
C
C     DESCRIPTION
C     ===========
C     WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C     ABSTRACT
C
C     SUBROUTINE D02QFQ INTEGRATES A SYSTEM OF  NEQN  FIRST ORDER
C     ORDINARY DIFFERENTIAL EQUATIONS ONE STEP, NORMALLY FROM X TO X+H,
C     USING A MODIFIED DIVIDED DIFFERENCE FORM OF THE ADAMS PECE
C     FORMULAS.  LOCAL EXTRAPOLATION IS USED TO IMPROVE ABSOLUTE
C     STABILITY AND ACCURACY. THE CODE ADJUSTS ITS ORDER AND STEP SIZE
C     TO CONTROL THE LOCAL ERROR  PER UNIT STEP IN A GENERALIZED SENSE.
C     SPECIAL DEVICES ARE INCLUDED TO CONTROL ROUNDOFF ERROR AND TO
C     DETECT WHEN THE USER IS REQUESTING TOO MUCH ACCURACY.
C
C     THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C     COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C     VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C     FURTHER DETAILS ON USE OF THIS CODE ARE AVAILABLE IN *SOLVING
C     ORDINARY DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C     BY L. F. SHAMPINE AND M. K. GORDON, SLA-73-1060.
C
C
C     THE PARAMETERS REPRESENT --
C      F -- SUBROUTINE TO EVALUATE DERIVATIVES
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- SOLUTION VECTOR AT X
C      X -- INDEPENDENT VARIABLE
C      H -- APPROPRIATE STEP SIZE FOR NEXT STEP.  NORMALLY DETERMINED BY
C           CODE
C      EPS -- LOCAL ERROR TOLERANCE
C      WT(*) -- VECTOR OF WEIGHTS FOR ERROR CRITERION
C      START -- LOGICAL VARIABLE SET .TRUE. FOR FIRST STEP,  .FALSE.
C           OTHERWISE
C      HOLD -- STEP SIZE USED FOR LAST SUCCESSFUL STEP
C      K -- APPROPRIATE ORDER FOR NEXT STEP (DETERMINED BY CODE)
C      KOLD -- ORDER USED FOR LAST SUCCESSFUL STEP
C      CRASH -- LOGICAL VARIABLE SET .TRUE. WHEN NO STEP CAN BE TAKEN,
C           .FALSE. OTHERWISE.
C      YP(*) -- DERIVATIVE OF SOLUTION VECTOR AT  X  AFTER SUCCESSFUL
C           STEP
C      KSTEPS -- COUNTER ON ATTEMPTED STEPS
C      TWOU -- 2.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      FOURU -- 4.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      RPAR,IPAR -- PARAMETER ARRAYS WHICH YOU MAY CHOOSE TO USE
C            FOR COMMUNICATION BETWEEN YOUR PROGRAM AND SUBROUTINE F.
C            THEY ARE NOT ALTERED OR USED BY D02QFQ.
C     THE VARIABLES X,XOLD,KOLD,KGI AND IVC AND THE ARRAYS
C     Y,PHI,ALPHA,G,W,P,IV AND GI ARE REQUIRED FOR THE INTERPOLATION
C     SUBROUTINE D02QFR. THE REMAINING VARIABLES AND ARRAYS ARE
C     INCLUDED IN THE CALL LIST ONLY TO ELIMINATE LOCAL RETENTION
C     OF VARIABLES BETWEEN CALLS.
C
C     INPUT TO D02QFQ
C
C      FIRST CALL --
C
C     THE USER MUST PROVIDE STORAGE IN HIS CALLING PROGRAM FOR
C     ALL ARRAYS IN THE CALL LIST, NAMELY
C
C     DIMENSION Y(NEQN),WT(NEQN),PHI(NEQN,16),P(NEQN),YP(NEQN),PSI(12),
C     1  ALPHA(12),BETA(12),SIG(13),V(12),W(12),G(13),GI(11),IV(10),
C     2  RPAR(1),IPAR(1)
C                              --                --    **NOTE**
C
C     THE USER MUST ALSO DECLARE  START ,  CRASH ,  PHASE1  AND  NORND
C     LOGICAL VARIABLES AND  F  AN EXTERNAL SUBROUTINE, SUPPLY THE
C     SUBROUTINE  F(X,Y,YP)  TO EVALUATE
C      DY(I)/DX = YP(I) = F(X,Y(1),Y(2),...,Y(NEQN))
C     AND INITIALIZE ONLY THE FOLLOWING PARAMETERS.
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- VECTOR OF INITIAL VALUES OF DEPENDENT VARIABLES
C      X -- INITIAL VALUE OF THE INDEPENDENT VARIABLE
C      H -- NOMINAL STEP SIZE INDICATING DIRECTION OF INTEGRATION
C           AND MAXIMUM SIZE OF STEP.  MUST BE VARIABLE
C      EPS -- LOCAL ERROR TOLERANCE PER STEP.  MUST BE VARIABLE
C      WT(*) -- VECTOR OF NON-ZERO WEIGHTS FOR ERROR CRITERION
C      START -- .TRUE.
C      YP(*) -- VECTOR OF INITIAL DERIVATIVE VALUES
C      KSTEPS -- SET KSTEPS TO ZERO
C      TWOU -- 2.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      FOURU -- 4.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C     DEFINE U TO BE THE MACHINE UNIT ROUNDOFF QUANTITY BY CALLING
C     THE FUNCTION ROUTINE  R1MACH,  U = R1MACH(4), OR BY
C     COMPUTING U SO THAT U IS THE SMALLEST POSITIVE NUMBER SUCH
C     THAT 1.0+U .GT. 1.0.
C
C     D02QFQ  REQUIRES THAT THE L2 NORM OF THE VECTOR WITH COMPONENTS
C     LOCAL ERROR(L)/WT(L)  BE LESS THAN  EPS  FOR A SUCCESSFUL STEP.
C     THE ARRAY  WT  ALLOWS THE USER TO SPECIFY AN ERROR TEST
C     APPROPRIATE FOR HIS PROBLEM.  FOR EXAMPLE,
C      WT(L) = 1.0  SPECIFIES ABSOLUTE ERROR,
C            = ABS(Y(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF THE
C                 L-TH COMPONENT OF THE SOLUTION,
C            = ABS(YP(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF
C                 THE L-TH COMPONENT OF THE DERIVATIVE,
C            = AMAX1(WT(L),ABS(Y(L)))  ERROR RELATIVE TO THE LARGEST
C                 MAGNITUDE OF L-TH COMPONENT OBTAINED SO FAR,
C            = ABS(Y(L))*RELERR/EPS + ABSERR/EPS  SPECIFIES A MIXED
C                 RELATIVE-ABSOLUTE TEST WHERE  RELERR  IS RELATIVE
C                 ERROR,  ABSERR  IS ABSOLUTE ERROR AND  EPS =
C                 AMAX1(RELERR,ABSERR) .
C
C      SUBSEQUENT CALLS --
C
C     SUBROUTINE  D02QFQ  IS DESIGNED SO THAT ALL INFORMATION NEEDED TO
C     CONTINUE THE INTEGRATION, INCLUDING THE STEP SIZE H  AND THE ORDER
C     K , IS RETURNED WITH EACH STEP.  WITH THE EXCEPTION OF THE STEP
C     SIZE, THE ERROR TOLERANCE, AND THE WEIGHTS, NONE OF THE PARAMETERS
C     SHOULD BE ALTERED.  THE ARRAY  WT  MUST BE UPDATED AFTER EACH STEP
C     TO MAINTAIN RELATIVE ERROR TESTS LIKE THOSE ABOVE.  NORMALLY THE
C     INTEGRATION IS CONTINUED JUST BEYOND THE DESIRED ENDPOINT AND THE
C     SOLUTION INTERPOLATED THERE WITH SUBROUTINE  D02QFR .  IF IT IS
C     IMPOSSIBLE TO INTEGRATE BEYOND THE ENDPOINT, THE STEP SIZE MAY BE
C     REDUCED TO HIT THE ENDPOINT SINCE THE CODE WILL NOT TAKE A STEP
C     LARGER THAN THE  H  INPUT.  CHANGING THE DIRECTION OF INTEGRATION,
C     I.E., THE SIGN OF H , REQUIRES THE USER SET  START = .TRUE. BEFORE
C     CALLING D02QFQ  AGAIN.  THIS IS THE ONLY SITUATION IN WHICH  START
C     SHOULD BE ALTERED.
C
C     OUTPUT FROM D02QFQ
C
C      SUCCESSFUL STEP --
C
C     THE SUBROUTINE RETURNS AFTER EACH SUCCESSFUL STEP WITH  START  AND
C     CRASH  SET .FALSE. .  X  REPRESENTS THE INDEPENDENT VARIABLE
C     ADVANCED ONE STEP OF LENGTH  HOLD  FROM ITS VALUE ON INPUT AND  Y
C     THE SOLUTION VECTOR AT THE NEW VALUE OF  X .  ALL OTHER PARAMETERS
C     REPRESENT INFORMATION CORRESPONDING TO THE NEW  X  NEEDED TO
C     CONTINUE THE INTEGRATION.
C
C      UNSUCCESSFUL STEP --
C
C     WHEN THE ERROR TOLERANCE IS TOO SMALL FOR THE MACHINE PRECISION,
C     THE SUBROUTINE RETURNS WITHOUT TAKING A STEP AND  CRASH = .TRUE. .
C     AN APPROPRIATE STEP SIZE AND ERROR TOLERANCE FOR CONTINUING ARE
C     ESTIMATED AND ALL OTHER INFORMATION IS RESTORED AS UPON INPUT
C     BEFORE RETURNING.  TO CONTINUE WITH THE LARGER TOLERANCE, THE USER
C     JUST CALLS THE CODE AGAIN.  A RESTART IS NEITHER REQUIRED NOR
C     DESIRABLE.
C
C     REFERENCES
C     ==========
C                 SHAMPINE L.F., GORDON M.K., *SOLVING ORDINARY
C                 DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C                 SLA-73-1060, SANDIA LABORATORIES, 1973.
C
C     DATE WRITTEN   740101   (YYMMDD)
C     REVISION DATE  840201   (YYMMDD)
C     AUTHOR  SHAMPINE, L.F.,  SNLA
C           GORDON, M.K.
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  EPS, FOURU, H, HOLD, TWANT, TWOU, X, XOLD
      INTEGER           IREVCM, IVC, K, KGI, KOLD, KPREV, KSTEPS, NEQN,
     *                  NFAIL, NS, NSUCC
      LOGICAL           CRASH, NORND, PHASE1, START
C     .. Array Arguments ..
      DOUBLE PRECISION  ALPHA(12), BETA(12), G(13), GI(11), P(NEQN),
     *                  PHI(NEQN,16), PSI(12), SIG(13), V(12), W(12),
     *                  WT(NEQN), Y(NEQN), YP(NEQN)
      INTEGER           IV(10)
C     .. Scalars in Common ..
      DOUBLE PRECISION  ABSH, BIG, ERK, ERKM1, P5EPS, ROUND, U
      INTEGER           IFAIL, KM1, KM2, KNEW, KP1, KP2
C     .. Arrays in Common ..
      DOUBLE PRECISION  GSTR(13), TWO(13)
C     .. Local Scalars ..
      DOUBLE PRECISION  ERKM2, ERKP1, ERR, HNEW, R, REALI, REALNS, RHO,
     *                  TAU, TEMP1, TEMP2, TEMP3, TEMP4, TEMP5, TEMP6
      INTEGER           I, IM1, IP1, IQ, J, JV, L, LIMIT1, LIMIT2, NSM2,
     *                  NSP1, NSP2
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. External Subroutines ..
      EXTERNAL          D02QFP
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /KD02QF/TWO, GSTR, ABSH, BIG, ERK, ERKM1, P5EPS,
     *                  ROUND, U, IFAIL, KM1, KM2, KNEW, KP1, KP2
C     .. Save statement ..
      SAVE              /KD02QF/
C     .. Executable Statements ..
C
C
C       ***     BEGIN BLOCK 0     ***
C     CHECK IF STEP SIZE OR ERROR TOLERANCE IS TOO SMALL FOR MACHINE
C     PRECISION.  IF FIRST STEP, INITIALIZE PHI ARRAY AND ESTIMATE A
C     STARTING STEP SIZE.
C                   ***
C
C     IF STEP SIZE IS TOO SMALL, DETERMINE AN ACCEPTABLE ONE
C
      GO TO (100,100,100,660,1160,880) IREVCM - 2
      CRASH = .TRUE.
      IF (ABS(H).GE.FOURU*ABS(X)) GO TO 20
      H = SIGN(FOURU*ABS(X),H)
      RETURN
   20 P5EPS = 0.5D0*EPS
C
C     IF ERROR TOLERANCE IS TOO SMALL, INCREASE IT TO AN ACCEPTABLE
C     VALUE
C
      ROUND = 0.0D0
      DO 40 L = 1, NEQN
         ROUND = ROUND + (Y(L)/WT(L))**2
   40 CONTINUE
      ROUND = TWOU*SQRT(ROUND)
      IF (P5EPS.GE.ROUND) GO TO 60
      EPS = 2.0D0*ROUND*(1.0D0+FOURU)
      RETURN
   60 CRASH = .FALSE.
      G(1) = 1.0D0
      G(2) = 0.5D0
      SIG(1) = 1.0D0
      IF ( .NOT. START) GO TO 140
C
C     INITIALIZE.  COMPUTE APPROPRIATE STEP SIZE FOR FIRST STEP
C
C      CALL F(X,Y,YP,RPAR,IPAR)
C     SUM = 0.0
      TWO(1) = 2.0D0
      TWO(2) = 4.0D0
      TWO(3) = 8.0D0
      TWO(4) = 16.0D0
      TWO(5) = 32.0D0
      TWO(6) = 64.0D0
      TWO(7) = 128.0D0
      TWO(8) = 256.0D0
      TWO(9) = 512.0D0
      TWO(10) = 1024.0D0
      TWO(11) = 2048.0D0
      TWO(12) = 4096.0D0
      TWO(13) = 8192.0D0
      GSTR(1) = 0.5D0
      GSTR(2) = 0.0833D0
      GSTR(3) = 0.0417D0
      GSTR(4) = 0.0264D0
      GSTR(5) = 0.0188D0
      GSTR(6) = 0.0143D0
      GSTR(7) = 0.0114D0
      GSTR(8) = 0.00936D0
      GSTR(9) = 0.00789D0
      GSTR(10) = 0.00679D0
      GSTR(11) = 0.00592D0
      GSTR(12) = 0.00524D0
      GSTR(13) = 0.00468D0
      DO 80 L = 1, NEQN
         PHI(L,1) = YP(L)
         PHI(L,2) = 0.0D0
   80 CONTINUE
C     20     SUM = SUM + (YP(L)/WT(L))**2
C     SUM = SQRT(SUM)
C     ABSH = ABS(H)
C     IF(EPS .LT. 16.0*SUM*H*H) ABSH = 0.25*SQRT(EPS/SUM)
C     H = SIGN(AMAX1(ABSH,FOURU*ABS(X)),H)
C
C      U = R1MACH(4)
      U = X02AJF()
C      BIG = SQRT(R1MACH(2))
      BIG = SQRT(1.0D0/X02AMF())
      TWANT = X
  100 CONTINUE
C     CALL HSTART(IREVCM,NEQN,TWANT,X+H,Y,YP,WT,1,U,BIG,PHI(1,3),PHI(1,
C     *            4),PHI(1,5),PHI(1,6),H)
      CALL D02QFP(IREVCM,NEQN,TWANT,X+H,Y,YP,WT,1,U,BIG,PHI(1,3),PHI(1,
     *            4),PHI(1,5),PHI(1,6),H)
      IF (IREVCM.NE.0) RETURN
C
      HOLD = 0.0D0
      K = 1
      KOLD = 0
      KPREV = 0
      START = .FALSE.
      PHASE1 = .TRUE.
      NORND = .TRUE.
      IF (P5EPS.GT.100.0D0*ROUND) GO TO 140
      NORND = .FALSE.
      DO 120 L = 1, NEQN
         PHI(L,15) = 0.0D0
  120 CONTINUE
  140 IFAIL = 0
C       ***     END BLOCK 0     ***
C
C       ***     BEGIN BLOCK 1     ***
C     COMPUTE COEFFICIENTS OF FORMULAS FOR THIS STEP.  AVOID COMPUTING
C     THOSE QUANTITIES NOT CHANGED WHEN STEP SIZE IS NOT CHANGED.
C                   ***
C
  160 KP1 = K + 1
      KP2 = K + 2
      KM1 = K - 1
      KM2 = K - 2
C
C     NS IS THE NUMBER OF STEPS TAKEN WITH SIZE H, INCLUDING THE CURRENT
C     ONE.  WHEN K.LT.NS, NO COEFFICIENTS CHANGE
C
      IF (H.NE.HOLD) NS = 0
      IF (NS.LE.KOLD) NS = NS + 1
      NSP1 = NS + 1
      IF (K.LT.NS) GO TO 440
C
C     COMPUTE THOSE COMPONENTS OF ALPHA(*),BETA(*),PSI(*),SIG(*) WHICH
C     ARE CHANGED
C
      BETA(NS) = 1.0D0
      REALNS = NS
      ALPHA(NS) = 1.0D0/REALNS
      TEMP1 = H*REALNS
      SIG(NSP1) = 1.0D0
      IF (K.LT.NSP1) GO TO 200
      DO 180 I = NSP1, K
         IM1 = I - 1
         TEMP2 = PSI(IM1)
         PSI(IM1) = TEMP1
         BETA(I) = BETA(IM1)*PSI(IM1)/TEMP2
         TEMP1 = TEMP2 + H
         ALPHA(I) = H/TEMP1
         REALI = I
         SIG(I+1) = REALI*ALPHA(I)*SIG(I)
  180 CONTINUE
  200 PSI(K) = TEMP1
C
C     COMPUTE COEFFICIENTS G(*)
C
C     INITIALIZE V(*) AND SET W(*).
C
      IF (NS.GT.1) GO TO 240
      DO 220 IQ = 1, K
         TEMP3 = IQ*(IQ+1)
         V(IQ) = 1.0D0/TEMP3
         W(IQ) = V(IQ)
  220 CONTINUE
      IVC = 0
      KGI = 0
      IF (K.EQ.1) GO TO 380
      KGI = 1
      GI(1) = W(2)
      GO TO 380
C
C     IF ORDER WAS RAISED, UPDATE DIAGONAL PART OF V(*)
C
  240 IF (K.LE.KPREV) GO TO 320
      IF (IVC.EQ.0) GO TO 260
      JV = KP1 - IV(IVC)
      IVC = IVC - 1
      GO TO 280
  260 JV = 1
      TEMP4 = K*KP1
      V(K) = 1.0D0/TEMP4
      W(K) = V(K)
      IF (K.NE.2) GO TO 280
      KGI = 1
      GI(1) = W(2)
  280 NSM2 = NS - 2
      IF (NSM2.LT.JV) GO TO 320
      DO 300 J = JV, NSM2
         I = K - J
         V(I) = V(I) - ALPHA(J+1)*V(I+1)
         W(I) = V(I)
  300 CONTINUE
      IF (I.NE.2) GO TO 320
      KGI = NS - 1
      GI(KGI) = W(2)
C
C     UPDATE V(*) AND SET W(*)
C
  320 LIMIT1 = KP1 - NS
      TEMP5 = ALPHA(NS)
      DO 340 IQ = 1, LIMIT1
         V(IQ) = V(IQ) - TEMP5*V(IQ+1)
         W(IQ) = V(IQ)
  340 CONTINUE
      G(NSP1) = W(1)
      IF (LIMIT1.EQ.1) GO TO 360
      KGI = NS
      GI(KGI) = W(2)
  360 W(LIMIT1+1) = V(LIMIT1+1)
      IF (K.GE.KOLD) GO TO 380
      IVC = IVC + 1
      IV(IVC) = LIMIT1 + 2
C
C     COMPUTE THE G(*) IN THE WORK VECTOR W(*)
C
  380 NSP2 = NS + 2
      KPREV = K
      IF (KP1.LT.NSP2) GO TO 440
      DO 420 I = NSP2, KP1
         LIMIT2 = KP2 - I
         TEMP6 = ALPHA(I-1)
         DO 400 IQ = 1, LIMIT2
            W(IQ) = W(IQ) - TEMP6*W(IQ+1)
  400    CONTINUE
         G(I) = W(1)
  420 CONTINUE
  440 CONTINUE
C       ***     END BLOCK 1     ***
C
C       ***     BEGIN BLOCK 2     ***
C     PREDICT A SOLUTION P(*), EVALUATE DERIVATIVES USING PREDICTED
C     SOLUTION, ESTIMATE LOCAL ERROR AT ORDER K AND ERRORS AT ORDERS K,
C     K-1, K-2 AS IF CONSTANT STEP SIZE WERE USED.
C                   ***
C
C     INCREMENT COUNTER ON ATTEMPTED STEPS
C
      KSTEPS = KSTEPS + 1
C
C     CHANGE PHI TO PHI STAR
C
      IF (K.LT.NSP1) GO TO 500
      DO 480 I = NSP1, K
         TEMP1 = BETA(I)
         DO 460 L = 1, NEQN
            PHI(L,I) = TEMP1*PHI(L,I)
  460    CONTINUE
  480 CONTINUE
C
C     PREDICT SOLUTION AND DIFFERENCES
C
  500 DO 520 L = 1, NEQN
         PHI(L,KP2) = PHI(L,KP1)
         PHI(L,KP1) = 0.0D0
         P(L) = 0.0D0
  520 CONTINUE
      DO 560 J = 1, K
         I = KP1 - J
         IP1 = I + 1
         TEMP2 = G(I)
         DO 540 L = 1, NEQN
            P(L) = P(L) + TEMP2*PHI(L,I)
            PHI(L,I) = PHI(L,I) + PHI(L,IP1)
  540    CONTINUE
  560 CONTINUE
      IF (NORND) GO TO 600
      DO 580 L = 1, NEQN
         TAU = H*P(L) - PHI(L,15)
         P(L) = Y(L) + TAU
         PHI(L,16) = (P(L)-Y(L)) - TAU
  580 CONTINUE
      GO TO 640
  600 DO 620 L = 1, NEQN
         P(L) = Y(L) + H*P(L)
  620 CONTINUE
  640 XOLD = X
      X = X + H
      ABSH = ABS(H)
C     CALL F(X,P,YP,RPAR,IPAR)
      IREVCM = 6
      TWANT = X
      RETURN
  660 CONTINUE
      IREVCM = 0
C
C     ESTIMATE ERRORS AT ORDERS K,K-1,K-2
C
      ERKM2 = 0.0D0
      ERKM1 = 0.0D0
      ERK = 0.0D0
      DO 740 L = 1, NEQN
         TEMP3 = 1.0D0/WT(L)
         TEMP4 = YP(L) - PHI(L,1)
         IF (KM2) 720, 700, 680
  680    ERKM2 = ERKM2 + ((PHI(L,KM1)+TEMP4)*TEMP3)**2
  700    ERKM1 = ERKM1 + ((PHI(L,K)+TEMP4)*TEMP3)**2
  720    ERK = ERK + (TEMP4*TEMP3)**2
  740 CONTINUE
      IF (KM2) 800, 780, 760
  760 ERKM2 = ABSH*SIG(KM1)*GSTR(KM2)*SQRT(ERKM2)
  780 ERKM1 = ABSH*SIG(K)*GSTR(KM1)*SQRT(ERKM1)
  800 TEMP5 = ABSH*SQRT(ERK)
      ERR = TEMP5*(G(K)-G(KP1))
      ERK = TEMP5*SIG(KP1)*GSTR(K)
      KNEW = K
C
C     TEST IF ORDER SHOULD BE LOWERED
C
      IF (KM2) 860, 840, 820
  820 IF (MAX(ERKM1,ERKM2).LE.ERK) KNEW = KM1
      GO TO 860
  840 IF (ERKM1.LE.0.5D0*ERK) KNEW = KM1
C
C     TEST IF STEP SUCCESSFUL
C
  860 IF (ERR.LE.EPS) GO TO 1060
C       ***     END BLOCK 2     ***
C
C       ***     BEGIN BLOCK 3     ***
C     THE STEP IS UNSUCCESSFUL.  RESTORE  X, PHI(*,*), PSI(*) .
C     IF THIRD CONSECUTIVE FAILURE, SET ORDER TO ONE.  IF STEP FAILS
C     MORE THAN THREE TIMES, CONSIDER AN OPTIMAL STEP SIZE.  DOUBLE
C     ERROR TOLERANCE AND RETURN IF ESTIMATED STEP SIZE IS TOO SMALL
C     FOR MACHINE PRECISION.
C                   ***
C
C     RESTORE X, PHI(*,*) AND PSI(*)
C
      NFAIL = NFAIL + 1
      TWANT = XOLD
      IREVCM = 8
      RETURN
  880 CONTINUE
      IREVCM = 0
      PHASE1 = .FALSE.
      X = XOLD
      DO 920 I = 1, K
         TEMP1 = 1.0D0/BETA(I)
         IP1 = I + 1
         DO 900 L = 1, NEQN
            PHI(L,I) = TEMP1*(PHI(L,I)-PHI(L,IP1))
  900    CONTINUE
  920 CONTINUE
      IF (K.LT.2) GO TO 960
      DO 940 I = 2, K
         PSI(I-1) = PSI(I) - H
  940 CONTINUE
C
C     ON THIRD FAILURE, SET ORDER TO ONE.  THEREAFTER, USE OPTIMAL STEP
C     SIZE
C
  960 IFAIL = IFAIL + 1
      TEMP2 = 0.5D0
      IF (IFAIL-3) 1020, 1000, 980
  980 IF (P5EPS.LT.0.25D0*ERK) TEMP2 = SQRT(P5EPS/ERK)
 1000 KNEW = 1
 1020 H = TEMP2*H
      K = KNEW
      NS = 0
      IF (ABS(H).GE.FOURU*ABS(X)) GO TO 1040
      CRASH = .TRUE.
      H = SIGN(FOURU*ABS(X),H)
      EPS = EPS + EPS
      RETURN
 1040 GO TO 160
C       ***     END BLOCK 3     ***
C
C       ***     BEGIN BLOCK 4     ***
C     THE STEP IS SUCCESSFUL.  CORRECT THE PREDICTED SOLUTION, EVALUATE
C     THE DERIVATIVES USING THE CORRECTED SOLUTION AND UPDATE THE
C     DIFFERENCES.  DETERMINE BEST ORDER AND STEP SIZE FOR NEXT STEP.
C                   ***
 1060 KOLD = K
      HOLD = H
      NSUCC = NSUCC + 1
C
C     CORRECT AND EVALUATE
C
      TEMP1 = H*G(KP1)
      IF (NORND) GO TO 1100
      DO 1080 L = 1, NEQN
         TEMP3 = Y(L)
         RHO = TEMP1*(YP(L)-PHI(L,1)) - PHI(L,16)
         Y(L) = P(L) + RHO
         PHI(L,15) = (Y(L)-P(L)) - RHO
         P(L) = TEMP3
 1080 CONTINUE
      GO TO 1140
 1100 DO 1120 L = 1, NEQN
         TEMP3 = Y(L)
         Y(L) = P(L) + TEMP1*(YP(L)-PHI(L,1))
         P(L) = TEMP3
 1120 CONTINUE
C     420  CALL F(X,Y,YP,RPAR,IPAR)
 1140 IREVCM = 7
      TWANT = X
      RETURN
 1160 CONTINUE
      IREVCM = 0
C
C     UPDATE DIFFERENCES FOR NEXT STEP
C
      DO 1180 L = 1, NEQN
         PHI(L,KP1) = YP(L) - PHI(L,1)
         PHI(L,KP2) = PHI(L,KP1) - PHI(L,KP2)
 1180 CONTINUE
      DO 1220 I = 1, K
         DO 1200 L = 1, NEQN
            PHI(L,I) = PHI(L,I) + PHI(L,KP1)
 1200    CONTINUE
 1220 CONTINUE
C
C     ESTIMATE ERROR AT ORDER K+1 UNLESS:
C     IN FIRST PHASE WHEN ALWAYS RAISE ORDER,
C     ALREADY DECIDED TO LOWER ORDER,
C     STEP SIZE NOT CONSTANT SO ESTIMATE UNRELIABLE
C
      ERKP1 = 0.0D0
      IF (KNEW.EQ.KM1 .OR. K.EQ.12) PHASE1 = .FALSE.
      IF (PHASE1) GO TO 1280
      IF (KNEW.EQ.KM1) GO TO 1300
      IF (KP1.GT.NS) GO TO 1320
      DO 1240 L = 1, NEQN
         ERKP1 = ERKP1 + (PHI(L,KP2)/WT(L))**2
 1240 CONTINUE
      ERKP1 = ABSH*GSTR(KP1)*SQRT(ERKP1)
C
C     USING ESTIMATED ERROR AT ORDER K+1, DETERMINE APPROPRIATE ORDER
C     FOR NEXT STEP
C
      IF (K.GT.1) GO TO 1260
      IF (ERKP1.GE.0.5D0*ERK) GO TO 1320
      GO TO 1280
 1260 IF (ERKM1.LE.MIN(ERK,ERKP1)) GO TO 1300
      IF (ERKP1.GE.ERK .OR. K.EQ.12) GO TO 1320
C
C     HERE ERKP1 .LT. ERK .LT. AMAX1(ERKM1,ERKM2) ELSE ORDER WOULD HAVE
C     BEEN LOWERED IN BLOCK 2.  THUS ORDER IS TO BE RAISED
C
C     RAISE ORDER
C
 1280 K = KP1
      ERK = ERKP1
      GO TO 1320
C
C     LOWER ORDER
C
 1300 K = KM1
      ERK = ERKM1
C
C     WITH NEW ORDER DETERMINE APPROPRIATE STEP SIZE FOR NEXT STEP
C
 1320 HNEW = H + H
      IF (PHASE1) GO TO 1340
      IF (P5EPS.GE.ERK*TWO(K+1)) GO TO 1340
      HNEW = H
      IF (P5EPS.GE.ERK) GO TO 1340
      TEMP2 = K + 1
      R = (P5EPS/ERK)**(1.0D0/TEMP2)
      HNEW = ABSH*MAX(0.5D0,MIN(0.9D0,R))
      HNEW = SIGN(MAX(HNEW,FOURU*ABS(X)),H)
 1340 H = HNEW
      RETURN
C       ***     END BLOCK 4     ***
C
C
C     END OF D02QFQ (STEPS)
C
C
      END
