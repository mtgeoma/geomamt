      SUBROUTINE D01JAF(F,N,RADIUS,EPSA,EPSR,METHOD,ICOORD,RESULT,
     *                  ESTERR,EVALS,IFAIL)
C     MARK 10 RELEASE. NAG COPYRIGHT 1982.
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C
C     **************************************************************
C
C     AUTOMATIC INTEGRATION OVER A SPHERE
C     -----------------------------------
C
C     STANDARD FORTRAN SUBROUTINE
C
C     PURPOSE
C     -------
C
C     THE ROUTINE CALCULATES AN APPROXIMATION RESULT TO THE
C     INTEGRAL
C
C     J = I ... I F(X1, ..., XN) DX1 ... DXN
C            S
C
C     WHERE S IS THE HYPERSPHERE (X1**2 + ...XN**2)**0.5.LE.RADIUS.
C     THE INTEGRAND FUNCTION MAY ALSO BE DEFINED IN SPHERICAL
C     COORDINATES (SEE PARAMETER ICOORD).
C
C     IF EVERYTHING GOES WELL,
C       ABS(RESULT-J).LE.MAX(EPSA,EPSR*ABS(J)).
C
C     PARAMETERS
C     ----------
C
C     ON ENTRY
C     --------
C     F      - REAL FUNCTION, SUPPLIED BY THE USER, IT
C              EVALUATES THE INTEGRAND AT THE POINT (X(1),...,X(N))
C              (IN CARTESIAN COORDINATES) OR (RO,THETA(1),...,
C              THETA(N-1)) (IN SPHERICAL COORDINATES) (SEE
C              PARAMETER ICOORD). F MUST BE DECLARED EXTERNAL
C              IN THE CALLING (SUB)PROGRAM.
C              CARE SHOULD BE TAKEN TO AVOID UNDERFLOW AND/OR
C              OVERFLOW PROBLEMS IN THE INTEGRAND FUNCTION
C              SUBPROGRAM, BECAUSE SOME OF THE INTEGRATION NODES
C              USED BY D01JAF ARE VERY CLOSE TO THE SURFACE
C              OR TO THE CENTRE OF THE SPHERE.
C              F IS SPECIFIED AS
C
C                    REAL FUNCTION F(N,X)
C              C     INTEGER N
C              C     REAL X(N)
C
C     N      - DIMENSION OF THE SPHERE (N.LE.4, FOR N.GT.4 SEE
C              DIMENSION INFORMATION BELOW)
C
C     RADIUS - RADIUS OF THE SPHERE
C
C     EPSA   - REQUESTED ABSOLUTE ACCURACY
C
C     EPSR   - REQUESTED RELATIVE ACCURACY
C
C              THE ROUTINE ATTEMPTS TO CALCULATE AN APPROXIMATION
C              RESULT TO THE INTEGRAL J, HOPEFULLY SATISFYING
C              ABS(RESULT-J).LE.MAX(EPSA,EPSR*ABS(J)).
C
C     METHOD - KEY FOR CHOOSING THE TRANSFORMATION TO BE
C              USED BY THE ROUTINE, DEPENDING ON THE BEHAVIOUR OF
C              THE INTEGRAND FUNCTION AND THE REQUESTED ACCURACY
C              - DEFAULT VALUE METHOD = 0
C              - WELL-BEHAVED FUNCTION OR FUNCTION WITH SINGULARITY
C                ONLY ON THE SURFACE OF THE SPHERE-
C                         - LOW  ACCURACY REQUESTED, METHOD = 1
C                         - HIGH ACCURACY REQUESTED, METHOD = 2
C              - FUNCTION WITH STRONG SINGULARITY ON THE SURFACE-
C                         - LOW  ACCURACY REQUESTED, METHOD = 3
C                         - HIGH ACCURACY REQUESTED, METHOD = 4
C                IN THIS CASE THE INTEGRAND MUST BE DEFINED IN THE
C                SPECIAL SPHERICAL COORDINATES (SEE ICOORD).
C              - FUNCTION WITH SINGULARITY IN THE CENTRE OF THE
C                SPHERE (SINGULARITY ON THE SURFACE IS ALLOWED
C                AS WELL)-
C                         - LOW  ACCURACY REQUESTED, METHOD = 5
C                         - HIGH ACCURACY REQUESTED, METHOD = 6
C              WHEN METHOD = 0, EPSR.LE.1.E-6 IS CONSIDERED AS A
C              HIGH, EPSR.GT.1.E-6 AS A LOW ACCURACY. HOWEVER, THE
C              VALUE OF EPSR WHICH DISTINGUISHES HIGH FROM LOW
C              TOLERANCES DEPENDS ALSO ON THE INTEGRAND. WHEN USING
C              METHOD.GT.0, THIS VALUE MAY IN GENERAL BE DECREASED
C              WHEN THE INTEGRAND IS SMOOTH, INCREASED WHEN IT
C              IS BADLY BEHAVED.
C
C     ICOORD - INDICATES WHICH KIND OF COORDINATES
C              ARE USED IN THE FUNCTION SUBPROGRAM F(N,X)-
C              ICOORD = 0- X(I) I = 1...N- CARTESIAN COORDINATES
C              ICOORD = 1- X- SPHERICAL COORDINATES-
C                          X(1) = RO
C                          X(I) = THETA(I-1)   I = 2...N
C              ICOORD = 2- IF METHOD IS SET TO 3 OR 4, THE USER HAS
C                          TO DEFINE THE FUNCTION IN SPHERICAL
C                          COORDINATES, WITH THE ADDITIONAL
C                          TRANSFORMATION RO = RADIUS - LAMBDA.
C                          IN THIS CASE THE ROUTINE DOES ITS
C                          COMPUTATIONS WITH LAMBDA INSTEAD OF WITH
C                          RO, AND THUS
C                          X(1) = LAMBDA
C                          X(I) = THETA(I-1)   I = 2...N.
C                          THE USER HAS TO TAKE CARE THAT THE
C                          FUNCTION SUBPROGRAM DOES NOT CONTAIN
C                          EXPRESSIONS OF THE FORM
C                          RADIUS - LAMBDA.
C              REMARKS   - THE CARTESIAN COORDINATES ARE RELATED
C                          TO THE SPHERICAL COORDINATES BY
C                          X(1) = RO*SIN(THETA(1))*...
C                                   *SIN(THETA(N-2))*SIN(THETA(N-1))
C                          X(2) = RO*SIN(THETA(1))*...
C                                   *SIN(THETA(N-2))*COS(THETA(N-1))
C                          X(3) = RO*SIN(THETA(1))*...
C                                                   *COS(THETA(N-2))
C                          X(N) = RO*COS(THETA(1))
C                          WHERE  0.LT.THETA(I).LE.PI   I = 1...N-2
C                                 0.LT.THETA(N-1).LE.2.E0*PI
C
C     ON EXIT
C     -------
C     RESULT - APPROXIMATION TO THE INTEGRAL
C
C     ESTERR - ESTIMATE OF THE (MODULUS OF THE) ABSOLUTE ERROR
C
C     EVALS  - NUMBER OF FUNCTION EVALUATIONS NEEDED TO OBTAIN
C              THE RESULT
C
C     IFAIL  - ERROR FLAG
C              IFAIL= 0- NORMAL AND RELIABLE TERMINATION OF THE
C                        ROUTINE, IT IS ASSUMED THAT THE TOLERANCE
C                        CRITERIA HAVE BEEN SATISFIED.
C              IFAIL= 1- THE REQUESTED ACCURACY CANNOT BE ACHIEVED
C                        WITHIN A LIMITING NUMBER OF FUNCTION
C                        EVALUATIONS (WHICH IS SET BY THE ROUTINE).
C              IFAIL= 2- THE PRESENCE OF ROUNDOFF ERROR PREVENTS
C                        THE REQUESTED ACCURACY FROM BEING OBTAINED.
C              IFAIL= 3- THE MAXIMUM ACCURACY WITH RESPECT TO THE
C                        MACHINE DEPENDENT CONSTANTS EPMACH AND
C                        UFLOW HAS BEEN ACHIEVED. IF THIS MAXIMUM
C                        ACCURACY IS RATHER LOW, IFAIL=3 MEANS THAT
C                        A SEVERE SINGULARITY ON THE BOUNDARY OR
C                        AT THE CENTRE OF THE SPHERE PREVENTS THE
C                        REQUESTED ACCURACY FROM BEING ACHIEVED.
C                        IF METHOD.LT.3, SETTING  METHOD=3 OR 4 MAY
C                        HELP.
C              IFAIL= 4- THE INPUT IS INVALID. NO CALCULATIONS HAVE
C                        BEEN PERFORMED (RESULT AND ESTERR ARE SET
C                        TO 0). THIS OCCURS WHEN
C                            N.LT.2 OR.GT.4,
C                         OR METHOD.LT.0 OR.GT.6,
C                         OR ICOORD.LT.0 OR.GT.2,
C                         OR METHOD.NE.3 OR 4  AND ICOORD = 2,
C                         OR METHOD = 3 OR 4 AND ICOORD.NE.2,
C                         OR RADIUS .LT. 0.0.
C
C     SUBPROGRAMS CALLED
C     ------------------
C
C         - D01JAY
C         - D01JAZ - D01JAX
C                  - D01JAW
C
C     DIMENSION INFORMATION
C     ---------------------
C
C     TO USE THE ROUTINE FOR INTEGRATION OVER A SPHERE
C     OF DIMENSION NDIM.GT.4, SET THE SIZE OF ALL THE
C     ARRAYS IN THE ROUTINES D01JAF, D01JAZ, D01JAX AND D01JAW
C     TO NDIM. FURTHERMORE DELETE THE TEST ON THE VALIDITY OF INPUT
C     PARAMETER N.
C
C     MACHINE DEPENDENT CONSTANTS
C     ---------------------------
C
C     EPMACH IS THE RELATIVE MACHINE ACCURACY.
C     UFLOW  IS ABOUT EQUAL TO, BUT MUST NOT BE LESS THAN
C              THE SMALLEST POSITIVE REAL NUMBER REPRESENTABLE
C              BY THE MACHINE.
C
C     RMAX, RMIN AND RMID WILL BE CALCULATED AS FUNCTIONS OF THE
C     ABOVE CONSTANTS. THEIR VALUES CAN INFLUENCE THE PERFORMANCE
C     OF THE ROUTINE CONSIDERABLY.
C
C     LABELLED COMMON AREAS
C     ---------------------
C
C         - AD01JA
C         - BD01JA
C         - CD01JA
C
C     LIST OF MAJOR VARIABLES
C     -----------------------
C
C     X      - THE CARTESIAN COORDINATES OF A GRID POINT
C
C     ABSCIS - THE CARTESIAN OR SPHERICAL COORDINATES
C              OF THE INTEGRATION NODE IN THE ORIGINAL REGION,
C              CORRESPONDING TO X
C
C     R      - DISTANCE FROM THE CENTRE
C
C     RO     - DISTANCE FROM THE CENTRE IN THE ORIGINAL REGION,
C              CORRESPONDING TO R
C
C     IRAD2  - INPUT PARAMETER OF THE ROUTINE D01JAZ, IRAD2*H = R**2
C
C     ITRANS - CODE FOR THE TRANSFORMATION TO BE USED, THE
C              VALUE OF ITRANS IS DETERMINED BY THE INPUT PARAMETERS
C              METHOD AND EPSR.
C
C     EPSLIM - CRITICAL VALUE OF EPSR FOR CHOICE OF THE
C              TRANSFORMATION WHEN METHOD = 0
C
C     WEIGHT - THE JACOBIAN OF THE TRANSFORMATION IN THE GRID POINTS
C              AT DISTANCE R EQUALS WEIGHT * RADIUS**N.
C
C     RMAX   - IF R.GT.RMAX- RADIUS*(1-EPMACH).LE.R0.LE.RADIUS, AND
C              /OR TO PREVENT UNDERFLOW DURING THE CALCULATION OF
C              THE WEIGHT.
C
C     RMIN   - IF METHOD = 5 OR 6 AND R.LT.RMIN, UNDERFLOW OCCURS
C              DURING THE CALCULATION OF THE WEIGHT.
C
C     RMID   - IF R = RMID, THEN RO = RMAX / 2.
C
C     BREAK1,- THE TRANSFORMED INTEGRAND IS NEGLIGIBLE WHEN
C     BREAK2   R.GT.BREAK1 OR R.LT.BREAK2.
C
C     TMIN   - USED TO DETERMINE BREAK1 AND BREAK2
C
C     SAVE   - SAVEGUARD WITH RESPECT TO TRUNCATION ERROR
C
C     H      - STEPLENGTH USED IN EACH DIRECTION IN THE TRAPEZOIDAL
C              RULE
C
C     HFAK   - THE INITIAL STEPLENGTH IS HFAK * RMAX / 2.
C
C     ITRMAX - DETERMINES THE MAXIMUM NUMBER OF FUNCTION
C              EVALUATIONS, THE STEPLENGTH H CANNOT BE HALVED
C              MORE THAN ITRMAX TIMES.
C
C     ERREXT - EXTRAPOLATED ERROR ESTIMATE
C
C     RESFOR - APPROXIMATION TO THE INTEGRAL IN THE PREVIOUS
C              STEP
C
C     ERRDIF - SIMPLE ERROR ESTIMATE (=ABS(RESULT-RESFOR))
C
C     ERREXT - EXTRAPOLATED ERROR ESTIMATE
C
C     ERTRUN - TRUNCATION ERROR ESTIMATE
C
C     RTRUN1 - GREATEST R (LESS THAN RMAX) USED IN THE PREVIOUS
C              STEP
C
C     RTRUN2 - IF METHOD=5 OR 6, THE SMALLEST R (GREATER THAN RMIN)
C              USED IN THE PREVIOUS STEP
C
C     STRUN1 - USED TO DETERMINE THE TRUNCATION ERROR ESTIMATE
C
C     STRUN2 - USED TO DETERMINE THE TRUNCATION ERROR ESTIMATE
C
C     SRAHN  - USED TO COMPUTE TMIN- IN EACH STEP,
C              SRAHN = SAVE / (RADIUS * H)**N.
C
C     **************************************************************
C
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D01JAF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  EPSA, EPSR, ESTERR, RADIUS, RESULT
      INTEGER           EVALS, ICOORD, IFAIL, METHOD, N
C     .. Function Arguments ..
      DOUBLE PRECISION  F
      EXTERNAL          F
C     .. Scalars in Common ..
      DOUBLE PRECISION  H, PI
      INTEGER           INDEX, INDNN, INOG, IREST, ITEL, ITELMX, NDIM,
     *                  NMIN, NPLUS
C     .. Arrays in Common ..
      DOUBLE PRECISION  Y(4)
      INTEGER           IX(4), IX2(4), NOTNUL(4)
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSTOL, ALFA, BETA, BREAK1, BREAK2, CONST,
     *                  EPMACH, EPSLIM, ERRDIF, ERREXT, ERTRUN, ESTFOR,
     *                  ETRFOR, FUN, HFAK, R, R2, RELACC, RELTOL,
     *                  RESFOR, RLAST, RMAX, RMID, RMIN, RO, RSAVE,
     *                  RTLABS, RTRUN1, RTRUN2, SABWEI, SAVE, SOM,
     *                  SOMABS, SOMRAD, SRAHN, STRUN1, STRUN2, SWLST1,
     *                  SWLST2, TMIN, TMIN1, TOLERR, TRRATE, UFLOW,
     *                  VERM, WEIGHT
      INTEGER           I, IBREAK, IDELTA, IERR, IFF, IMIN, IRAD2,
     *                  IRMID, ISFER, ITRANS, ITRAP, ITRMAX, J, NMI,
     *                  NPTR
C     .. Local Arrays ..
      DOUBLE PRECISION  ABSCIS(4), HF(3,2), X(4)
      INTEGER           ITR(3,2)
      CHARACTER*1       P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  S09ABF, X01AAF, X02AJF, X02AMF
      INTEGER           P01ABF
      EXTERNAL          S09ABF, X01AAF, X02AJF, X02AMF, P01ABF
C     .. External Subroutines ..
      EXTERNAL          D01JAY, D01JAZ
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, LOG, DBLE, SIN, SQRT
C     .. Common blocks ..
      COMMON            /AD01JA/H, Y, ITEL, ITELMX, NOTNUL, INDNN
      COMMON            /BD01JA/NDIM, NMIN, NPLUS, IX, IX2, INDEX, INOG,
     *                  IREST
      COMMON            /CD01JA/PI
C     .. Data statements ..
      DATA              EPSLIM/1.D-6/, SAVE/1.D-2/
      DATA              ITR(1,1)/6/, ITR(2,1)/4/, ITR(3,1)/4/,
     *                  ITR(1,2)/6/, ITR(2,2)/5/, ITR(3,2)/4/
      DATA              HF(1,1)/1.D0/, HF(2,1)/1.D0/, HF(3,1)/1.6D0/,
     *                  HF(1,2)/1.D0/, HF(2,2)/1.42D0/, HF(3,2)/1.42D0/
C     .. Executable Statements ..
      PI = X01AAF(0.0D0)
      EPMACH = X02AJF()
      UFLOW = X02AMF()
      IF (N.GT.4) GO TO 720
      IF (N.LT.2 .OR. METHOD.LT.0 .OR. METHOD.GT.6 .OR. ICOORD.LT.0 .OR.
     *    ICOORD.GT.2) GO TO 720
      IF ((METHOD.NE.3 .AND. METHOD.NE.4 .AND. ICOORD.EQ.2)
     *    .OR. ((METHOD.EQ.3 .OR. METHOD.EQ.4) .AND. ICOORD.NE.2))
     *    GO TO 720
      IF (RADIUS.LT.0.0D0) GO TO 720
      IERR = 0
      IF (RADIUS.EQ.0.0D0) GO TO 740
      NDIM = N
      NMIN = N - 1
      NPLUS = N + 1
C
C     RESET RELATIVE TOLERANCE IF IT IS TOO SMALL
C
      RELACC = EPMACH*1.D1
      ABSTOL = ABS(EPSA)
      RELTOL = ABS(EPSR)
      IF (RELTOL.LT.RELACC) RELTOL = RELACC
C
C     ITRMAX IS SET TO ITR(N-1,1) IF EPSR.GT.EPSLIM,
C                   TO ITR(N-1,2) IF EPSR.LE.EPSLIM.
C     HFAK IS SET TO HF(N-1,1) IF EPSR.GT.EPSLIM,
C                 TO HF(N-1,2) IF EPSR.LE.EPSLIM.
C
      I = NMIN
C     IF(N.GT.4) I = 3
      J = 1
      IF (RELTOL.LE.EPSLIM) J = 2
      ITRMAX = ITR(I,J)
      HFAK = HF(I,J)
C
C     SELECT TRANSFORMATION AND INITIALIZE VARIABLES
C
      ITRANS = METHOD
      IF (METHOD.EQ.5 .OR. METHOD.EQ.6) GO TO 60
      CONST = 5.D0
      IF (N.EQ.4) CONST = 3.D0
      RMID = 0.D0
      RMIN = 0.D0
      IF (METHOD.EQ.3 .OR. METHOD.EQ.4) GO TO 40
      IF (METHOD.NE.0) GO TO 20
      ITRANS = 1
      IF (RELTOL.LE.EPSLIM) ITRANS = 2
   20 ALFA = LOG(2.D0/EPMACH)/PI
      RMAX = LOG(ALFA+SQRT(ALFA*ALFA+1.D0))
      IF (ITRANS.EQ.2) GO TO 100
      ALFA = CONST*0.5D0/RMAX
      RMAX = -ALFA + SQRT(ALFA*ALFA+1.D0)
      GO TO 100
   40 ALFA = UFLOW*1.D3
      ALFA = LOG(2.D0/ALFA)/PI
      RMAX = LOG(ALFA+SQRT(ALFA*ALFA+1.D0))
      IF (ITRANS.EQ.4) GO TO 100
      ALFA = CONST*0.5D0/RMAX
      RMAX = SQRT(ALFA*ALFA+1.D0) - ALFA
      GO TO 100
   60 CONST = 1.D0
      ALFA = -LOG(EPMACH)/PI
      BETA = LOG(ALFA+SQRT(ALFA*ALFA+1.D0))
      IF (ITRANS.EQ.5) RMAX = 1.D0 - CONST*0.5D0/BETA
      IF (ITRANS.EQ.6) RMAX = 2.D0*BETA/CONST - 1.D0
      RMID = RMAX*0.5D0
      ALFA = LOG(UFLOW)/(PI*DBLE(N))
      BETA = LOG(ALFA+SQRT(ALFA*ALFA+1.D0))
      IF (ITRANS.EQ.6) GO TO 80
      ALFA = CONST - BETA
      RMIN = (-ALFA+SQRT(ALFA*ALFA+4.D0*RMID*CONST*BETA))*0.5D0/BETA
      GO TO 100
   80 ALFA = (RMID+BETA/CONST-1.D0)*0.5D0
      RMIN = ALFA + SQRT(ALFA*ALFA+RMID)
  100 ISFER = 0
      IF (ICOORD.GT.0) ISFER = 1
C
C     PERFORM THE TRANSFORMATION.
C
      IF (ITRANS.GE.5) GO TO 140
      H = RMAX*HFAK
      CALL D01JAY(0.D0,0.D0,RO,WEIGHT,N,NMIN,RADIUS,ITRANS,CONST,RMID)
      DO 120 I = 1, N
         ABSCIS(I) = 0.D0
  120 CONTINUE
      IF (ISFER.EQ.1) ABSCIS(1) = RO
      RESFOR = (RADIUS*H)**N*F(N,ABSCIS)*WEIGHT
      EVALS = 1
      H = H*0.5D0
      GO TO 160
  140 H = RMID*HFAK
      RESFOR = 0.D0
      EVALS = 0
  160 SRAHN = SAVE/(RADIUS*H)**N
      TMIN = 0.D0
      BREAK1 = RMAX
      BREAK2 = RMIN
      RTRUN1 = RMAX
      RTRUN2 = RMIN
      SWLST2 = 0.0D0
      ITRAP = 1
      IRMID = 1
C
C     START THE CALCULATION OF RESULT.
C
  180 SOM = 0.D0
      STRUN1 = 0.0D0
      STRUN2 = 0.0D0
      IBREAK = 0
      IRAD2 = 0
      IF (ITRANS.GE.5) IRAD2 = IRMID - 1
      IDELTA = 1
  200 IRAD2 = IRAD2 + IDELTA
      R2 = H*H*DBLE(IRAD2)
      R = SQRT(R2)
      IF (R.GE.BREAK1) GO TO 460
      IF (R.LE.BREAK2) GO TO 480
C
C     TREAT ALL THE POINTS AT DISTANCE R OF THE CENTRE OF THE
C     SPHERE.
C
      SOMRAD = 0.D0
      SOMABS = 0.D0
      NPTR = 0
C
C     INITIALIZE THE VARIABLES INDEX, INOG AND ITEL USED IN THE
C     ROUTINES D01JAZ, D01JAX AND D01JAW.
C
      INDEX = 0
      INOG = 1
      ITEL = 0
C
      CALL D01JAZ(IRAD2,X)
      IF (INOG.EQ.0) GO TO 200
      RSAVE = R
      CALL D01JAY(R,R2,RO,WEIGHT,N,NMIN,RADIUS,ITRANS,CONST,RMID)
      VERM = RO/R
C
C     CALCULATE THE (CARTESIAN OR SPHERICAL) COORDINATES OF THE GRID
C     POINT IN THE ORIGINAL SPHERE, CORRESPONDING TO THE POINT
C     (X(1),...,X(N)).
C
  220 IF (ISFER.EQ.1) GO TO 260
C     CARTESIAN COORDINATES
      DO 240 I = 1, N
         ABSCIS(I) = VERM*X(I)
  240 CONTINUE
      GO TO 380
C     SPHERICAL COORDINATES
  260 ABSCIS(1) = RO
      DO 320 I = 2, N
         IMIN = I - 1
         NMI = N - IMIN + 1
         ABSCIS(I) = X(NMI)/R
         IF (IMIN.EQ.1) GO TO 300
         DO 280 J = 2, IMIN
            ABSCIS(I) = ABSCIS(I)/SIN(ABSCIS(J))
  280    CONTINUE
  300    IF (ABS(ABSCIS(I)).GE.1.D0) GO TO 340
         IFF = 0
         ABSCIS(I) = S09ABF(ABSCIS(I),IFF)
  320 CONTINUE
      IF (X(1).LT.0.0D0) ABSCIS(N) = 2.0D0*PI - ABSCIS(N)
      GO TO 380
  340 IF (ABSCIS(I).GE.1.0D0) ABSCIS(I) = 0.0D0
      IF (ABSCIS(I).LE.-1.0D0) ABSCIS(I) = PI
      IF (I.EQ.N) GO TO 380
      J = I + 1
      DO 360 I = J, N
         ABSCIS(I) = 0.D0
  360 CONTINUE
  380 FUN = F(N,ABSCIS)
      NPTR = NPTR + 1
      SOMRAD = SOMRAD + FUN
      SOMABS = SOMABS + ABS(FUN)
      CALL D01JAZ(IRAD2,X)
      IF (INOG.NE.0) GO TO 220
      SOM = SOM + SOMRAD*WEIGHT
      EVALS = EVALS + NPTR
      SABWEI = SOMABS*WEIGHT
      IF (ITRAP.LT.3) GO TO 400
      IF (R.GT.RTRUN1) STRUN1 = STRUN1 + SABWEI
      IF (R.LT.RTRUN2) STRUN2 = STRUN2 + SABWEI
C
C     ALL THE GRID POINTS AT DISTANCE R HAVE BEEN TREATED.
C     IF THE VALUE OF THE TRANSFORMED INTEGRAND IS NEGLIGIBLE, THE
C     SCANNING IS STOPPED, OTHERWISE THE GRID POINTS AT DISTANCE
C     GREATER THAN R ARE TREATED.
C
  400 IF (SABWEI.GE.TMIN) GO TO 420
      IF (IDELTA.EQ.1 .AND. R.LT.7.D-1*BREAK1) GO TO 420
      IBREAK = IBREAK + 1
      IF (IBREAK.EQ.2) GO TO 440
      RLAST = R
      GO TO 200
  420 IBREAK = 0
      GO TO 200
  440 IF (IDELTA.EQ.(-1)) GO TO 480
  460 IF (IBREAK.NE.0 .AND. ITRAP.NE.1) BREAK1 = RLAST
      RTRUN1 = RSAVE
      SWLST1 = SABWEI
      IF (ITRANS.LE.4) GO TO 500
      IDELTA = -1
      IBREAK = 0
      IRAD2 = IRMID
      GO TO 200
  480 IF (IBREAK.NE.0 .AND. ITRAP.NE.1) BREAK2 = RLAST
      RTRUN2 = RSAVE
      SWLST2 = SABWEI
  500 RESULT = RESFOR*0.5D0**N + SOM*(H*RADIUS)**N
C
C     COMPUTE THE ERROR ESTIMATE ESTERR, APPLYING TO THE
C     APPROXIMATION WITH MESH SIZE H.
C
      IF (ITRAP.EQ.1) GO TO 700
      TOLERR = ABSTOL
      RTLABS = RELTOL*ABS(RESULT)
      IF (TOLERR.LT.RTLABS) TOLERR = RTLABS
C
C     COMPUTE THE SIMPLE ERROR ESTIMATE ERRDIF
C             THE EXTRAPOLATED ERROR ESTIMATE ERREXT
C             THE TRUNCATION ERROR ESTIMATE ERTRUN
C
      ERRDIF = ABS(RESULT-RESFOR)
      IF (ITRAP.GE.3) GO TO 520
C
C     IF ITRAP=2, THE ERROR ESTIMATE ESTERR=MAX(ERRDIF,ERTRUN)
C
      ERTRUN = (SWLST1+SWLST2)*(H*RADIUS)**N
      ESTERR = ERRDIF
      IF (ERRDIF.LE.RELACC*RESULT) GO TO 620
      IF (ERRDIF.LT.ERTRUN) ESTERR = ERTRUN
      IF (ESTERR.LE.TOLERR) GO TO 620
      GO TO 700
C
  520 ERREXT = ERRDIF*ERRDIF/ESTFOR
      ERTRUN = (STRUN1+STRUN2)*(H*RADIUS)**N
      R = ETRFOR*0.5D0**N
      IF (R.GT.ERTRUN) GO TO 540
      ERTRUN = ERTRUN + R
      GO TO 560
  540 ERTRUN = (SWLST1+SWLST2)*(H*RADIUS)**N
C
C     COMPUTE ESTERR
C
  560 IF (BREAK1.LT.RMAX .AND. (BREAK2.GT.RMIN .OR. ITRANS.LE.4))
     *    GO TO 600
C
C     THE TRUNCATION ERROR MAY PREVENT THE REQUESTED ACCURACY
C     FROM BEING ACHIEVED
C
      IF (ERRDIF.LT.ERTRUN) GO TO 580
      ESTERR = ERREXT
      IF (ERREXT.LT.ERTRUN) ESTERR = ERTRUN
      IF (ESTERR.LE.TOLERR) GO TO 620
      IF (ERRDIF.GE.ESTFOR .OR. ERTRUN.GE.ETRFOR) GO TO 660
      GO TO 680
  580 ESTERR = ERTRUN
      IF (ESTERR.LE.TOLERR) GO TO 620
C
C     ASSUME THAT THE REQUESTED ACCURACY CANNOT BE ACHIEVED
C
      IERR = 3
      GO TO 760
C
C     THE TRUNCATION ERROR MAY BE NEGLECTED AGAINST THE PROPER
C     ERROR OF THE QUADRATURE FORMULA
C
  600 ESTERR = ERREXT
      IF (ERREXT.GT.TOLERR) GO TO 640
      ESTERR = TOLERR
      IF (ERRDIF.LT.TOLERR) ESTERR = ERRDIF
C
C     REQUESTED ACCURACY ACHIEVED
C     COMPUTE FINAL ERROR ESTIMATE, ESTERR, AND EXIT
C
  620 IF (ESTERR.GT.RELACC*ABS(RESULT)) GO TO 760
      ESTERR = RELACC*ABS(RESULT)
      TOLERR = ABSTOL
      RTLABS = ABS(EPSR*RESULT)
      IF (TOLERR.LT.RTLABS) TOLERR = RTLABS
      IF (ESTERR.GT.TOLERR) IERR = 2
      GO TO 760
C
C     REQUESTED ACCURACY NOT ACHIEVED,
C     TEST TO DETECT ROUNDOFF ERROR.
C
  640 IF (ERRDIF.LT.ESTFOR) GO TO 680
  660 IF (RESULT.EQ.0.D0) GO TO 680
      TRRATE = RESULT/RESFOR
      IF (TRRATE.LT.0.999D0 .OR. TRRATE.GT.1.001D0) GO TO 680
C
C     ROUNDOFF ERROR DETECTED, SET RESULT TO RESFOR AND EXIT.
C
      RESULT = RESFOR
      IERR = 2
      IF (BREAK1.EQ.RMAX) IERR = 3
      GO TO 760
C
C     CHECK WHETHER THE LIMITING NUMBER OF STEPS HAS BEEN
C     REACHED.
C
  680 IF (ITRAP.LT.ITRMAX) GO TO 700
      IERR = 1
      IF (BREAK1.EQ.RMAX) IERR = 3
      GO TO 760
C
C     NEW APPROXIMATION NEEDS TO BE CALCULATED, RESET VARIABLES.
C
  700 H = H*0.5D0
      IRMID = IRMID*4
      RESFOR = RESULT
      IF (ITRAP.GT.1) ESTFOR = ERRDIF
      IF (ITRAP.GT.1) ETRFOR = ERTRUN
      ITRAP = ITRAP + 1
      SRAHN = SRAHN*2.D0**N
      TMIN = ABSTOL*SRAHN
      TMIN1 = RELTOL*ABS(RESULT)*SRAHN
      IF (TMIN.LT.TMIN1) TMIN = TMIN1
      GO TO 180
  720 IERR = 4
  740 EVALS = 0
      RESULT = 0.D0
      ESTERR = 0.D0
  760 IFAIL = P01ABF(IFAIL,IERR,SRNAME,0,P01REC)
      RETURN
      END
