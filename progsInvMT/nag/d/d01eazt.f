      SUBROUTINE D01EAZ(NDIM,A,B,MINCLS,MAXCLS,NFUN,FUNSUB,ABSREQ,
     *                  RELREQ,FINEST,ABSEST,LENWRK,WORK,MXRGNS,PONTRS,
     *                  RGNERS,DVAXES,ERRORS,VALUES,LOWERS,UPPERS,
     *                  HWIDTH,ALPHA,IRCLS,IFAIL)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C     .. Scalar Arguments ..
      DOUBLE PRECISION  ABSREQ, RELREQ
      INTEGER           IFAIL, IRCLS, LENWRK, MAXCLS, MINCLS, MXRGNS,
     *                  NDIM, NFUN
C     .. Array Arguments ..
      DOUBLE PRECISION  A(NDIM), ABSEST(NFUN), ALPHA(NDIM), B(NDIM),
     *                  DVAXES(MXRGNS), ERRORS(NFUN,MXRGNS),
     *                  FINEST(NFUN), HWIDTH(NDIM), LOWERS(NDIM,MXRGNS),
     *                  PONTRS(MXRGNS), RGNERS(MXRGNS),
     *                  UPPERS(NDIM,MXRGNS), VALUES(NFUN,MXRGNS),
     *                  WORK(LENWRK)
C     .. Subroutine Arguments ..
      EXTERNAL          FUNSUB
C     .. Local Scalars ..
      DOUBLE PRECISION  ABSMAX, FINMAX, HALF, INTSGN, ONE, RLNDIM, TWO,
     *                  ZERO
      INTEGER           DIVAXN, DIVAXO, DVFLAG, FUNCLS, I1, I2, I3, I4,
     *                  IF1, IF2, IF3, IF4, IF5, IF6, IF7, IF8, IF9, J,
     *                  MXRINT, POINTR, RGNCLS, SBRGNS
C     .. Local Arrays ..
      DOUBLE PRECISION  GNRTRS(3), WEGHTS(9)
C     .. External Functions ..
      DOUBLE PRECISION  G05CAF, X02AJF
      INTEGER           X02BBF
      EXTERNAL          G05CAF, X02AJF, X02BBF
C     .. External Subroutines ..
      EXTERNAL          D01EAX, D01EAY
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, MOD, DBLE, INT
C     .. Executable Statements ..
      FUNCLS = 0
C
C     INITIALISATION OF SUBROUTINE
C
      ZERO = 0.0D0
      ONE = 1.0D0
      TWO = 2.0D0
      HALF = ONE/TWO
      MXRINT = INT(MIN(DBLE(X02BBF(ONE)),ONE/X02AJF()-ONE))
      WEGHTS(1) = ZERO
      I1 = LENWRK - 4*NDIM - 9*NFUN + 1
      I2 = I1 + NDIM
      I3 = I2 + NDIM
      I4 = I3 + NDIM
      IF1 = I4 + NDIM
      IF2 = IF1 + NFUN
      IF3 = IF2 + NFUN
      IF4 = IF3 + NFUN
      IF5 = IF4 + NFUN
      IF6 = IF5 + NFUN
      IF7 = IF6 + NFUN
      IF8 = IF7 + NFUN
      IF9 = IF8 + NFUN
      INTSGN = ONE
      DO 20 J = 1, NDIM
         IF (B(J).LT.A(J)) INTSGN = -INTSGN
   20 CONTINUE
C
C     END SUBROUTINE INITIALISATION
C
      IF (MINCLS.LT.0) THEN
         SBRGNS = WORK(LENWRK)
         GO TO 220
      END IF
C
C     WHEN MINCLS .GT. 0 DETERMINE RANDOM SUBDIVISION OF INTEGRATION
C     REGION AND APPLY BASIC RULE TO EACH SUBREGION
C
      SBRGNS = 0
      RLNDIM = NDIM
      DO 40 J = 1, NDIM
         HWIDTH(J) = ABS(B(J)-A(J))*HALF
         ALPHA(J) = ONE
   40 CONTINUE
      FUNCLS = IRCLS
   60 IF (FUNCLS*2.LE.MINCLS .AND. FUNCLS*2.LE.MXRGNS*IRCLS) THEN
         DIVAXN = RLNDIM*G05CAF(ONE) + ONE
         IF (ALPHA(DIVAXN).NE.ONE) THEN
            HWIDTH(DIVAXN) = HWIDTH(DIVAXN)*HALF
         ELSE
            ALPHA(DIVAXN) = G05CAF(ONE)
         END IF
         FUNCLS = FUNCLS*2
         GO TO 60
      END IF
      DO 80 J = 1, NDIM
         LOWERS(J,1) = MIN(A(J),B(J))
         HWIDTH(J) = ALPHA(J)*HWIDTH(J)
         UPPERS(J,1) = LOWERS(J,1) + TWO*HWIDTH(J)
   80 CONTINUE
C
C     APPLY BASIC RULE
C
  100 SBRGNS = SBRGNS + 1
      CALL D01EAX(NDIM,LOWERS(1,SBRGNS),UPPERS(1,SBRGNS),HWIDTH,NFUN,
     *            FUNSUB,GNRTRS,WEGHTS,WORK(I1),WORK(I2),WORK(I3),
     *            WORK(I4),WORK(IF1),WORK(IF2),WORK(IF3),WORK(IF4),
     *            WORK(IF5),WORK(IF6),WORK(IF7),WORK(IF8),WORK(IF9),
     *            ERRORS(1,SBRGNS),VALUES(1,SBRGNS),DIVAXN)
C
C     STORE RESULTS IN HEAP
C
      DVFLAG = 2
      CALL D01EAY(DVFLAG,SBRGNS,SBRGNS,MXRGNS,NDIM,NFUN,PONTRS,DVAXES,
     *            RGNERS,ERRORS,VALUES,FINEST,ABSEST,DIVAXN,INTSGN)
      IF (SBRGNS.NE.MXRGNS) THEN
         DO 120 J = 1, NDIM
            LOWERS(J,SBRGNS+1) = LOWERS(J,SBRGNS)
            UPPERS(J,SBRGNS+1) = UPPERS(J,SBRGNS)
  120    CONTINUE
         DO 140 J = 1, NDIM
            IF (ALPHA(J).NE.ONE) THEN
               LOWERS(J,SBRGNS+1) = UPPERS(J,SBRGNS)
               ALPHA(J) = ONE - ALPHA(J)
               HWIDTH(J) = ALPHA(J)*HWIDTH(J)/(ONE-ALPHA(J))
               UPPERS(J,SBRGNS+1) = LOWERS(J,SBRGNS+1) + TWO*HWIDTH(J)
               IF (LOWERS(J,SBRGNS+1)+HWIDTH(J).LT.MAX(A(J),B(J)))
     *             GO TO 100
               LOWERS(J,SBRGNS+1) = MIN(A(J),B(J))
               ALPHA(J) = ONE - ALPHA(J)
               HWIDTH(J) = ALPHA(J)*HWIDTH(J)/(ONE-ALPHA(J))
               UPPERS(J,SBRGNS+1) = LOWERS(J,SBRGNS+1) + TWO*HWIDTH(J)
            END IF
  140    CONTINUE
      END IF
C
C     CHECK FOR TERMINATION
C
  160 IF (FUNCLS.GE.MINCLS) THEN
         ABSMAX = ZERO
         FINMAX = ZERO
         DO 200 J = 1, NFUN
            FINEST(J) = ZERO
            ABSEST(J) = ZERO
            DO 180 POINTR = 1, SBRGNS
               ABSEST(J) = ABSEST(J) + ERRORS(J,POINTR)
               FINEST(J) = FINEST(J) + VALUES(J,POINTR)
  180       CONTINUE
            FINEST(J) = INTSGN*FINEST(J)
            IF (ABSEST(J).GT.ABSMAX) ABSMAX = ABSEST(J)
            IF (ABS(FINEST(J)).GT.FINMAX) FINMAX = ABS(FINEST(J))
  200    CONTINUE
         IF (ABSMAX.LE.RELREQ*FINMAX .OR. ABSMAX.LE.ABSREQ) THEN
            IFAIL = 0
            GO TO 300
         END IF
      END IF
C
C     PREPARE TO APPLY BASIC RULE IN EACH HALF OF SUBREGION
C     WITH LARGEST ERROR
C
  220 DVFLAG = 0
      RGNCLS = IRCLS
      POINTR = PONTRS(1)
      DO 240 J = 1, NDIM
         HWIDTH(J) = (UPPERS(J,POINTR)-LOWERS(J,POINTR))*HALF
  240 CONTINUE
      DIVAXN = DVAXES(POINTR)
      IF (DIVAXN.LE.0) THEN
         IFAIL = 2
         GO TO 300
      END IF
  260 DIVAXO = MOD(DIVAXN,NDIM+1)
      DIVAXN = DIVAXN/(NDIM+1)
      HWIDTH(DIVAXO) = HWIDTH(DIVAXO)*HALF
      RGNCLS = RGNCLS*2
      IF (DIVAXN.GT.0) GO TO 260
      IF (FUNCLS+RGNCLS.GT.MAXCLS) THEN
         IF (FUNCLS.GT.0) THEN
            IFAIL = 1
         ELSE
            IFAIL = 3
         END IF
         GO TO 300
      END IF
      IF (RGNCLS/IRCLS+SBRGNS.GT.MXRGNS) DVFLAG = 1
      FUNCLS = FUNCLS + RGNCLS
C
C     APPLY BASIC RULE IN FIRST HALF OF SUBREGION (OR WHOLE
C     SUBREGION WHEN STORAGE SPACE IS LIMITED)
C
      IF (DVFLAG.EQ.0) UPPERS(DIVAXO,POINTR) = LOWERS(DIVAXO,POINTR) +
     *    TWO*HWIDTH(DIVAXO)
      CALL D01EAX(NDIM,LOWERS(1,POINTR),UPPERS(1,POINTR),HWIDTH,NFUN,
     *            FUNSUB,GNRTRS,WEGHTS,WORK(I1),WORK(I2),WORK(I3),
     *            WORK(I4),WORK(IF1),WORK(IF2),WORK(IF3),WORK(IF4),
     *            WORK(IF5),WORK(IF6),WORK(IF7),WORK(IF8),WORK(IF9),
     *            ERRORS(1,POINTR),VALUES(1,POINTR),DIVAXN)
      IF (INT(DVAXES(POINTR))+1.GT.MXRINT/(NDIM+1)) DVAXES(POINTR) = -1
      IF (DVFLAG.EQ.1) DIVAXN = DIVAXN + (NDIM+1)*INT(DVAXES(POINTR))
C
C     STORE RESULTS IN HEAP FROM TOP DOWN
C
      CALL D01EAY(DVFLAG,SBRGNS,POINTR,MXRGNS,NDIM,NFUN,PONTRS,DVAXES,
     *            RGNERS,ERRORS,VALUES,FINEST,ABSEST,DIVAXN,INTSGN)
      IF (DVFLAG.NE.1) THEN
C
C        APPLY BASIC RULE IN SECOND HALF OF SUBREGION (WHEN STORAGE
C        SPACE IS AVAILABLE)
C
         SBRGNS = SBRGNS + 1
         DO 280 J = 1, NDIM
            LOWERS(J,SBRGNS) = LOWERS(J,POINTR)
            UPPERS(J,SBRGNS) = UPPERS(J,POINTR)
  280    CONTINUE
         LOWERS(DIVAXO,SBRGNS) = UPPERS(DIVAXO,SBRGNS)
         UPPERS(DIVAXO,SBRGNS) = LOWERS(DIVAXO,SBRGNS) +
     *                           TWO*HWIDTH(DIVAXO)
         CALL D01EAX(NDIM,LOWERS(1,SBRGNS),UPPERS(1,SBRGNS),HWIDTH,NFUN,
     *               FUNSUB,GNRTRS,WEGHTS,WORK(I1),WORK(I2),WORK(I3),
     *               WORK(I4),WORK(IF1),WORK(IF2),WORK(IF3),WORK(IF4),
     *               WORK(IF5),WORK(IF6),WORK(IF7),WORK(IF8),WORK(IF9),
     *               ERRORS(1,SBRGNS),VALUES(1,SBRGNS),DIVAXN)
C
C        STORE RESULTS IN HEAP FROM BOTTOM UP
C
         CALL D01EAY(2,SBRGNS,SBRGNS,MXRGNS,NDIM,NFUN,PONTRS,DVAXES,
     *               RGNERS,ERRORS,VALUES,FINEST,ABSEST,DIVAXN,INTSGN)
      END IF
      GO TO 160
C
C     TERMINATION POINT
C
  300 MINCLS = FUNCLS
      WORK(LENWRK) = SBRGNS
      RETURN
      END
