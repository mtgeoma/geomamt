      DOUBLE PRECISION FUNCTION D01AHF(A,B,EPR,NPTS,RELERR,F,NL,IFAIL)
C     MARK 8 RELEASE. NAG COPYRIGHT 1979.
C     MARK 8A REVISED. IER-254 (AUG 1980).
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 12B REVISED. IER-525 (FEB 1987).
C     MARK 13 REVISED. USE OF MARK 12 X02 FUNCTIONS (APR 1988).
C     MARK 14 REVISED. IER-819 (DEC 1989).
C
C     THIS FUNCTION ROUTINE PERFORMS AUTOMATIC INTEGRATION OVER A
C     FINITE INTERVAL USING THE BASIC INTEGRATION ALGORITHMS D01AHY
C     AND D01AHX, TOGETHER WITH, IF NECESSARY, AN ADAPTIVE
C     SUBDIVISION PROCESS.
C
C     INPUT ARGUMENTS
C     ----- ----------
C     A,B     -  LOWER AND UPPER INTEGRATION LIMITS.
C     EPR     -  REQUIRED RELATIVE ACCURACY.
C     NL      -  APPROXIMATE LIMIT ON NUMBER OF INTEGRAND
C                EVALUATIONS. IF SET NEGATIVE OR ZERO THE
C                DEFAULT IS 10000.
C     F       -  THE USER NAMED AND PREPARED FUNCTION  F(X)
C                GIVES THE VALUE OF THE INTEGRAND AT X.
C     IFAIL      INTEGER VARIABLE
C             - 0  FOR HARD FAIL REPORT
C             - 1  FOR SOFT FAIL REPORT
C
C     OUTPUT ARGUMENTS
C     ------ ----------
C     NPTS    -  NUMBER OF INTEGRAND EVALUATIONS USED IN OBTAINING
C                THE RESULT.
C     RELERR  -  ROUGH ESTIMATE OF RELATIVE ACCURACY ACHIEVED.
C     IFAIL   -  VALUE INDICATES THE OUTCOME OF THE INTEGRATION -
C                IFAIL  = 0  CONVERGED
C                IFAIL  = 1  INTEGRAND EVALUATIONS EXCEEDED  NL.
C                            THE RESULT WAS OBTAINED BY CONTINUING
C                            BUT IGNORING ANY NEED TO SUBDIVIDE.
C                            RESULT LIKELY TO BE INACCURATE.
C                IFAIL  = 2  DURING THE SUBDIVISION PROCESS
C                            THE STACK BECAME FULL
C                            (PRESENTLY SET TO HOLD 20
C                            LEVELS OF INFORMATION.  MAY BE
C                            INCREASED BY  ALTERING  ISMAX
C                            AND THE DIMENSIONS OF STACK
C                            AND ISTACK). RESULT IS
C                            OBTAINED BY CONTINUING BUT
C                            IGNORING CONVERGENCE FAILURES
C                            ON INTERVALS  WHICH CANNOT BE
C                            ACCOMMODATED ON THE STACKS.
C                            RESULT LIKELY TO BE
C                            INACCURATE.
C                IFAIL  = 3  INVALID ACCURACY REQUEST.
C
C     THE SUBDIVISION STRATEGY IS AS FOLLOWS -
C     AT EACH STAGE AN INTERVAL IS PRESENTED FOR SUBDIVISION
C     (INITIALLY THE WHOLE INTERVAL). THE POINT OF SUBDIVISION IS
C     DETERMINED BY THE RELATIVE GRADIENT OF THE INTEGRAND
C     AT THE END POINTS (SEE D01AHZ) AND MAY BE IN THE
C     RATIO 1/2, 1/1 OR 2/1.D01AHY IS THEN APPLIED TO EACH
C     SUBINTERVAL.  SHOULD IT FAIL TO CONVERGE ON THE LEFT
C     SUBINTERVAL THE SUBINTERVAL IS STACKED FOR FUTURE
C     EXAMINATION AND THE RIGHT SUBINTERVAL IMMEDIATELY
C     EXAMINED. SHOULD  IT FAIL ON THE RIGHT SUBINTERVAL
C     SUBDIVISION IS IMMEDIATELY PERFORMED AND THE WHOLE
C     PROCESS REPEATED. EACH CONVERGED RESULT IS
C     ACCUMULATED AS THE PARTIAL VALUE OF THE INTEGRAL.
C     WHEN THE LEFT  AND RIGHT SUBINTERVALS BOTH CONVERGE
C     THE INTERVAL LAST STACKED IS SUBDIVIDED AND THE
C     PROCESS REPEATED.
C     A NUMBER OF REFINEMENTS ARE INCLUDED.  ATTEMPTS ARE MADE TO
C     DETECT LARGE VARIATIONS IN THE INTEGRAND AND
C     TRANSFORMATIONS ARE MADE IF ENDPOINT VARIATION IS
C     EXTREME. THIS DEPENDS ON THE RATE OF CONVERGENCE OF
C     D01AHX AND ON THE END POINT RELATIVE GRADIENTS OF THE
C     INTEGRAND FOR THE NON-SUBDIVIDED INTERVAL.  RANDOM
C     TRANSFORMATIONS ARE ALSO APPLIED TO IMPROVE THE
C     RELIABILITY.  THE  RELATIVE ACCURACY REQUESTED ON
C     EACH SUBINTERVAL IS ADJUSTED IN ACCORDANCE WITH ITS
C     LIKELY CONTRIBUTION TO THE TOTAL INTEGRAL.
C
C     .. Parameters ..
      CHARACTER*6                      SRNAME
      PARAMETER                        (SRNAME='D01AHF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 A, B, EPR, RELERR
      INTEGER                          IFAIL, NL, NPTS
C     .. Function Arguments ..
      DOUBLE PRECISION                 F
      EXTERNAL                         F
C     .. Scalars in Common ..
      DOUBLE PRECISION                 AFLOW, ALP, AV, CRATE, EPMACH,
     *                                 UFLOW
      INTEGER                          IR, MRULE, NT
C     .. Local Scalars ..
      DOUBLE PRECISION                 QSUBND
      DOUBLE PRECISION                 AMAXL, AMAXR, C2, COMP, EPS,
     *                                 EPSIL, EPSR, FACTOR, SUB1, SUB2,
     *                                 SUB3, TEST, V
      INTEGER                          IC, ICQ, IL, IS, ISI, ISMAX, IT,
     *                                 K, KK, NF, NLIM, NLIMIT, NTMAX
C     .. Local Arrays ..
      DOUBLE PRECISION                 RESULT(8), STACK(120)
      INTEGER                          ISTACK(20)
      CHARACTER*1                      P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION                 D01AHU, D01AHZ, X02AJF, X02AMF
      INTEGER                          P01ABF
      EXTERNAL                         D01AHU, D01AHZ, X02AJF, X02AMF,
     *                                 P01ABF
C     .. External Subroutines ..
      EXTERNAL                         D01AHY
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, LOG, MAX, MIN, SIGN
C     .. Common blocks ..
      COMMON                           /AD01AH/CRATE, MRULE
      COMMON                           /CD01AH/ALP, AV, NT, IR
      COMMON                           /DD01AH/EPMACH, UFLOW, AFLOW
C     .. Data statements ..
      DATA                             ISMAX, NLIM, NTMAX, TEST/116,
     *                                 10000, 10, 0.25D0/
C     .. Executable Statements ..
      IL = 3
      ICQ = IFAIL
      IF (EPR.LE.0.0D0) GO TO 220
C     EPMACH SHOULD BE SLIGHTLY LARGER THAN THE RELATIVE
C     MACHINE ACCURACY.
      EPMACH = 1.1D0*X02AJF()
C     UFLOW IS THE SMALLEST POSITIVE REAL NUMBER REPRESENTABLE
C     ON THE MACHINE WHICH CAN BE INVERTED WITHOUT OVERFLOW.
      UFLOW = X02AMF()
      AFLOW = LOG(X02AMF())
      CRATE = 0.0D0
      EPSR = EPR/10.0D0
      NLIMIT = NL
      IF (NLIMIT.LE.0) NLIMIT = NLIM
      EPSIL = MIN(EPSR,1.0D-3)
      CALL D01AHY(A,B,RESULT,K,EPSIL,NPTS,IFAIL,F,AMAXL,AMAXR,A,0)
      D01AHF = RESULT(K)
      RELERR = ABS(RESULT(K)-RESULT(K-1))
      IF (ABS(D01AHF).GT.100.0D0*UFLOW) RELERR = RELERR/D01AHF
      RELERR = MAX(RELERR,0.5D0*EPMACH)
C
C     CHECK IF SUBDIVISION IS NEEDED
      IF (IFAIL.EQ.0) RETURN
C
C     SUBDIVIDE
      EPSIL = EPSIL*0.5D0
      FACTOR = 1.0D0
      NT = 1
      RELERR = 0.0D0
      QSUBND = 0.0D0
      D01AHF = 0.0D0
      IS = 1
      ISI = 1
      IC = 1
      SUB1 = A
      SUB3 = B
   20 IF (ABS(SUB1-SUB3).LT.20.0D0*EPSIL*(ABS(SUB1)+ABS(SUB3))) THEN
         K = 1
         RESULT(K) = F((SUB1+SUB3)/2.0D0)*(SUB3-SUB1)
         COMP = 0.0D0
         NPTS = NPTS + 1
         GO TO 160
      END IF
      SUB2 = D01AHZ(SUB1,SUB3,AMAXL,AMAXR)
      EPS = MIN(0.5D-3,FACTOR*EPSIL)
C
C     PROCESS SUBINTERVAL (SUB1,SUB2)
      IT = 0
      IF (AMAXL.GT.TEST .AND. CRATE.LE.21.0D0) IT = 1
      V = AMAXR
      C2 = CRATE
      CALL D01AHY(SUB1,SUB2,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB1,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 40
      IC = SIGN(2,IC)
   40 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 100
      IF (ABS(IC).EQ.2) GO TO 100
      IF (IS.GE.ISMAX) GO TO 80
C
C     STACK SUBINTERVAL (SUB1,SUB2) FOR FUTURE EXAMINATION
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      STACK(IS) = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      IS = IS + 1
      STACK(IS) = SUB1
      IS = IS + 1
      STACK(IS) = SUB2
      IS = IS + 1
      STACK(IS) = AMAXL
      IS = IS + 1
      STACK(IS) = AMAXR
      IS = IS + 1
      STACK(IS) = CRATE
      IS = IS + 1
      KK = NT
      IF (IT.EQ.0) GO TO 60
      IF (IFAIL.EQ.4) GO TO 60
      IF (NT.GE.NTMAX) GO TO 60
      KK = NT + 1
   60 ISTACK(ISI) = KK
      ISI = ISI + 1
      GO TO 120
   80 IC = -ABS(IC)
  100 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
C
C     PROCESS SUBINTERVAL (SUB2,SUB3)
  120 IT = 0
      IF (V.GT.TEST .AND. C2.LE.21.0D0) IT = 1
      CALL D01AHY(SUB2,SUB3,RESULT,K,EPS,NF,IFAIL,F,AMAXL,AMAXR,SUB3,IT)
      NPTS = NPTS + NF
      IF (NPTS.LE.NLIMIT) GO TO 140
      IC = SIGN(2,IC)
  140 COMP = ABS(RESULT(K)-RESULT(K-1))
      IF (IFAIL.EQ.0) GO TO 160
      IF (ABS(IC).EQ.2) GO TO 160
C
C     SUBDIVIDE INTERVAL (SUB2,SUB3)
      IF (IT.EQ.1 .AND. IFAIL.NE.4) NT = NT + 1
      SUB1 = SUB2
      IF (RESULT(K).EQ.0.0D0) RESULT(K) = D01AHF
      FACTOR = MAX(1.0D0,ABS(D01AHF/RESULT(K))*0.1D0)
      GO TO 20
  160 QSUBND = QSUBND + RESULT(K)
      D01AHF = QSUBND
      RELERR = RELERR + COMP
      IF (IS.EQ.1) GO TO 180
C
C     SUBDIVIDE THE DELINQUENT INTERVAL LAST STACKED
      ISI = ISI - 1
      NT = ISTACK(ISI)
      IS = IS - 1
      CRATE = STACK(IS)
      IS = IS - 1
      AMAXR = STACK(IS)
      IS = IS - 1
      AMAXL = STACK(IS)
      IS = IS - 1
      SUB3 = STACK(IS)
      IS = IS - 1
      SUB1 = STACK(IS)
      IS = IS - 1
      FACTOR = STACK(IS)
      GO TO 20
C
C     SUBDIVISION RESULT
  180 IF (ABS(D01AHF).GT.100.0D0*UFLOW)
     *    RELERR = ABS(RELERR/D01AHU(D01AHF))
      RELERR = MAX(RELERR,0.5D0*EPMACH)
      IF (IC.NE.1) GO TO 200
      IFAIL = 0
      RETURN
  200 IL = 2
      IF (IC.LT.0) GO TO 220
      IL = 1
  220 IFAIL = P01ABF(ICQ,IL,SRNAME,0,P01REC)
      RETURN
      END
