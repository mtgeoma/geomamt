      SUBROUTINE D02NNF(NEQ,NEQMAX,T,TOUT,Y,YDOTI,RWORK,RTOL,ATOL,ITOL,
     *                  INFORM,YSAVE,NY2DIM,WKJAC,NWKJAC,JACPVT,NJCPVT,
     *                  IMON,INLN,IRES,IREVCM,LDERIV,ITASK,JTRACE,IFAIL)
C     MARK 14 RE-ISSUE. NAG COPYRIGHT 1989.
C     MARK 15A REVISED. IER-938 (APR 1991).
C     MARK 15 REVISED. IER-939 (APR 1991).
C     MARK 16A REVISED. IER-977 (JUN 1993).
C     MARK 17 REVISED. IER-1545 (JUN 1995).
C     VP CHANGED OCT 94
C-----------------------------------------------------------------------
C THE FOLLOWING INTERNAL COMMON BLOCKS ARE DEFINED AS FOLLOWS;
C     AD02NM CONTAINS TRACE LEVEL AND CHANNEL FOR DEBUGGING
C     BD02NM CONTAINS THE INTEGRATION STATISTICS PARAMETERS SUCH
C            NUMBER OF JACOBIAN EVALUATIONS AND STEPS. THE PARAMETER
C            NINTER CONTAINS THE EFFECTIVE SIZE OF THE MEMORY ARRAY
C            YH(NEQMAX,NINTER) IF INTERPOLATION IS TO BE USED ON IT.
C     DD02NM CONTAINS THE VARIABLES USED IN THE TIME MANAGEMENT
C            SCHEME AND THE WORKSPACE POINTERS.
C     ED02NM CONTAINS THE COMMUNICATION POINTERS USED IN REVERSE
C            COMMUNICATION BETWEEN THE TIME MANAGEMENT SCHEME AND
C            THE MODULES CALLED BY IT.
C     FD02NM CONTAINS THE IFIP TRANSPORTABLE NUMERICAL SOFTWARE
C            PARAMETERS WHICH ARE INITIALISED IN THE BLOCK DATA .
C     GD02NM CONTAINS INFORMATION USED BY THE NONLINEAR EQUATIONS
C            SOLVER CAN BE USED BY THE STEP MODULE TO IMPLEMENT
C            A DAMPED NEWTON METHOD  OR TO GOVERN THE NUMBER OF
C            ITERATIONS PERFORMED.
C     HD02NM PASSES THE TYPE OF NORM TO BE USED TO THE FUNCTION D02ZAF.
C   IMPORTANT
C   ---------
C      THE RESIDUAL, STEP, NONLINEAR EQUATIONS AND LINEAR ALGEBRA
C   MODULES ALL COMMUNICATE BY USING REVERSE COMMUNICATION THROUGH
C   THE TIME MANAGEMENT SCHEME IN D02NNF. ACCESS TO THESE MODULES IS
C   ONLY THROUGH THE PARAMETER LIST USED IN D02NNF. INTERNAL
C   COMMUNICATION BETWEEN THE GROUPS OF ROUTINES WHICH MAKE UP A
C   MODULE IS BY COMMON BLOCKS. FOR EXAMPLE THERE ARE THREE ROUTINES
C   IN THE B.D.F./ ADAMS METHOD TIME INTEGRATION MODULE :BDFSET, D02NMX
C   AND D02XJZ. INTERCOMMUNICATION BETWEEN THESE ROUTINES IS VIA COMMON
C   BLOCKS.
C-----------------------------------------------------------------------
CMBZ ONE EXTRA LINE + SAVE THE BLOCK AND DECLARE VARIABLES
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D02NNF')
C     .. Scalar Arguments ..
      DOUBLE PRECISION  T, TOUT
      INTEGER           IFAIL, IMON, INLN, IRES, IREVCM, ITASK, ITOL,
     *                  JTRACE, NEQ, NEQMAX, NJCPVT, NWKJAC, NY2DIM
C     .. Array Arguments ..
      DOUBLE PRECISION  ATOL(*), RTOL(*), RWORK(50+4*NEQMAX),
     *                  WKJAC(NWKJAC), Y(NEQMAX), YDOTI(NEQMAX),
     *                  YSAVE(NEQMAX,NY2DIM)
      INTEGER           INFORM(23), JACPVT(NJCPVT)
      LOGICAL           LDERIV(2)
C     .. Scalars in Common ..
      DOUBLE PRECISION  ATOLI, BIG, BIGBIG, CRATE, DAMP, DSQU, DUNFLO,
     *                  EL0, ELC, ELS, EWTI, H, H0, HMAX, HMIN, HMXI,
     *                  HMXSTT, HNEXT, HOLD, HU, QTYMIN, RH, RJNORM,
     *                  ROOTN, RTOLI, SIZE, TCRIT, TEM, TN, TOLSF, TP,
     *                  TS, UROUND, WB
      INTEGER           I, ICHMAX, ICRASH, IDACHK, IDACNT, IDAOLD, IDEV,
     *                  IER, IEWSET, IFJ, IFLAG, IFN, IFUNC, IMXER,
     *                  INIT, INITL, INORM, IODE, IOVFLO, IRETUR, ISAVE,
     *                  ISTEP, ITRACE, J, KCUR, KGO, LACOR, LDAE, LENRW,
     *                  LEWT, LSAVR, MAXIT, MXHNIL, MXHNL0, MXSTEP,
     *                  MXSTP0, N, NHNIL, NINTER, NITER, NJE, NOLD, NQ,
     *                  NQU, NRE, NSLAST, NST
      LOGICAL           CRIT1, CRIT2, IHIT, NT1STP, SFILTR
C     .. Local Scalars ..
      DOUBLE PRECISION  HMAXT
      INTEGER           IFZAF, JIIRES, K, MJCPVT, MWKJAC, MY2DIM
      LOGICAL           FAILED, INCICH, SUCCES
      CHARACTER*200     ERRMSG
C     .. Local Arrays ..
      DOUBLE PRECISION  AARG(1)
      CHARACTER         P01REC(1)
C     .. External Functions ..
      DOUBLE PRECISION  D02ZAF, X02AJF, X02ALF, X02AMF
      INTEGER           P01ABF
      EXTERNAL          D02ZAF, X02AJF, X02ALF, X02AMF, P01ABF
C     .. External Subroutines ..
      EXTERNAL          D02MVY, D02MWX, D02NMM, D02NMN, D02NMQ, D02NMS,
     *                  D02NMU, D02NMV, D02NMX, D02NMZ, D02NNN, D02NNQ,
     *                  D02NNV, D02NNW, D02NNX, D02NNY, D02NNZ, D02XJY,
     *                  X04ABF
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, DBLE, INT, MAX, MIN, MOD, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /AD02MZ/SFILTR
      COMMON            /AD02NM/ITRACE, IDEV
      COMMON            /BD02NM/HOLD, NQ, NQU, NST, NRE, NJE, NITER,
     *                  NINTER, KCUR
      COMMON            /CD02NM/HMXSTT
      COMMON            /DD02NM/H, EL0, TN, HU, HMIN, HMXI, DSQU, ELS,
     *                  WB, ELC, TS, INIT, LEWT, LACOR, LSAVR, LDAE,
     *                  MXSTEP, MXHNIL, NHNIL, NSLAST
      COMMON            /ED02NM/IFUNC, ISTEP, IER, IEWSET, IRETUR,
     *                  IDACNT, IDAOLD, INITL, IODE, ICRASH, IFN, IDACHK
      COMMON            /FD02NM/DUNFLO, UROUND, IOVFLO
      COMMON            /GD02NM/DAMP, RJNORM, CRATE, MAXIT
      COMMON            /HD02NM/INORM
      COMMON            /JD02NM/BIGBIG, QTYMIN, ROOTN
      COMMON            /KD02NM/IHIT
      COMMON            /LD02NM/ATOLI, BIG, EWTI, H0, RH, RTOLI, SIZE,
     *                  TCRIT, TEM, HNEXT, TOLSF, TP, HMAX, I, IFJ,
     *                  IFLAG, ICHMAX, IMXER, J, KGO, LENRW, MXHNL0,
     *                  MXSTP0, N, ISAVE, NOLD, CRIT1, CRIT2, NT1STP
C     .. Save statement ..
      SAVE              /BD02NM/, /DD02NM/, /ED02NM/, /FD02NM/,
     *                  /GD02NM/, /HD02NM/, /LD02NM/, /KD02NM/,
     *                  /JD02NM/, /AD02NM/, /CD02NM/, /AD02MZ/
C     .. Executable Statements ..
C-----------------------------------------------------------------------
C BLOCK A.
C THIS CODE BLOCK IS EXECUTED ON EVERY CALL.
C IT TESTS ISTATE AND ITASK FOR LEGALITY AND BRANCHES APPROPIATELY.
C IF ISTATE .GT. 1 BUT THE FLAG INIT SHOWS THAT INITIALIZATION HAS
C NOT YET BEEN DONE, AN ERROR RETURN OCCURS.
C IF ISTATE = 0 OR 1 AND TOUT = T RETURN IMMEDIATELY.
C-----------------------------------------------------------------------
C
C  COPY THE CONTROL PARAMETERS FROM THE INFORM ARRAY
C
      JIIRES = IRES
      GO TO (440,920,920,980,1580,880,880,960,20,
     *       80,320) IREVCM
      GO TO 140
   20 CONTINUE
      GO TO (1160,1160,1160,80,1160,40,60) IMON + 3
      GO TO 1160
   40 CONTINUE
      H = RWORK(16)
   60 CONTINUE
      HMIN = RWORK(17)
      HMAX = RWORK(18)
   80 CONTINUE
      IF (ITASK.NE.4 .AND. ITASK.NE.5) GO TO 120
      FAILED = IREVCM .EQ. 10
      SUCCES = IREVCM .EQ. 9
      IHIT = .FALSE.
  100 CONTINUE
      IF ( .NOT. CRIT1 .AND. .NOT. CRIT2) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            ISTEP = 3
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) THEN
               H = 0.5D0*(TCRIT-TN)
               ISTEP = 3
            END IF
         END IF
      ELSE IF (CRIT1 .AND. SUCCES) THEN
         CRIT1 = .FALSE.
         CRIT2 = .FALSE.
         IHIT = .TRUE.
      ELSE IF (CRIT1 .AND. FAILED) THEN
         IF (KCUR.NE.0) THEN
            CRIT1 = .FALSE.
            GO TO 100
         ELSE
            KCUR = 1
         END IF
      ELSE IF (CRIT2 .AND. FAILED) THEN
         IF (KCUR.NE.0) THEN
            CRIT2 = .FALSE.
            GO TO 100
         ELSE
            KCUR = 1
         END IF
      ELSE IF (CRIT2 .AND. SUCCES) THEN
         IF (ABS(H).GE.ABS(HU)) THEN
            CRIT2 = .FALSE.
            CRIT1 = .TRUE.
            H = HU
            ISTEP = 3
         ELSE
            CRIT1 = .FALSE.
            CRIT2 = .FALSE.
            GO TO 100
         END IF
      END IF
  120 CONTINUE
      GO TO (1160,740) IREVCM - 8
  140 CONTINUE
C
      NT1STP = ITASK .NE. 2 .AND. ITASK .NE. 5 .AND. ITASK .NE. 6
C
      ISAVE = 0
      ITRACE = JTRACE
      CALL X04ABF(0,IDEV)
C
CMBZ
C   THERE IS NO OPTION TO SET IODE = 2 TO SWITCH ON THE FILTER......
C
      SFILTR = .FALSE.
      IF (LDERIV(2)) THEN
         IODE = 1
      ELSE
         IODE = 0
      END IF
      IF (RWORK(49).EQ.1.0D0) THEN
         INORM = 1
      ELSE IF (RWORK(49).EQ.2.0D0) THEN
         INORM = 2
C  VP ADDED NEXT 2 LINES OCT 94
      ELSE IF (RWORK(49).EQ.3.0D0) THEN
         INORM = 3
      ELSE
         GO TO 1740
      END IF
      IF (RWORK(40).LT.0.0D0 .OR. RWORK(40).GT.1.0D0) GO TO 1740
      IF (ITASK.LT.1 .OR. ITASK.GT.6) GO TO 1760
      IF (RWORK(40).EQ.0.0D0) GO TO 160
      IF (INIT.EQ.0) GO TO 1780
      IF (RWORK(40).EQ.1.0D0 .AND. RWORK(8).EQ.1.0D0) GO TO 540
      GO TO 180
  160 CONTINUE
      INIT = 0
      IF (TOUT.EQ.T) GO TO 2020
C                            ABORT THE RUN
  180 CONTINUE
C-----------------------------------------------------------------------
C BLOCK B.
C THE NEXT CODE BLOCK IS EXECUTED FOR THE INITIAL CALL (ISTATE = 0 OR 1)
C OR FOR A CONTINUATION CALL WITH PARAMETER CHANGES (ISTATE = 3).
C IT CONTAINS CHECKING OF ALL INPUTS AND VARIOUS INITIALIZATIONS.
C
C FIRST CHECK LEGALITY OF THE NON-OPTIONAL INPUTS NEQ, ITOL AND IOPT.
C-----------------------------------------------------------------------
      IF (NEQ.LE.0) GO TO 1800
      IF (RWORK(40).EQ.0.0D0) NOLD = NEQ
      IF (NEQ.GT.NEQMAX) GO TO 1820
      N = NEQ
      ROOTN = SQRT(DBLE(N))
      BIGBIG = X02ALF()
      UROUND = X02AJF()
      DUNFLO = X02AMF()
      QTYMIN = SQRT(DUNFLO)
      IF (ITOL.LT.1 .OR. ITOL.GT.4) GO TO 1840
      ICRASH = 0
C ICRASH COUNTS THE NUMBER OF STEP ERROR TEST OR CONVERGENCE FAILURES---
C NEXT PROCESS AND CHECK THE OPTIONAL INPUTS. --------------------------
      MXSTEP = INT(RWORK(2))
      IF (MXSTEP.LT.0) GO TO 1860
C      IF (MXSTEP .EQ. 0) MXSTEP = MXSTP0
      MXHNIL = INT(RWORK(3))
      IF (MXHNIL.LT.0) GO TO 1880
      IF (MXHNIL.EQ.0) MXHNIL = 10
      IF (RWORK(40).EQ.1.0D0) GO TO 200
      H0 = RWORK(5)
      IF ((TOUT-T)*H0.LT.0.0D0) GO TO 1900
  200 CONTINUE
      HMAX = RWORK(6)
      IF (HMAX.LT.0.0D0) GO TO 1920
      HMXI = 0.0D0
      IF (HMAX.GT.0.0D0) HMXI = 1.0D0/HMAX
      IF (RWORK(40).EQ.1.0D0) GO TO 220
      ICHMAX = 0
      HMXSTT = ABS(TOUT-T)
      IF (ITASK.EQ.4) THEN
         HMXSTT = ABS(0.5D0*ABS(RWORK(1)-T))
         IF (HMAX.GT.0.0D0) HMXSTT = MIN(HMAX,HMXSTT)
      END IF
  220 CONTINUE
      HMIN = RWORK(7)
      IF (HMIN.LT.0.0D0) GO TO 1940
C-----------------------------------------------------------------------
C SET WORK ARRAY POINTERS .
C POINTERS TO SEGMENTS OF RWORK ARE NAMED BY PREFIXING L TO
C THE NAME OF THE SEGMENT.  E.G. THE SEGMENT EWT STARTS AT RWORK(LEWT).
C SEGMENTS OF RWORK (IN ORDER) ARE DENOTED EWT, ACOR, SAVR.
C-----------------------------------------------------------------------
      LEWT = 51
      LACOR = LEWT + NEQMAX
      LSAVR = LACOR + NEQMAX
      LDAE = LSAVR + NEQMAX
      LENRW = LSAVR + NEQMAX - 1
C
C     CHECK NY2DIM FOR LEGALITY
C
      MY2DIM = INT(RWORK(33))
      MWKJAC = INT(RWORK(46))
      MJCPVT = INT(RWORK(47))
      IF (NY2DIM.NE.MY2DIM) GO TO 2200
      IF (NWKJAC.NE.MWKJAC) GO TO 2220
      IF (RWORK(34).NE.1.0D0 .AND. NJCPVT.NE.MJCPVT) GO TO 2240
C
C     CHECK RTOL AND ATOL FOR LEGALITY.
C
      RTOLI = RTOL(1)
      ATOLI = ATOL(1)
      DO 240 I = 1, N
         IEWSET = -I
C205
C205  THIS LOOP IS NOT EASILY VECTORISED
C205
         IF (ITOL.GE.3) RTOLI = RTOL(I)
         IF (ITOL.EQ.2 .OR. ITOL.EQ.4) ATOLI = ATOL(I)
         IF (RTOLI.LT.0.0D0) GO TO 1960
         IF (ATOLI.LT.0.0D0) GO TO 1980
         IEWSET = 0
  240 CONTINUE
      DSQU = SQRT(UROUND)
      IF (RWORK(40).EQ.0.0D0) GO TO 260
C
C IF ISTATE = 3, SET FLAG TO SIGNAL PARAMETER CHANGES TO STEP MODULE.---
C
      ISTEP = 2
      GO TO 540
C-----------------------------------------------------------------------
C BLOCK C.    INITIALISATION BLOCK
C THE NEXT BLOCK IS FOR THE INITIAL CALL ONLY (ISTATE = 0 OR 1) OR FOR
C A RESTART FORCED BY THE MONITOR ROUTINE. IN THE LATTER CASE THE ENTRY
C POINT TO THIS BLOCK IS AT POINT INDICATED.
C IT CONTAINS ALL REMAINING INITIALIZATIONS AND CALLS TO THE NONLINEAR
C SOLVER AND THE CALCULATION OF THE INITIAL STEP SIZE.
C THE ERROR WEIGHTS IN EWT ARE INVERTED AFTER BEING LOADED.
C-----------------------------------------------------------------------
  260 CONTINUE
      TN = T
      IHIT = .FALSE.
      HU = 0.0D0
CMBZ
CNEW BLOCK OF CODE HERE  WITH TWO NEW LINE AND SOME RESTRUCTURING.
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         TCRIT = RWORK(1)
         IF ((TCRIT-TOUT)*(TOUT-T).LT.0.0D0) GO TO 2080
         IF (H0.NE.0.0D0 .AND. (T+H0-TCRIT)*H0.GT.0.0D0) H0 = TCRIT - T
         HMAXT = MAX(ABS(TCRIT-T),UROUND)
         HMXI = MAX(1.0D0/HMAXT,HMXI)
      END IF
      ISTEP = -1
      NHNIL = 0
      NST = 0
      IFN = 0
      NRE = 1
      NJE = 0
      NSLAST = 0
      HU = 0.0D0
      NQU = 0
      NITER = 0
      IF (RWORK(40).EQ.0.0D0 .AND. .NOT. LDERIV(1)) THEN
C        SET YDOTI TO 0 TO PREVENT UNDEFINED REFERENCES
         DO 280 I = 1, N
            YDOTI(I) = 0.0D0
  280    CONTINUE
      END IF
      INITL = 1
      IF (LDERIV(1)) INITL = 2
      H = H0
C-----------------------------------------------------------------------
C     CHECK IF THE USER HAS CORRECTLY SPECIFIED THE RESID ROUTINE
C     WHEN IT IS CALLED WITH IRES = -1
C     NOTE: THIS TEST WILL NOT WORK FOR D.A.ES OF THE FORM
C           A YDOT = C(T) F(Y)   WHERE C(0) = 0  OR F(Y(0)) = 0
C     BECAUSE AT T= 0 THE ROUTINE IS CORRECT.
C     ALSO CHECK IF THE USER OVERWRITES Y AND/OR YDOT IN  RESID.
C     THIS TEST COULD BE IMPROVED BY PERTURBING Y AND T SO THAT ANY
C     ALGEBRAIC EQUATIONS ARE NOT THEN SATISFIED .
C----------------------------------------------------------------------
      DO 300 I = 1, N
         RWORK(LSAVR+I-1) = 1.0D0/UROUND
         YSAVE(I,1) = Y(I)
         RWORK(LACOR+I-1) = YDOTI(I)
         YDOTI(I) = 0.0D0
  300 CONTINUE
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 2000
      IRES = -1
C
C      CALL RESID(NEQ, TN, Y, YDOTI, RWORK(LSAVR), IRES, WKRES, NWKRES)
C
      IREVCM = 11
      GO TO 1660
  320 CONTINUE
      K = 0
      J = 0
      DO 340 I = 1, N
         IF (ABS(RWORK(LSAVR+I-1)).GT.DUNFLO) J = I
  340 CONTINUE
      DO 360 I = 1, N
         RWORK(LSAVR+I-1) = ABS(YSAVE(I,1)-Y(I)) + ABS(YDOTI(I))
  360 CONTINUE
      DO 380 I = 1, N
         IF (ABS(RWORK(LSAVR+I-1)).GT.DUNFLO) K = I
  380 CONTINUE
      DO 400 I = 1, N
         YDOTI(I) = RWORK(LACOR+I-1)
         Y(I) = YSAVE(I,1)
  400 CONTINUE
      IF ((IRES.GT.1) .OR. (IRES.EQ.0) .OR. (IRES.LT.-1)) THEN
         CALL D02NNQ(
     *' WHEN EVALUATING THE RESIDUAL DURING INITIALISATION IRES
     *  WAS SET TO (=I1)',2,1,IRES,0,0,0.0D0,0.0D0)
         IF (IRES.EQ.2) THEN
            ISAVE = 11
         ELSE IF (IRES.EQ.3) THEN
            ISAVE = 7
         ELSE
            ISAVE = 1
         END IF
         GO TO 2300
      END IF
      IF (J.GT.0) GO TO 2140
      IF (K.GT.0) THEN
         CALL D02NNQ(
     *' THE ROUTINE WHICH EVALUATES THE RESIDUAL, APPEARS TO
     *  OVERWRITE THE Y AND/OR YDOT VECTORS WHEN CALLED.
     *  INTEGRATION WILL NOT BE ATTEMPTED .',1,0,0,0,0,0.0D0,0.0D0)
         GO TO 2280
      END IF
C
C     EXTRA TEST TO ENSURE THAT ALGEBRAIC EQUATIONS ARE O.K.
C
      TEM = T + (TOUT-T)*DSQU
      DO 420 I = 1, N
         YDOTI(I) = 0.0D0
         Y(I) = Y(I) + (1.0D0+ABS(Y(I)))*DSQU*(N+I)/N
  420 CONTINUE
      IRES = -1
C
C     CALL RESID(NEQ, TN, Y, YDOTI, RWORK(LSAVR), IRES, WKRES, NWKRES)
C
      IREVCM = 1
      GO TO 1660
  440 CONTINUE
      J = 0
      DO 460 I = 1, N
         IF (ABS(RWORK(LSAVR+I-1)).GT.DUNFLO) J = I
  460 CONTINUE
      DO 480 I = 1, N
         YDOTI(I) = RWORK(LACOR+I-1)
         Y(I) = YSAVE(I,1)
  480 CONTINUE
      IF ((IRES.GT.1) .OR. (IRES.EQ.0) .OR. (IRES.LT.-1)) THEN
         CALL D02NNQ(
     *' WHEN EVALUATING THE RESIDUAL DURING INITIALISATION IRES
     *  WAS SET TO (=I1)',2,1,IRES,0,0,0.0D0,0.0D0)
         IF (IRES.EQ.2) THEN
            ISAVE = 11
         ELSE IF (IRES.EQ.3) THEN
            ISAVE = 7
         ELSE
            ISAVE = 1
         END IF
         GO TO 2300
      END IF
      IF (J.GT.0) GO TO 2140
C-----------------------------------------------------------------------
C ENTRY TO BLOCK IF RESTART FORCED BY MONITOR ROUTINE.
C-----------------------------------------------------------------------
  500 CONTINUE
      NQ = 1
      EL0 = 1.0D0
C-----------------------------------------------------------------------
C LOAD AND INVERT THE EWT ARRAY AND THEN CALL THE INITIALISATION MODULE
C----------------------------------------------------------------------
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 2000
      INLN = 0
      CALL D02NNW(NEQ,TN,TOUT,H,Y,YDOTI,RWORK(LEWT),RTOL,ATOL,ITOL)
C
C        ERROR RETURN FOR INITIAL STEP UNOBTAINABLE
      IF (H.EQ.0.0D0) GO TO 2280
C
      RH = ABS(H)*HMXI*100
      IF (RH.GT.1.0D0) H = H/RH
      IF (INITL.EQ.1) THEN
         TEM = DSQU*100.0D0
         TEM = 0.315D-5
         H = MIN(ABS(H),TEM)*SIGN(1.0D0,H)
      END IF
      RH = HMIN/ABS(H)
      IF (RH.GT.1.0D0) H = H*RH
CMBZ CHANGES IN NEXT 18 LINES
C
C 620 CALL DZ2NNY(N,Y,YDOTI,YSAVE,NEQMAX,RWORK(LSAVR),RWORK(LACOR),
C    *            RWORK(LDAE),TN,H,INITL,INLN,IODE,HMIN)
      DAMP = 1.0D0
  520 CONTINUE
      CALL D02NNY(N,Y,YDOTI,YSAVE,NEQMAX,RWORK(LSAVR),RWORK(LACOR),
     *            RWORK(LDAE),TN,H,INITL,INLN,IODE,HMIN,RWORK(LEWT),
     *            JIIRES)
      IF (INITL.EQ.0) THEN
         IRETUR = 1
CMBZ     DAMP = 1.0D0
C        MAXIT = 3
C        IF (INLN.EQ.1) THEN
C           MAXIT = 5
C           DAMP = 0.75D0
C        ELSE IF (INLN.EQ.7) THEN
C           MAXIT = 5
CMBZ     END IF
         GO TO 780
      ELSE
C           TRAP FOR RESID THEN ENTER MONITOR PATH
         IF (INLN.EQ.-4) THEN
            IMON = -2
            GO TO 1140
         END IF
         IF (INITL.EQ.-1) GO TO 1500
      END IF
      MAXIT = 3
      DAMP = 1.0D0
      HU = H
      LDERIV(2) = IODE .EQ. 0
      IF (ITASK.EQ.6) THEN
C         RETURN TO THE CALLING PROGRAM WITH CALCULATED INITIAL VALUES.
         T = TN
         TOUT = TN
         LDERIV(1) = .TRUE.
         GO TO 1640
      END IF
      CALL D02NNW(NEQ,TN,TOUT,H0,Y,YDOTI,RWORK(LEWT),RTOL,ATOL,ITOL)
C          TO COMPUTE THE INITIAL STEPSIZE H0 , ADJUST IT ON
C          RETURN TO MEET HMAX BOUND AND LOAD H0 INTO H.
C
C CMBZ 5 NEW LINES AND LABEL 660 SHIFTED UP
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         HMAXT = MAX(ABS(TCRIT-TN),UROUND)
         HMXI = MAX(1.0D0/HMAXT,HMXI)
      END IF
      RH = ABS(H0)*HMXI
      H = H0
      IF (RH.GT.1.0D0) H = H0/RH
      IF (ABS(H).LT.HMIN) H = HMIN*SIGN(1.0D0,H0)
      IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            CRIT2 = .FALSE.
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) H = 0.5D0*(TCRIT-TN)
         END IF
      END IF
      IF (ITRACE.GE.1) THEN
         AARG(1) = H
         CALL D02NNN(AARG,1,1)
      END IF
      H0 = 0.0D0
      INITL = 1
CMBZ TWO NEW LINES INC POSS JUMP
C    CHECK TO SEE IF OUTPUT POINT HAS BEEN PASSED IN INITIALISATION.
      IF ((TN-TOUT)*H.GE.0.0D0) GO TO 540
      GO TO 680
C-----------------------------------------------------------------------
C BLOCK D.
C THE NEXT CODE BLOCK IS FOR CONTINUATION CALLS ONLY (ISTATE = 2 OR 3)
C AND IS TO CHECK STOP CONDITIONS BEFORE TAKING A STEP.
C-----------------------------------------------------------------------
  540 CONTINUE
      NSLAST = NST
      IHIT = .FALSE.
      GO TO (560,660,580,600,620) ITASK
  560 CONTINUE
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 660
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      IF (IFLAG.NE.0) GO TO 2120
      T = TOUT
      GO TO 1360
  580 CONTINUE
      TP = TN - HU*(1.0D0+100.0D0*UROUND)
      IF ((TP-TOUT)*H.GT.0.0D0) GO TO 2040
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 660
      T = TN
      GO TO 1320
  600 CONTINUE
      TCRIT = RWORK(1)
      IF ((TN-TCRIT)*H.GT.0.0D0) GO TO 2060
      IF ((TCRIT-TOUT)*H.LT.0.0D0) GO TO 2080
      IF ((TN-TOUT)*H.LT.0.0D0) GO TO 640
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      IF (IFLAG.NE.0) GO TO 2120
      T = TOUT
      GO TO 1360
  620 CONTINUE
      TCRIT = RWORK(1)
      IF ((TN-TCRIT)*H.GT.0.0D0) GO TO 2060
  640 CONTINUE
      IF ( .NOT. CRIT1 .AND. .NOT. CRIT2) THEN
         CRIT1 = (TN+H-TCRIT)*H .GE. 0.0D0
         IF (CRIT1) THEN
            H = TCRIT - TN
            ISTEP = 3
         ELSE
            CRIT2 = (TN+2.0D0*H-TCRIT)*H .GE. 0.0D0
            IF (CRIT2) THEN
               H = 0.5D0*(TCRIT-TN)
               ISTEP = 3
            END IF
         END IF
      END IF
      IF (IHIT) GO TO 1300
C-----------------------------------------------------------------------
C BLOCK E.
C THE NEXT BLOCK IS NORMALLY EXECUTED FOR ALL CALLS AND CONTAINS
C THE CALL TO THE STEP CORE INTEGRATOR.
C
C THIS IS A LOOPING POINT FOR THE INTEGRATION STEPS.
C
C FIRST CHECK FOR TOO MANY STEPS BEING TAKEN, UPDATE EWT (IF NOT AT
C START OF PROBLEM), CHECK FOR TOO MUCH ACCURACY BEING REQUESTED, AND
C CHECK FOR H BELOW THE ROUNDOFF LEVEL IN T.
C-----------------------------------------------------------------------
  660 CONTINUE
      IF (RWORK(8).EQ.2.0D0) THEN
         HNEXT = RWORK(9)
         IF (HNEXT.NE.0.0D0) THEN
            IF (ITASK.EQ.4 .OR. ITASK.EQ.5) THEN
               IF (CRIT1 .AND. ABS(H).LT.ABS(HNEXT)) THEN
                  CRIT1 = .FALSE.
                  H = SIGN(1.0D0,H)*HNEXT
               ELSE
                  CRIT1 = .FALSE.
                  CRIT2 = .FALSE.
                  IF (HNEXT.GT.ABS(TCRIT-TN)) CRIT1 = .TRUE.
                  H = SIGN(1.0D0,H)*MIN(HNEXT,ABS(TCRIT-TN))
               END IF
            ELSE
               H = SIGN(1.0D0,H)*HNEXT
            END IF
            ISTEP = 3
         END IF
         RWORK(8) = 1.0D0
      END IF
      IF (RWORK(40).EQ.1.0D0 .AND. N.NE.NOLD) ISTEP = 2
      NOLD = N
      IF ((NST-NSLAST).GE.MXSTEP .AND. MXSTEP.GT.0) GO TO 1420
      CALL D02NNX(N,ITOL,RTOL,ATOL,Y,RWORK(LEWT),IEWSET)
      IF (IEWSET.LT.0) GO TO 1440
  680 CONTINUE
      IFZAF = 1
      TOLSF = UROUND*D02ZAF(N,Y,RWORK(LEWT),IFZAF)
      IF (TOLSF.LE.1.0D0) GO TO 700
      TOLSF = TOLSF*2.0D0
      IF (NST.EQ.0) GO TO 2100
      GO TO 1460
  700 CONTINUE
      IF ((TN+H).NE.TN) GO TO 720
      NHNIL = NHNIL + 1
      IF (NHNIL.GT.MXHNIL) GO TO 720
      CALL D02NNQ(
     *' WARNING... THE TIME T (=R1) AND STEPSIZE H (=R2) ARE
     *  SUCH THAT T + H = T ON THE NEXT STEP - SOLVER WILL
     *  CONTINUE',2,0,0,0,2,TN,H)
      IF (NHNIL.LT.MXHNIL) GO TO 720
      CALL D02NNQ(
     *' ABOVE WARNING HAS NOW BEEN ISSUED I1 TIMES
     *  AND WILL NOT BE USED AGAIN. ',2,1,MXHNIL,0,0,0.0D0,0.0D0)
  720 CONTINUE
      INLN = 0
      TS = TN
  740 CONTINUE
      IF (RWORK(21).EQ.1.0D0) THEN
         CALL D02NMX(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
      ELSE IF (RWORK(21).EQ.2.0D0) THEN
         CALL D02NMZ(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
CMBZ
C  NEXT 8 LINES ARE ADDITION BY M.B.
      ELSE IF (RWORK(21).EQ.3.0D0) THEN
         CALL D02MWX(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
      ELSE IF (RWORK(21).EQ.4.0D0) THEN
         CALL D02MVY(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),YDOTI,RWORK(LSAVR),
     *               RWORK(LACOR),INLN,ISTEP,EL0,H,TN,HMIN,HMXI,
     *               RWORK(LDAE),RWORK,IREVCM)
      ELSE
         GO TO 1740
      END IF
C
      IF (IREVCM.EQ.10) GO TO 1660
C
      IRETUR = 0
      IF (INLN.GT.0) THEN
C        REVERSE COMMUNICATIONS CALL TO NLSLVR IN PROGRESS SET THE
C        RETURN FLAG AND CALL THE SOLVER.
         IRETUR = 2
         GO TO 780
      ELSE
C        FIND THE LARGEST LOCAL ERROR COMPONENT
C205
C205     REPLACE THE FOLLOWING BLOCK OF CODE WITH SOMETHING LIKE:
C205     ASSIGN TEMP1(1),.DYN.N
C205     TEMP1(1) = VABS ( RWORK(LACOR;N), TEMP1(1) )
C205     TEMP1(1) = TEMP(1) * RWORK(LEWT;N)
C205     IMXER = Q8SMAXI(TEMP1) + 1
C205     FREE
C205
         BIG = 0.0D0
         DO 760 I = 1, N
            SIZE = ABS(RWORK(I+LACOR-1)*RWORK(LEWT+I-1))
            IF (BIG.LE.SIZE) THEN
               BIG = SIZE
               IMXER = I
            END IF
  760    CONTINUE
         GO TO 1100
      END IF
C-----------------------------------------------------------------------
C BLOCK F
C ------- CALL TO NONLINEAR EQUATIONS SOLVER PART OF PACKAGE
C         **************************************************
C
C         INLN = 1   SOLVE THE NONLINEAR SYSTEM OF EQUATIONS
C                    AFTER FORMING A NEW JACOBIAN MATRIX.
C         INLN = 2   AS FOR INLN = 1 BUT USING THE OLD JACOBIAN.
C         INLN = 3   FORM THE RESIDUAL OF THE D.A.E. STARTING
C                    THE VALUES AT RWORK(LSAVR).
C         INLN = 4   PERFORM ONE BACKSUBSTITUTION ONLY ON THE VECTOR
C                    WHICH STARTS AT RWORK(LSAVR) USING THE ALREADY
C                    FACTORED JACOBIAN MATRIX .
C         INLN = 5   PETZOLD LOCAL ERROR ESTIMATE- PREMULTIPLY
C                    USUAL LOCAL ERROR ESTIMATE BY DF/DYDOT AND THEN
C                    BY THE INVERSE OF THE JACOBIAN.
C         INLN = 6   SOLVE THE NONLINEAR SYSTEM OF EQUATIONS USING
C                    FUNCTIONAL ITERATION.
C         INLN = 7   SOLVE FOR THE INITIAL VALUES OF THE ALGEBRAIC EQNS
C                    AND FOR THE INITIAL DERIVATIVES USING FUNCTIONAL
C                    ITERATION . THIS ASSUMES THAT BOTH THE ALGEBRAIC
C                    AND DIFFERENTIAL PARTS ARE WRITTEN IN NORMAL FORM.
C         INLN = 8   AS FOR INLN = 3 BUT WITH IRES = -1
C
C-----------------------------------------------------------------------
  780 CONTINUE
      IDACHK = 0
      IF ((INLN.GT.2 .AND. INLN.LT.6) .OR. INLN.EQ.8) THEN
C         AVOID THE CALL TO NLSLVR
         IFUNC = INLN
         IF (IFUNC.EQ.4) GO TO 1020
         GO TO 820
      ELSE IF (INLN.EQ.6) THEN
         IFN = IFN + 1
         IF (MOD(IFN,9).EQ.8) IDACHK = 1
C                                CHECK O.D.E./D.A.E. SPLIT FOR F/ITER
      ELSE IF (INLN.EQ.1) THEN
         IF (MOD(NJE,9).EQ.8) IDACHK = 1
C                                CHECK O.D.E./D.A.E. SPLIT FOR NEWTON
      END IF
  800 CONTINUE
      CALL D02NMV(NEQ,Y,YDOTI,YSAVE,NEQMAX,RWORK(LSAVR),RWORK(LACOR),
     *            RWORK(LEWT),IFUNC,INLN,H,EL0,RWORK(LDAE))
C
C          IF IFUNC = 0 RETURN TO CALLING POINT AS SOLVER HAS FINISHED
C
      IF (IFUNC.EQ.0) GO TO 1080
  820 CONTINUE
      DO 840 I = 1, N
         RWORK(LSAVR+I-1) = 0.0D0
  840 CONTINUE
      IF (IFUNC.NE.5) GO TO 860
C         RESID EVAL WITH DIFFERENT PARAMETER LIST FOR PETZOLD ERR EST
      IRES = -1
      IREVCM = 2
      GO TO 1660
  860 CONTINUE
      IF (IDACHK.NE.1) GO TO 900
CMBZ      PERIODICALLY CHECK ALGEBRAIC DIFF. EQN. SPLIT
  880 CONTINUE
      CALL D02NNZ(NEQ,TN,Y,YDOTI,YSAVE,NEQMAX,RWORK(LSAVR),RWORK(LACOR),
     *            RWORK(LEWT),H,EL0,RWORK(LDAE),IRES,IREVCM)
      IF (IREVCM.EQ.6 .OR. IREVCM.EQ.7) GO TO 1660
      I = IRES*IRES
      IF (I.NE.1) GO TO 1060
      IDACHK = 0
  900 CONTINUE
C     ORDINARY RESID EVALUATION TO PUT SAVR TO WHAT IT SHOULD BE
      IRES = 1
      IF (IFUNC.EQ.8) IRES = -1
      IREVCM = 3
      GO TO 1660
  920 CONTINUE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      NRE = NRE + 1
      I = IRES*IRES
      IF (I.NE.1) GO TO 1060
      GO TO (940,1020,1080,800,1020,800,800,1080) IFUNC
C
C                                  JACOBIAN EVALUATION
  940 CONTINUE
      IFJ = 0
      NJE = NJE + 1
      ELS = H*EL0
  960 CONTINUE
      IF (RWORK(34).EQ.1.0D0) THEN
         CALL D02NMU(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE IF (RWORK(34).EQ.2.0D0) THEN
         CALL D02NMS(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE IF (RWORK(34).EQ.3.0D0) THEN
         CALL D02NMM(NEQ,Y,YSAVE,NEQMAX,RWORK(LEWT),RWORK(LACOR),
     *               RWORK(LSAVR),YDOTI,WKJAC,JACPVT,IFJ,H,EL0,TN,IFUNC,
     *               RWORK(LDAE),RWORK,IREVCM,INFORM)
      ELSE
         GO TO 2180
      END IF
C
      IF (IREVCM.EQ.8) GO TO 1660
C     USER SUPPLIED ROUTINE BEING USED TO FORM JACOBIAN
      IF (IFJ.EQ.0) GO TO 1000
      IF (IFJ.EQ.-1) THEN
         INLN = -1
         GO TO 1080
      ELSE IF (IFJ.EQ.-2) THEN
         INLN = -5
         GO TO 1080
      END IF
C     DIFFERENCING IS BEING USED TO FORM JACOBIAN
      IRES = 1
      IREVCM = 4
      GO TO 1660
  980 CONTINUE
      NRE = NRE + 1
      I = IRES*IRES
      IF (I.NE.1) GO TO 1060
      GO TO 960
 1000 CONTINUE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
C      BACKSUBSTITUTION FOLLOWED BY A RETURN TO NLSLVR
 1020 CONTINUE
      NITER = NITER + 1
C      SCALE THE RESIDUAL VECTOR BY THE RELAX FACTOR
      ELC = EL0*H
      WB = ELC*ELS*2.0D0/(ELC+ELS) - 1
C205
C205   REPLACE THR NEXT LOOP WITH SOMETHING LIKE:
C205   ASSIGN TEMP1(1),.DYN.N
C205   TEMP1(1) = RWORK(LDAE;N)*WB + 1.0
C205   RWORK(LSAVR;N) = TEMP1(1)*RWORK(LSAVR;N)
C205
      DO 1040 I = 1, N
         RWORK(LSAVR+I-1) = RWORK(LSAVR+I-1)*(RWORK(LDAE-1+I)*WB+1.0D0)
 1040 CONTINUE
      J = 0
      IF (RWORK(34).EQ.1.0D0) THEN
         CALL D02NMQ(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE IF (RWORK(34).EQ.2.0D0) THEN
         CALL D02NMN(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE IF (RWORK(34).EQ.3.0D0) THEN
         CALL D02NNV(WKJAC,JACPVT,RWORK(LSAVR),NEQ,J)
      ELSE
         GO TO 2180
      END IF
C
CMBZ MAJOR CHANGE NEXT THREE LINES COMMENTED OUT.... DO 1200 LOOP GONE
C       AND NOW RESCALE THE RESULT
C     DO 1200 I = 1, N
C        RWORK(LSAVR+I-1) = RWORK(LSAVR+I-1)/ELC
C1200 CONTINUE
      IF (J.NE.0) INLN = -5
      IF (INLN.EQ.0) GO TO 800
      GO TO 1080
C
C      ERROR IN RESIDUAL FORMATION
 1060 CONTINUE
      INLN = -IRES
      IF ((IRES.GT.4) .OR. (IRES.EQ.0) .OR. (IRES.LT.-2)) THEN
         ERRMSG =
     *' THE ROUTINE WHICH EVALUATES THE RESIDUAL
     * HAS ILLEGALLY SET IRES(=I1) . IRES HAS BEEN RESET TO 3 TO
     * TRY AND CONTINUE THE INTEGRATION. '
         CALL D02NNQ(ERRMSG,2,1,IRES,0,0,0.0D0,0.0D0)
         IRES = 3
         INLN = -3
      END IF
C
C      RETURN TO THE PROGRAM SEGMENT WHICH CALLED THE SOLVER
 1080 CONTINUE
      IFUNC = 0
      GO TO (520,740,1140) IRETUR
C
C-----------------------------------------------------------------------
C BLOCK G
C           EXIT FROM THE STEP MODULE- CHECK IF MONITR IS TO BE CALLED
C-----------------------------------------------------------------------
 1100 CONTINUE
      IF (IRES.EQ.4) THEN
         IMON = -2
         GO TO 1140
      ELSE IF (ISTEP.EQ.-1 .OR. ISTEP.EQ.-2) THEN
         IMON = -1
      END IF
      KGO = 2 - ISTEP
      GO TO (1120,780,1140,1140,1320,1480,1480,2280,2260) KGO
C             1    2    3    4    5    6    7    8    9
C
C KGO = 1,SUCCESS.   2, CALL TO NLSLVR.  3,ERROR TEST FAILURE.
C       4, CONVERGENCE FAILURE.          5,RES ORDERED RETURN.
C       6,RES RETURNED ERROR.      7,SINGULAR JACOBIAN MATRIX.
C       8,NO CALL TO INIT MODULE.     9,IMPOSS ERR IN LIN ALG.
 1120 CONTINUE
      INIT = 1
      HU = HOLD
      IF ((ITASK.EQ.4 .OR. ITASK.EQ.5) .AND. CRIT1) TN = TCRIT
      NST = NST + 1
      INCICH = NT1STP .AND. (ABS(HU).EQ.HMAX .OR. NST.LT.3 .AND. ABS(HU)
     *         .EQ.HMXSTT)
      IF (INCICH) ICHMAX = ICHMAX + 1
      IMON = 1
 1140 CONTINUE
      IREVCM = 9
      GO TO 1660
 1160 CONTINUE
      IF (HMAX.LT.0.0D0) THEN
         GO TO 1920
      ELSE
         HMXI = 0.0D0
         IF (HMAX.GT.0.0D0) HMXI = 1.0D0/HMAX
      END IF
      IF (NEQ.NE.N) THEN
C        THE DIMENSION OF THE O.D.E. SYSTEM HAS CHANGED.
         IF (NEQ.GT.NEQMAX) GO TO 2160
         IF (NEQ.LT.1) GO TO 1800
         N = NEQ
         ROOTN = SQRT(DBLE(N))
      END IF
      IF (IMON.EQ.0) IRETUR = 3
      IF (IMON.EQ.2) THEN
         LDERIV(1) = .TRUE.
         RWORK(40) = 0.0D0
         ISTEP = -1
         H0 = H
      END IF
      IF (IMON.EQ.3 .OR. IMON.EQ.4) THEN
         I = ISTEP
         ISTEP = IMON - 1
         IF (I.LT.0) GO TO 720
      END IF
      IF (IMON.EQ.-1 .AND. ISTEP.LT.0) IMON = -3
      I = IMON + 4
C             -3     -2   -1   0    1    2    3    4    IMON
      GO TO (1380,1320,1520,780,1180,500,1180,1180) I
C          RESTART    ERROR   NON-      RE-    NORMAL CONTINUE
C                    RETURNS  LIN SOLVER  START
      GO TO 1520
C-----------------------------------------------------------------------
C BLOCK H :HANDLES A SUCCESSFUL RETURN FROM THE CORE INTEGRATOR,ISTEP=1.
C THE TEST FOR STOP CONDITIONS IS MADE ,ON FAILURE WE JUMP TO THE
C BEGINNING OF BLOCK E.
C IF THE STOP CONDITIONS ARE SATISFIED AND ITASK .NE. 1 ,Y IS LOADED
C FROM YH AND T IS SET ACCORDINGLY. THE RETURN IS MADE FROM THE SECTION
C BEGINNING WITH THE COMMENT 'EXIT POINT FOR SUCCESSFUL RUNS'
C-----------------------------------------------------------------------
 1180 CONTINUE
      IF (ITRACE.GE.1) THEN
         AARG(1) = TN
         CALL D02NNN(AARG,1,2)
      END IF
      TEM = -TOUT*10.0D0*H*UROUND
      GO TO (1200,1240,1220,1260,1280) ITASK
C
C          ITASK = 1. IF TOUT HAS BEEN REACHED, INTERPOLATE.
C
 1200 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) GO TO 660
      IFLAG = 0
      CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,RWORK(21))
      T = TOUT
      GO TO 1360
C
C         ITASK =2,3. JUMP TO EXIT IF TOUT WAS REACHED.
C
 1220 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) GO TO 660
 1240 CONTINUE
      T = TN
      GO TO 1320
C
C          ITASK = 4. SEE IF TOUT OR TCRIT WAS REACHED AND ADJUST H.
C
 1260 CONTINUE
      IF ((TN-TOUT)*H.LT.TEM) THEN
         IF (IHIT) GO TO 1300
CMBZ  THREE NEW LINES TO RESET HMAX, HMIN AND HMXI
         HMAXT = MIN(ABS(TCRIT-TN),ABS(TOUT-TN))
         HMAXT = MAX(HMAXT,UROUND)
         HMXI = MAX(1.D0/HMAXT,HMXI)
         GO TO 660
      ELSE
         IFLAG = 0
         CALL D02XJY(TOUT,0,YSAVE,NEQMAX,Y,IFLAG,NEQ,H,TN,HU,NQU,
     *               RWORK(21))
         T = TOUT
         GO TO 1360
      END IF
C
C         ITASK = 5.  SEE IF TCRIT WAS REACHED AND JUMP TO EXIT.
C
 1280 CONTINUE
      T = TN
 1300 CONTINUE
      IF (IHIT) T = TCRIT
C        .
C A SUCCESSFUL RETURN FROM D02NNF. SET Y FROM YH AND JUMP TO THE SECTION
C BEGINNING WITH THE COMMENT 'EXIT POINT FOR SUCCESSFUL RUNS'
C
 1320 CONTINUE
      DO 1340 I = 1, N
         Y(I) = YSAVE(I,1)
 1340 CONTINUE
 1360 CONTINUE
      ISAVE = 0
C     IF (ISTEP.EQ.-3) ISAVE = 11
C     IF (IMON.EQ.-2) ISAVE = 12
      IF (ISTEP.EQ.-3 .OR. IMON.EQ.-2) THEN
         T = TN
         ISAVE = 11
         IF (IMON.EQ.-2) ISAVE = 12
      END IF
      GO TO 1640
C-----------------------------------------------------------------------
C  BLOCK I
C  THIS BLOCK ENTERED AFTER ERROR TEST OR CONVERGENCE FAILURES AND
C  PROVIDING THAT THE MONITR ROUTINE HAS NOT SET IMON = -2
C  ICRASH COUNTS THE FAILURES AND ALLOWS A MAXIMUM OF THREE PER RUN.
C-----------------------------------------------------------------------
 1380 CONTINUE
      ICRASH = ICRASH + 1
      IF (ICRASH.EQ.3) GO TO 1480
C       ELSE RESTART MODE
      IF (ITRACE.GE.1) THEN
         AARG(1) = TN
         CALL D02NNN(AARG,1,3)
      END IF
      DO 1400 I = 1, N
         YDOTI(I) = 0.0D0
 1400 CONTINUE
      H = H*0.1D0
      H0 = H
      ISTEP = -1
      GO TO 500
C-----------------------------------------------------------------------
C BLOCK J.
C THE FOLLOWING BLOCK HANDLES ALL RETURNS OTHER THAN THOSE FOR ILLEGAL
C INPUT. IN THE CASE OF INTEGRATOR FAILURE THE ERROR MESSAGE ROUTINE IS
C CALLED Y IS LOADED FROM YH AND T IS SET TO TN. IN EITHER CASE THE   .
C OPTIONAL OUTPUTS ARE  LOADED INTO THE WORK ARRAYS BEFORE RETURNING.
C-----------------------------------------------------------------------
C THE MAXIMUM NUMBER OF STEPS WAS TAKEN BEFORE REACHING TOUT.
C
 1420 CONTINUE
      CALL D02NNQ(
     *' AT CURRENT TIME (=R1), MAXIMUM NUMBER OF ALLOWED STEPS (=I1)
     * ON THIS CALL WAS TAKEN BEFORE REACHING THE NEXT OUTPUT POINT
     *  TOUT (=R2) ',1,1,MXSTEP,0,2,TN,TOUT)
      ISAVE = 2
CMBZ CHANGED 1740 TO 1800
      GO TO 1600
C EWT(I) .LE. 0.0 FOR SOME I (NOT AT START OF PROBLEM). ----------------
 1440 CONTINUE
      EWTI = RWORK(LEWT+I-1)
      I = -IEWSET
      CALL D02NNQ(
     *' AT THE TIME T(=R1), THE ERROR TEST WEIGHT COMPONENT EWT(I1)(=R2)
     * HAS BECOME  LESS THAN  0. CHECK THE VALUES OF ATOL RTOL AND ITOL
     * SUPPLIED (ATOL(I1) AND RTOL(I1) IF ARRAYS ARE BEING USED).',1,1,
     *            I,0,2,TN,EWTI)
      ISAVE = 6
      GO TO 1600
C TOO MUCH ACCURACY REQUESTED FOR MACHINE PRECISION. -------------------
 1460 CONTINUE
      CALL D02NNQ(
     *' AT THE TIME T (=R1), TOO MUCH ACCURACY REQUESTED FOR PRECISION
     * OF THE MACHINE . SEE OPTIONAL OUTPUT RWORK(14)(=R2). ',1,0,0,0,2,
     *            TN,TOLSF)
      RWORK(14) = TOLSF
      ISAVE = 3
      GO TO 1600
C
C ERROR RETURNS FOR VALUES OF  ISTEP  =  -1, -2  OR  -4
C
 1480 CONTINUE
      IF (ISTEP.EQ.-4) THEN
         ISAVE = 7
         GO TO 1600
      ELSE
         ISAVE = 3 - ISTEP
         IF (ISAVE.EQ.8) ISAVE = 9
         GO TO 1540
      END IF
C
C INITIALISATION FAILED IN D02NNY
C
 1500 CONTINUE
      CALL D02NNQ(' ATTEMPT TO INITIALIZE DY/DT AND Y FAILED.',1,0,0,0,
     *            0,0.0D0,0.0D0)
      ISAVE = 8
      GO TO 2300
 1520 CONTINUE
      CALL D02NNQ(
     *' MONITR ROUTINE ERROR- ILLEGAL VALUE OF IMON(=I1) RETURNED
     * TO D02NNF',1,1,IMON,0,0,0.0D0,0.0D0)
      ISAVE = 1
      GO TO 2300
C
C COMPUTE IMXER IF RELEVANT. -------------------------------------------
C
 1540 CONTINUE
      BIG = 0.0D0
C205
C205     REPLACE THE FOLLOWING BLOCK OF CODE WITH SOMETHING LIKE:
C205     ASSIGN TEMP1(1),.DYN.N
C205     TEMP1(1) = VABS ( RWORK(LACOR;N), TEMP1(1) )
C205     TEMP1(1) = TEMP(1) * RWORK(LEWT;N)
C205     IMXER = Q8SMAXI(TEMP1) + 1
C205     FREE
C205
      IMXER = 1
      DO 1560 I = 1, N
         SIZE = ABS(RWORK(I+LACOR-1)*RWORK(I+LEWT-1))
         IF (BIG.LT.SIZE) THEN
            BIG = SIZE
            IMXER = I
         END IF
 1560 CONTINUE
CMBZ BLOCK DOWN TO 1800 COMMENTED OUT
C COMPUTE RESIDUAL IF RELEVANT. ----------------------------------------
C
C1740 DO 1760 I = 1, N
C        RWORK(I+LSAVR-1) = YSAVE(I,2)/H
C        Y(I) = YSAVE(I,1)
C1760 CONTINUE
C     IRES = 1
C
C     CALL RESID ( NEQ, TN, Y, RWORK(LSAVR), YDOTI, IRES, WKRES, NWKRES)
C
C     IREVCM = 5
C     GO TO 1880
 1580 CONTINUE
C     NRE = NRE + 1
C     IF (IRES.GT.1) THEN
C        CALL D02NNQ(
C    *' THE ROUTINE WHICH EVALUATES THE RESIDUAL SETS IRES
C    * TO (=I1) WHEN CALLED
C    * FOR FINAL OUTPUT',2,1,IRES,0,0,0.0D0,0.0D0)
C     END IF
C
C SET Y VECTOR AND T
C
 1600 CONTINUE
      DO 1620 I = 1, N
         Y(I) = YSAVE(I,1)
 1620 CONTINUE
      T = TN
C***********************************************************************
C           EXIT POINT FOR SUCCESSFUL RUNS OR FOR RUN TIME FAILURES.   *
C           LOAD ISTATE AND THE OPTIONAL OUTPUTS                       *
C***********************************************************************
 1640 CONTINUE
      RWORK(11) = HU
      RWORK(12) = H
      RWORK(13) = TN
      RWORK(14) = TOLSF
      INFORM(1) = NST
      INFORM(2) = NRE
      INFORM(3) = NJE
      INFORM(4) = NQU
      INFORM(5) = NQ
      INFORM(6) = NITER
      INFORM(8) = IMXER
      IREVCM = 0
      LDERIV(2) = IODE .EQ. 0
      IF (ITASK.NE.6) RWORK(40) = 1.0D0
      IF (NT1STP .AND. NST.EQ.ICHMAX .AND. ISAVE.EQ.0) ISAVE = 13
      IFAIL = P01ABF(IFAIL,ISAVE,SRNAME,0,P01REC)
      RETURN
C***********************************************************************
C          EXIT POINT FOR REVERSE COMMUNICATION CALLS TO               *
C                JAC , RESID AND MONITOR .                             *
C***********************************************************************
 1660 CONTINUE
      RWORK(19) = TN
      GO TO (1720,1720,1720,1720,1720,1720,1720,1680,1700,
     *       1720,1720) IREVCM
 1680 CONTINUE
      RWORK(16) = H
      RWORK(20) = EL0
      RETURN
 1700 CONTINUE
      RWORK(15) = HU
      RWORK(16) = H
      RWORK(17) = HMIN
      RWORK(18) = HMAX
      RWORK(10) = DBLE(NQU)
 1720 CONTINUE
      RETURN
C-----------------------------------------------------------------------
C BLOCK K.
C THE FOLLOWING BLOCK HANDLES ALL ERROR RETURNS DUE TO ILLEGAL INPUT
C (ISTATE = -3), AS DETECTED BEFORE CALLING THE CORE INTEGRATOR.
C FIRST THE ERROR MESSAGE ROUTINE IS CALLED AND THEN THE RUN IS HALTED.
C-----------------------------------------------------------------------
C
 1740 CONTINUE
      ERRMSG =
     *' AN INTEGRATOR SETUP ROUTINE HAS NOT BEEN CALLED OR THE USER HAS
     * OVERWRITTEN COMPONENTS IN THE WORK ARRAY RWORK. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2280
 1760 CONTINUE
      ERRMSG = ' THE INPUT VALUE OF ITASK (=I1) IS ILLEGAL.'
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,0,0.0D0,0.0D0)
      GO TO 2280
 1780 CONTINUE
      ERRMSG =
     *' INTERNAL VARIABLES INDICATE THAT THE ROUTINE WAS
     * ENTERED ON A CONTINUATION CALL, BUT THAT THE INTERNAL
     * INITIALISATION HAD NOT BEEN DONE. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ERRMSG =
     *        ' THE USER HAS PROBABLY OVERWRITTEN THE WORK ARRAY RWORK '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2280
 1800 CONTINUE
      ERRMSG =
     *' THE NUMBER OF ODE HAS ILLEGAL VALUE(=I1). ITS VALUE IS
     *  LESS THAN 1. '
      CALL D02NNQ(ERRMSG,1,1,NEQ,0,0,0.0D0,0.0D0)
      GO TO 2280
 1820 CONTINUE
      ERRMSG = ' ISTATE HAS BEEN SET=1 AND NEQ (=I1) .GT. NEQMAX(=I2). '
      CALL D02NNQ(ERRMSG,1,2,NEQ,NEQMAX,0,0.0D0,0.0D0)
      GO TO 2280
 1840 CONTINUE
      ERRMSG = ' THE VALUE OF ITOL(=I1) IS ILLEGAL.'
      CALL D02NNQ(ERRMSG,1,1,ITOL,0,0,0.0D0,0.0D0)
      GO TO 2280
 1860 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT MXSTEP HAS ILLEGAL VALUE (=I1)
     * LESS THAN 0.'
      CALL D02NNQ(ERRMSG,1,1,MXSTEP,0,0,0.0D0,0.0D0)
      GO TO 2280
 1880 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT MXHNIL HAS ILLEGAL VALUE (=I1) LESS
     * THAN 0 '
      CALL D02NNQ(ERRMSG,1,1,MXHNIL,0,0,0.0D0,0.0D0)
      GO TO 2280
 1900 CONTINUE
      ERRMSG = ' TOUT (=R1) BEHIND T (=R2) '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TOUT,T)
      ERRMSG =
     *  ' INTEGRATION DIRECTION IS GIVEN BY THE OPTIONAL INPU H0(=R1). '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,H0,0.0D0)
      GO TO 2280
 1920 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT HMAX HAS PROVIDED AN ILLEGAL MAXIMUM
     * STEPSIZE (=R1) LESS THAN  0.0. '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,HMAX,0.0D0)
      GO TO 2280
 1940 CONTINUE
      ERRMSG =
     *' THE OPTIONAL INPUT HMIN HAS PROVIDED AN ILLEGAL MINIMUM
     * STEPSIZE (=R1) LESS THAN 0.0. '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,HMIN,0.0D0)
      GO TO 2280
 1960 CONTINUE
      ERRMSG = ' RTOL(=I1) HAS ILLEGAL VALUE (=R1) LESS THAN 0.0'
      CALL D02NNQ(ERRMSG,1,1,I,0,1,RTOLI,0.0D0)
      GO TO 2280
 1980 CONTINUE
      ERRMSG =
     *     ' ATOL(=I1) HAS ILLEGAL VALUE (=R1) WHICH IS LESS THAN 0.0. '
      CALL D02NNQ(ERRMSG,1,1,I,0,1,ATOLI,0.0D0)
      GO TO 2280
 2000 CONTINUE
      EWTI = RWORK(LEWT+I-1)
      I = -IEWSET
      ERRMSG =
     *' THE WEIGHT USED IN THE LOCAL ERROR TEST EWT(I1)(=R1) IS
     * LESS THAN  0. CHECK THE VALUES OF RTOL AND ATOL. ATOL(I1) AND
     * Y(I1) MAY BOTH BE ZERO .'
      CALL D02NNQ(ERRMSG,1,1,I,0,1,EWTI,0.0D0)
      GO TO 2280
 2020 CONTINUE
      ERRMSG =
     *' TOUT(=R1) TOO CLOSE TO T(=R2) TO START                  THE INTE
     *GRATION.'
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TOUT,T)
      GO TO 2280
 2040 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK IS (=I1) AND TOUT (=R1) IS BEHIND
     * TCUR-HU (=R2) '
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,2,TOUT,TP)
      GO TO 2280
 2060 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK HAS BEEN SET TO 4 OR 5 AND THE
     * OPTIONAL INPUT TCRIT (=R1) IS BEHIND CURRENT TIME(=R2). '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TCRIT,TN)
      GO TO 2280
 2080 CONTINUE
      ERRMSG =
     *' THE VALUE OF ITASK HAS BEEN SET TO 4 OR 5 AND THE
     * OPTIONAL INPUT TCRIT (=R1) IS BEHIND TOUT(=R2). '
      CALL D02NNQ(ERRMSG,1,0,0,0,2,TCRIT,TOUT)
      GO TO 2280
 2100 CONTINUE
      ERRMSG = ' AT START OF PROBLEM, TOO MUCH ACCURACY REQUESTED. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ERRMSG =
     *' REQUESTED FOR PRECISION OF MACHINE. SEE TOLSF (=R1) AND THE
     *  DOCUMENTATION ON OPTIONAL OUTPUTS FOR THE MEANING OF THIS
     *  VALUE. '
      CALL D02NNQ(ERRMSG,1,0,0,0,1,TOLSF,0.0D0)
      ISAVE = 14
      RWORK(14) = TOLSF
      RWORK(11) = 0.0D0
      RWORK(12) = 0.0D0
      RWORK(13) = 0.0D0
      INFORM(1) = 0
      INFORM(2) = 0
      INFORM(3) = 0
      INFORM(4) = 0
      INFORM(5) = 0
      INFORM(6) = 0
      INFORM(8) = 0
      GO TO 2300
 2120 CONTINUE
      ERRMSG =
     *' TROUBLE FROM INTERNAL TIME INTERPOLATION ROUTINE WHEN
     * ITASK(=I1), AND TOUT(=R1). '
      CALL D02NNQ(ERRMSG,1,1,ITASK,0,1,TOUT,0.0D0)
      GO TO 2280
 2140 CONTINUE
      ERRMSG =
     *' THE ROUTINE THAT FORMS
     *  THE RESIDUAL OF THE ODE SYSTEM HAS NOT BEEN
     *  WRITTEN TO HANDLE THE CASE IRES(=I1) CORRECTLY.'
      CALL D02NNQ(ERRMSG,1,1,IRES,0,0,0.0D0,0.0D0)
      ERRMSG =
     *' THE ROUTINE WHICH EVALUATES THE RESIDUAL IS CALLED WITH
     * IRES (=I1) AND WITH A ZERO DY/DT VECTOR. CHECK ALL THE
     * ROUTINES WHICH EVALUATE THE FUNCTIONS DEFINING THE
     * SYSTEM OF EQUATIONS. '
      CALL D02NNQ(ERRMSG,1,1,IRES,0,0,0.D0,0.0D0)
      GO TO 2280
 2160 CONTINUE
      ERRMSG =
     *'  THE SIZE OF ODE SYSTEM WAS ILLEGALLY
     * INCREASED TO (=I1), WHICH IS GREATER THAN NEQMAX (=I2)'
      CALL D02NNQ(ERRMSG,1,2,NEQ,NEQMAX,0,0.0D0,0.0D0)
      GO TO 2280
 2180 CONTINUE
      ERRMSG =
     *' LINEAR ALGEBRA SETUP ROUTINE NOT CALLED OR USER HAS
     *OVERWRITTEN WORKSPACE HE SUPPLIED TO SETUP ROUTINE'
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      GO TO 2280
 2200 CONTINUE
      ERRMSG =
     *' NY2DIM (=I1) SUPPLIED TO D02NNF NOT THE SAME NY2DIM
     * (=I2) SUPPLIED TO O.D.E SETUP ROUTINE OR THE USER HAS
     * OVERWRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE.'
      CALL D02NNQ(ERRMSG,1,2,NY2DIM,MY2DIM,0,0.0D0,0.0D0)
      GO TO 2280
 2220 CONTINUE
      ERRMSG =
     *' NWKJAC (=I1) SUPPLIED TO D02NNF NOT THE SAME NWKJAC(=I2) SUP
     *PLIED TO LINEAR ALGEBRA SETUP ROUTINE OR THE USER HAS         OVER
     *WRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE'
      CALL D02NNQ(ERRMSG,1,2,NWKJAC,MWKJAC,0,0.0D0,0.0D0)
      GO TO 2280
 2240 CONTINUE
      ERRMSG =
     *' NJCPVT (=I1) SUPPLIED TO D02NNF NOT THE SAME NJCPVT(=I2)
     * SUPPLIED TO LINEAR ALGEBRA SETUP ROUTINE OR THE USER HAS
     * OVERWRITTEN THE WORK ARRAY HE SUPPLIED THE SETUP ROUTINE.'
      CALL D02NNQ(ERRMSG,1,2,NJCPVT,MJCPVT,0,0.0D0,0.0D0)
      GO TO 2280
 2260 CONTINUE
      ERRMSG =
     *' WORKSPACE ERROR OCCURRED IN THE
     *  LINEAR ALGEBRA ROUTINES -CHECK ARRAY SIZES '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ISAVE = 10
      GO TO 2300
C
 2280 CONTINUE
      ERRMSG = ' ILLEGAL INPUT - CHECK ALL THE INPUT. '
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
      ISAVE = 1
 2300 CONTINUE
      ERRMSG = ' RUN ABORTED.'
      CALL D02NNQ(ERRMSG,1,0,0,0,0,0.0D0,0.0D0)
C***********************************************************************
C        OUTPUT POINT FOR ILLEGAL INPUTS                               *
C        COPY BACK ISTATE PARAMETER                                    *
C***********************************************************************
      IREVCM = 0
      IFAIL = P01ABF(IFAIL,ISAVE,SRNAME,0,P01REC)
      RETURN
      END
